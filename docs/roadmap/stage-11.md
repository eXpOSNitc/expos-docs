---
title: 'Stage 11 : Introduction to ExpL (4 Hours)'
---

!!! info "Learning Objectives"
    - Familiarise with the use of ExpL for writing application programs
    - Familiarise with the ExpL high level library interface

!!! abstract "Pre-requisite Reading"
    Read and understand the

    1. <a href="support_tools-files/expl.html" target="_blank">ExpL Specification</a>
    2. <a href="os_spec-files/dynamicmemoryroutines.html">ExpL high level library interface</a>
    before proceeding further. 

    :warning: Read only the specification just enough to write simple programs in the language. Don't get lost in the links


ExpL is a high level language in which you can write high level application programs.
A compiler for ExpL supplied to you along with the eXpOS package will generate
target code compatible with the eXpOS specification.

ExpL permits application programs to call the function
exposcall() that implements the <a href="os_spec-files/dynamicmemoryroutines.html" target="_blank">high level library interface</a>
to the OS. Application programs must use this library interface to invoke eXpOS system calls. 
Certain built-in functions of the ExpL language (Alloc, Free and Initialize - these
functions handle ExpL dynamic memory management) are also implemented as ExpL library routines.
Note that the only way to invoke an eXpOS system call from
a high level ExpL program is to use the exposcall() function.


The ExpL library file library.lib supplied to you along with the eXpOS package contains
assembly language implementation of the library and occupies two pages of memory.
The OS design stipulates that this library code must be pre-loaded
to the XSM disk blocks 13 and 14 before OS bootstrap using XFS interface (see
<a href="os_implementation.html" target="_blank">disk layout</a>).
Your OS start up code is supposed to load this code into
memory pages 63 and 64 from disk blocks 13 and 14.

An ExpL program written by a programmer will contain library calls using the exposcall()
function. The ExpL compiler will translate these calls to assembly instructions calling the library as
specified <a href="abi.html" target="_blank">here</a> (see<b>low level runtime library interface</b>).

The compiler expects that the library will be loaded to the <b>logical address 0</b>of the
address space of the program. The target code generated by the compiler will not contain the
code for the library. Instead, the OS is expected to link this code (at physical pages 63 and
64)
into logical pages 0 and 1 when the program is loaded for execution.


Hence, when the OS loads a program for execution, the library code must be linked to the
logical pages 0 and 1 by setting the page table entries for the first two logical pages to 63 and 64. An ExpL
program will contain calls to the library and hence the library linkage must be done correctly for ExpL program to
run properly.

In the previous stages, you wrote and executed application programs in assembly language.
Now, you will write application programs in ExpL and compile it to generate the assembly
program. This compiled code is loaded into the XSM disk as done in previous stages.

1) Below is the ExpL program to print numbers upto 50. Save this program as numbers.expl in
`$HOME/myexpos/eXpl/samples.` This will be the init program in this stage.

```
int main()
{
decl
    int temp,num;
enddecl
begin
    num=1;
    while ( num &lt;= 50 ) do
         temp = exposcall ( "Write" , -2, num );
         num = num + 1;
    endwhile;
    return 0;
end
}
```

Refer <a href="http://silcnitc.github.io/testprograms.html" target="_blank"> here </a>
for more examples of ExpL programs.

2) Compile this program using the command
```
cd $HOME/myexpos/eXpl
./expl samples/numbers.expl
```

The ExpL compiler will write the target executable code into the file assemblycode.xsm. (You
will have to save the file to a different name before compiling the next ExpL program).

!!! note 
    The present version of ExpL compiles <filename>.expl into <filename>.xsm. 
    A copy of this target file is also wriiten into the file `assemblycode.xsm` for backward compatibility.

3) Load the compiled code as the init program into the XSM disk using XFS Interface.

4) Run the XSM machine.


??? question "Q1. If your ExpL program contains read() function call, will it work now?"
    Obviously not. The ExpL compiler will generate a call to the library
    requesting a console read; the library code in turn will generate an
    INT 6 for console input. Since you haven't written any code for INT 6,
    the OS will crash in INT 6. It will be an insightful exercise to trace the sequence
    of calls in debug mode.

!!! assignment "Assignment 1"
    Write an ExpL program to print all odd numbers from 1-100 and run the machine with this program loaded as the init.

!!! assignment "Assignment 2"
    Write an ExpL program to include a user defined type *Student* as follows
    
    ```
    Student
    {
    str name;
    int marks;
    }
    ```

    Declare a variable of type Student, assign values "John", 89 for name and marks respectively
    and print the values to the terminal. Run the machine with this as an init program. Don't
    forget to initialize the heap and allocate the memory for a variable before assigning values to
    its attributes.

!!! assignment "Assignment 3: Writing your own library"
    Instead of using the library implementation `library.lib`, write your own library (in assembly language) 
    to support only the write system call to console. Your library code must extract
    arguments from the stack, check whether the request is for a console write, if so call INT 7
    after supplying proper arguments in the stack as done in the previous stage. Upon return from 
    the system call, your library routine must set the return value through the stack (setting return value 
    in the proper location of the stack -see details <a href="abi.html#library" target="_blank">here</a>
    ) and return control back to the application.
 
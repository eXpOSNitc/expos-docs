{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"eXpOS NITC \u00b6 Project Infomation Source Code: https://github.com/exposnitc Contact: https://groups.google.com/g/xos-users Trial version , errors are being corrected as reported. Last updated: 22nd July 2021 (see Release Notes ) Project eXpOS (eXperimental Operating System) is an on-line educational platform which helps undergraduate students to learn the working on an operating system. A detailed project roadmap that is part of the platform provides step by step guidance to the student towards writing a small operating system from scratch. The student learns the implementation of various OS data structures and kernel routines during the course of the project. The OS written by the student will run on a machine simulator supplied along with the platform. The project assumes that the student has undergone a course in computer organization, and is comfortable with programming. Roadmap \u00b6 If you wish to work on the project, the approach we suggest is to follow the project roadmap. The roadmap takes you through a step by step journey towards the complete implementation of the operating system. At each step, you will be asked to read concepts, specifications and interfaces that are required for that step. In fact, you will be asked to read only what is necessary for completing that step. The links to the relevant reading material will be given at appropriate places in the roadmap. Proceed to Roadmap Final System \u00b6 If you are curious about what the \"final system\" you are going to build looks like, we give a brief overview here. You are warned not to get lost in the links. The roadmap will ask you to read the appropriate parts of the documentation as and when required. In the figure, an architecture simulator for the eXperimental String Machine (XSM) is given to you. Your primary job is to implement the eXpOS kernel for this machine in such a way that application programs can be loaded and executed by your kernel. You will also be asked to write a few application programs,\u00ad like the shell (for providing a user interface). Clearly, in order to write the OS kernel, one must be given its two interfaces \u2013 the interface to the architecture below and the interface to the executable application programs above. The former is given to you in the XSM architecture specification. The latter, called the Application Binary Interface specification, is also given to you. There are also two additional interfaces (not shown in the figure) described below: The format in which data and executable files are stored in the disk is standardized and given in the eXpFS file system specification . This standardization allows portability of files between eXpOS and other systems. You must implement the OS file system satisfying this interface specification. Specification for a small application layer software called the eXpOS Library is given to you. The library is a special application program that stands between the OS kernel and other application programs. The library provides a generic interface through which other applications can access the OS system calls. Dynamic memory management services of the OS are also implemented by the library. The library code will be supplied to you. Your OS kernel must load the library into memory and link it to the application programs at run time. Since you start with a bare machine with no software on it, you need some external mechanism to: Write the kernel modules and get them as XSM executable programs. Store these modules into the machine's disk so that they can be loaded to the memory and executed when the machine is powered on. We provide you with support tools for achieving the above objectives. For the first task, a cross compiler for an enriched XSM assembly language called the System Programming Language (SPL) is given to you. You can write the OS modules in the SPL language from your host (Linux/Unix) environment and generate XSM target programs using the SPL compiler. For the second task, we provide you with an interface software called the XFS interface .This tool allows you to transfer executable kernel modules from your host (Linux/Unix) system to specified blocks of the XSM disk. Thus, you can load the XSM target modules into the appropriate areas of the XSM disk. The following figure illustrates the OS development environment from an OS programmer's viewpoint. A similar mechanism is provided for preparing application programs and loading them to the machine's disk. A cross compiler for a tiny high level programming language called the Experimental Language (ExpL) is supplied to you. The ExpL compiler translates your program into the target executable format recognized by eXpOS. These programs can be stored in the XSM machine's disk using the XFS interface tool. The following figure illustrates the development environment from an application programmer's perspective. The OS that you build will be very elementary. There will be no system software like compilers or file editors that run on top of the OS. The OS will only be capable of loading into the memory and executing programs that are already pre-loaded into machine's disk before boot up. Hence, the only way to write application programs (or kernel code) for the OS will be to write the code from your host (Linux/Unix) system, compile the code using ExpL (or SPL) cross compiler and pre-load the target executable into the XSM disk using the XFS-Interface tool, before powering on the simulator. Once the OS modules and application programs are loaded into the XSM machine's disk, the XSM simulator can be used to bootstrap the OS into the machine memory and start execution. The collection of development tools given to you including the XSM simulator, compilers for ExpL and SPL and XFS Interface will be referred to as the \"eXpOS package\u201d in the eXpOS documentation. The following figure gives a high level picture of the OS that you will build by the end of the project. The eXpOS specification provides an informal description of OS from the view point of the user/application programmer. You may also have a quick look at the high level system design for a closer view of the OS. eXpOS evolved from a primitive version called XOS developed a few years back. The eXpOS FAQ and About us pages provide some more information. We wish you enjoy doing the project following the Roadmap .","title":"Home"},{"location":"#expos-nitc","text":"Project Infomation Source Code: https://github.com/exposnitc Contact: https://groups.google.com/g/xos-users Trial version , errors are being corrected as reported. Last updated: 22nd July 2021 (see Release Notes ) Project eXpOS (eXperimental Operating System) is an on-line educational platform which helps undergraduate students to learn the working on an operating system. A detailed project roadmap that is part of the platform provides step by step guidance to the student towards writing a small operating system from scratch. The student learns the implementation of various OS data structures and kernel routines during the course of the project. The OS written by the student will run on a machine simulator supplied along with the platform. The project assumes that the student has undergone a course in computer organization, and is comfortable with programming.","title":"eXpOS NITC"},{"location":"#roadmap","text":"If you wish to work on the project, the approach we suggest is to follow the project roadmap. The roadmap takes you through a step by step journey towards the complete implementation of the operating system. At each step, you will be asked to read concepts, specifications and interfaces that are required for that step. In fact, you will be asked to read only what is necessary for completing that step. The links to the relevant reading material will be given at appropriate places in the roadmap. Proceed to Roadmap","title":"Roadmap"},{"location":"#final-system","text":"If you are curious about what the \"final system\" you are going to build looks like, we give a brief overview here. You are warned not to get lost in the links. The roadmap will ask you to read the appropriate parts of the documentation as and when required. In the figure, an architecture simulator for the eXperimental String Machine (XSM) is given to you. Your primary job is to implement the eXpOS kernel for this machine in such a way that application programs can be loaded and executed by your kernel. You will also be asked to write a few application programs,\u00ad like the shell (for providing a user interface). Clearly, in order to write the OS kernel, one must be given its two interfaces \u2013 the interface to the architecture below and the interface to the executable application programs above. The former is given to you in the XSM architecture specification. The latter, called the Application Binary Interface specification, is also given to you. There are also two additional interfaces (not shown in the figure) described below: The format in which data and executable files are stored in the disk is standardized and given in the eXpFS file system specification . This standardization allows portability of files between eXpOS and other systems. You must implement the OS file system satisfying this interface specification. Specification for a small application layer software called the eXpOS Library is given to you. The library is a special application program that stands between the OS kernel and other application programs. The library provides a generic interface through which other applications can access the OS system calls. Dynamic memory management services of the OS are also implemented by the library. The library code will be supplied to you. Your OS kernel must load the library into memory and link it to the application programs at run time. Since you start with a bare machine with no software on it, you need some external mechanism to: Write the kernel modules and get them as XSM executable programs. Store these modules into the machine's disk so that they can be loaded to the memory and executed when the machine is powered on. We provide you with support tools for achieving the above objectives. For the first task, a cross compiler for an enriched XSM assembly language called the System Programming Language (SPL) is given to you. You can write the OS modules in the SPL language from your host (Linux/Unix) environment and generate XSM target programs using the SPL compiler. For the second task, we provide you with an interface software called the XFS interface .This tool allows you to transfer executable kernel modules from your host (Linux/Unix) system to specified blocks of the XSM disk. Thus, you can load the XSM target modules into the appropriate areas of the XSM disk. The following figure illustrates the OS development environment from an OS programmer's viewpoint. A similar mechanism is provided for preparing application programs and loading them to the machine's disk. A cross compiler for a tiny high level programming language called the Experimental Language (ExpL) is supplied to you. The ExpL compiler translates your program into the target executable format recognized by eXpOS. These programs can be stored in the XSM machine's disk using the XFS interface tool. The following figure illustrates the development environment from an application programmer's perspective. The OS that you build will be very elementary. There will be no system software like compilers or file editors that run on top of the OS. The OS will only be capable of loading into the memory and executing programs that are already pre-loaded into machine's disk before boot up. Hence, the only way to write application programs (or kernel code) for the OS will be to write the code from your host (Linux/Unix) system, compile the code using ExpL (or SPL) cross compiler and pre-load the target executable into the XSM disk using the XFS-Interface tool, before powering on the simulator. Once the OS modules and application programs are loaded into the XSM machine's disk, the XSM simulator can be used to bootstrap the OS into the machine memory and start execution. The collection of development tools given to you including the XSM simulator, compilers for ExpL and SPL and XFS Interface will be referred to as the \"eXpOS package\u201d in the eXpOS documentation. The following figure gives a high level picture of the OS that you will build by the end of the project. The eXpOS specification provides an informal description of OS from the view point of the user/application programmer. You may also have a quick look at the high level system design for a closer view of the OS. eXpOS evolved from a primitive version called XOS developed a few years back. The eXpOS FAQ and About us pages provide some more information. We wish you enjoy doing the project following the Roadmap .","title":"Final System"},{"location":"abi/","text":"An application binary interface (ABI) is the interface between a user program and the kernel. The eXpOS ABI defines the following: The machine model - that is, the instruction set and the virtual memory address space to which an application/compiler generating executable file must generate target code for. This is very much architecture specific. A logical division of the memory address space into regions - text, stack, heap and library and the low level (assembly/machine level) system call interface. This part is dependent on both the OS and the architecture. The file format to be followed for executable files by the compiler (the XEXE executable file format). This part is generally OS specific and architecture independent. Compilers must generate executable files adhering to this format. A low level system call interface which gives the specification of the software interrupt instruction (trap) corresponding to each system call and the order in which arguments must be passed to the system call through the application program's stack.This part is architecture dependent. The low level runtime library interface : The low level runtime library interface consists of user level routines which provide a layer of abstraction between the low level system call interface and the application program by providing a unified interface for all system calls, hiding low level interrupt details from the application. (Applications however, may choose to bypass this layer and directly invoke the low level system calls.) In addition to the system call interface, application level dynamic memory allocator and deallocator functions are also part of the eXpOS library. XSM User Level Instruction Set \u00b6 XSM Instruction set describes the target language in which a compiler must generate an executable file. Instructions are classified into privileged and unprivileged instructions. Since application programs run in the user mode, they can make use of only unprivileged instructions. You can read more about the XSM user level instruction set here . Virtual Address Space Model \u00b6 The (virtual) address space of any eXpOS process is logically divided into four parts namely Shared Library, Heap, Code and Stack . Shared library can be shared by more than one executable file. The maximum size of this memory region is X_LSIZE. Note eXpOS provides a library that provides a unified interface for system calls and dynamic memory allocation/deallocation routines. The library is pre-loaded into memory at the time of OS startup and is linked to the address space of a process when an executable program is loaded into the memory for execution if required (as determined by the Library flag in the executable file ) . The eXpOS implementation for the XSM architecture discussed here sets X_LSIZE to 1024 words. Thus the shared library will be loaded into the region between memory addresses 0 and 1023 in the address space of the process. Heap is the portion of the address space of a process reserved as the memory pool from which dynamic memory allocation is done by the allocator routines in the shared library (for example, memory allocated via malloc in C). The maximum size of this memory region is X_HSIZE. Library functions access this portion of memory for dynamic memory allocation and deallocation. The eXpOS execution semantics specify that when a process executes the Fork system call, this region will be shared between the parent process and the child process. The eXpOS implementation for the XSM architecture discussed here sets X_HSIZE to 1024 words. Thus the heap region will be between memory addresses 1024 and 2047 in the address space of the process. Code contains the header and code part of the XEXE executable file, which is loaded by the eXpOS loader from the file system when the Exec system call is executed. The first eight words of the executable file contains the header. The rest of the code region contains the XSM instructions. The total size of code section cannot exceed X_CSIZE. The eXpOS implementation for the XSM architecture discussed here sets X_CSIZE to 2048 words. Hence, the code region will be between memory addressess 2048 and 4095 in the address space of the process. Stack is the space reserved for the runtime stack of the process. Parameters and local variables associated with functions in a program are allocated in the stack. In the XSM architecture, the stack grows upwards and the maximum stack size is X_SSIZE. Global variables are normally allocated in the stack as the executable file format does not support a separate Data region . The eXpOS implementation for the XSM architecture discussed here sets X_SIZE to 1024 words.Thus the stack will occupy the region between memory address 4096 and 5119 in the address space of the process. A description of the user level address space provided by XSM is given here . XEXE Executable File Format \u00b6 Executable files in eXpOS must be in the XEXE format as eXpOS executes only files of such format. An XEXE executable file in eXpOS consists of two parts: 1. Header 2. Code The maximum size of the file (including the header) is limited by the constant EXE_SIZE. The eXpOS implementation for the XSM architecture discussed here sets EXE_SIZE to 2048 words. The first eight words of an executable file are reserved for the header which describes the features of file. The structure of the header is : XMAGIC is a number indicating the type of executable file. All XEXE files will have magic number 0. For more on Magic Number, click here . Entry point contains the virtual address in memory of the first instruction to be executed (entry point) of the program after the OS loader has loaded it. During loading, the program counter must be initialized to this address. Text Size , Data Size , Heap Size and Stack size indicates the sizes of Text, Data, Heap and Stack regions to be allocated by the OS loader when the file is loaded for execution. Note The present eXpOS virtual address space model requires that the data and stack must be in the same memory area and must be managed by the compiler / application program (this means that the program must contain the code to initialize the value of the stack pointer). The value of Data Size field is ignored. Moreover, the eXpOS loader ( exec system call ) sets the size of text region to 2048 words and stack region to 1024 words in memory irrespective of the values present in the header. If the Runtime Library must be included when the file is loaded, the Library Flag is set to 1 in the executable file. If this flag is not set then neither memory is allocated for the heap nor the library linked to the address space of the process by the eXpOS loader at execution time. In summary, the eXpOS loader maps an executable file into its virtual address according to the following table : Region Start Address End Address Library* 0 1023 Heap* 1024 2047 Code** 2048 4095 Stack\u2020 4096 5119 * If Library Flag is set to 1 in the executable header. ** The eXpOS loader sets IP to the value specified in the program header. \u2020 The eXpOS loader does not gurentee that the values of SP and BP are initialised to the base address of the stack region. Hence the executable program must contain code to initialise these registers. Low Level System Call Interface \u00b6 The Low level system call interface describes the conventions to be followed by application programs that invoke eXpOS system calls on the XSM architecture. The interface describes the software interrupt instruction (trap) corresponding to each system call and the calling conventions for passing arguments and extracting return values of the system call through the application program's stack. This part is architecture dependent. Note If a high level language like ExpL is used for writing application programs, then the application programs will be using the high level library interface for invoking system calls. The ExpL compiler is responsible for generating assembly language code to translate the call to a corresponding library call using the low level library interface. The ExpL library which is pre-loaded into the system memory during eXpOS boot up contains assembly language code that redirects the library call to the corresponding eXpOS system call using the low level system call interface described here. If you write assembly language application programs as user programs, then you can use the low level system call interface directly bye-passing the library. System Calls \u00b6 For an application program, there are two stages in executing a system call: 1) Before the system call : The calling application must set up the arguments in the (user) stack before executing the trap instruction. Important Note The calling application is supposed to save its register context into the stack before making a system call.The system call is not expected to save the user context of the calling application. However, the ExpL calling convention (unfortunately) does not save the Base Pointer Register (BP) before the call. Hence, the OS implementation must be careful to save the value of the register. 2) After the system call : The return value of the system call must be extracted from the stack. Invoking a system call \u00b6 A user program invokes a system call by first pushing the system call number and then the arguments into the stack and then invoking the INT machine instruction corresponding to the system call. The eXpOS ABI stipulates that the number of arguments pushed into the stack is fixed at three. PUSH System_Call_Number // Push system call number PUSH Argument_1 // Push argument 1 to the stack PUSH Argument_2 // Push argument 2 to the stack PUSH Argument_3 // Push argument 3 to the stack PUSH R0 // Push an empty space for RETURN VALUE INT number // Invoke the corresponding INT instruction. // The number can be any number between 4 and 18 A system call invocation using the high level application programmer's interface of a programming language like ExpL compiles to a set of machine instructions (see the instructions to the left). They are the stack operations that must be performed by the user program before the INT instruction is executed. The arguments must be pushed into the stack in such a way that the last argument comes on the top. An additional push instruction ('PUSH R0') is inserted to have an empty space in the stack for the return value. The system call implementation must ensure that the return value is stored in this space. The system call number is also pushed to the stack. The interrupt routine needs this value to identify the system call. The figure to the left shows the data stored in process stack just before an INT instruction. The INT instruction in XSM will push the value of IP + 2 on to the stack. This is the address of the instruction immediately following the INT instruction in the user program. Each instruction is 2 words, hence IP is incremented by 2. Upon execution of the IRET instruction from the system call, execution resumes from this value of IP. The INT instruction changes mode from User mode to Kernel mode and passes control to the Interrupt Routine corresponding to the system call. The figure to the right shows the contents of the stack immediately after the execution of the INT instruction. After return from the system call \u00b6 The IRET instruction transfers control back to the user program to the instruction immediately following the INT instruction. The following machine instructions are present after the INT instruction in the ExpL compiled machine code given in the previous step. POP Ri // Pop and save the return value into some register Ri POP Rj // Pop and discard argument 3 POP Rj // Pop and discard argument 2 POP Rj // Pop and discard argument 1 POP Rj // Pop and discard the system call number // Now the stack is popped back to the state before call The machine code to the left pops the values from the stack. The system call number and arguments were inputs to the system call and hence they may be discarded now. The return value which is stored in the stack by the system call is fetched and used by the user program by popping out to some register. System calls and their translation \u00b6 Associated with each system call, there is a system call number and interrupt routine number. The system call number is used to identify a system call. The interrupt routine number denotes the number of the interrupt routine which handles the system call. An interrupt routine may handle more than one system call. Mapping of system calls to interrupt numbers and corresponding system call interface specification with details of arguments and return values of system calls are given in the eXpOS Low Level System Call Interface Documentation. Low Level Runtime Library Interface \u00b6 The eXpOS library consists of a collection of user level routines provided as part of the operating system. These routines are loaded to the memory during OS start up and can be linked to the address space of any user process by the OS loader (exec system call). The OS loader will link these routines to the shared library region of the address space (see address space) if the library flag in the header of the executable file being loaded is set to 1 (see xexe). The library provides a uniform interface through which an application program can invoke system calls and dynamic memory allocation / deallocation routines by providing the function code and the arguments. The interface hides the details of the interrupt service routines corresponding to the system calls from the application, thereby making them architecture independent. The library also provides user level routines for dynamic memory management (allocation and de-allocation) from the heap region of the application. The library routine is linked to virtual address 0 of the address space of a process by the OS loader and requires four arguments (function code and three arguments to the system call / memory management routine) to be passed through the stack. The routine invokes the corresponding low level system call / memory management routine and returns to the user program the return value of the system call / memory management routine through the stack. The figure to the side shows the contents of the stack immediately before a call to this library routine. The invocation details for the system calls and the dynamic memory management routines using the library interface can be seen in the eXpOS High Level Library Interface documentation. Invoking a library module \u00b6 PUSH Function_Code // Push Function Code PUSH Argument_1 // Push argument 1 to the stack PUSH Argument_2 // Push argument 2 to the stack PUSH Argument_3 // Push argument 3 to the stack PUSH R0 // Push an empty space for RETURN VALUE CALL 0 // Pass the control to virtual address 0. // (eXpOS loader links the library to virtual address 0) A library module invocation using the high level application programmer's interface of a programming language like ExpL compiles to a set of machine instructions (see the instructions to the right). They are the stack operations that must be performed by the user program before the CALL instruction is executed. After return from the library module \u00b6 The following machine instructions are present after the CALL instruction in the ExpL compiled machine code given in the previous step. POP Ri // Pop and save the return value into some register Ri POP Rj // Pop and discard argument 3 POP Rj // Pop and discard argument 2 POP Rj // Pop and discard argument 1 POP Rj // Pop and discard the function code // Now the stack is popped back to the state before call The machine code to the left pops the values from the stack. The function code and arguments were inputs to the library module and hence they may be discarded now. The return value which is stored in the stack by the system call is fetched and used by the user program by popping out to some register. Note If application programs are written in a high level language like ExpL, the exposcall() function will be used to make system calls/invoke dynamic memory routines. The programmer does not have to worry about the library interface specified here because the ExpL compiler will automatically generate assembly code that translate the high level call to a low level call to the library using the above interface and retrieve return values from the call. eXpOS pre-loads the library into the memory at boot time. The library re-directs system call requests to the OS through the low level system call interface. Dynamic memory mangement functions are implemented as part of the library itself.","title":"Low Level Library Interface"},{"location":"abi/#xsm-user-level-instruction-set","text":"XSM Instruction set describes the target language in which a compiler must generate an executable file. Instructions are classified into privileged and unprivileged instructions. Since application programs run in the user mode, they can make use of only unprivileged instructions. You can read more about the XSM user level instruction set here .","title":"XSM User Level Instruction Set"},{"location":"abi/#virtual-address-space-model","text":"The (virtual) address space of any eXpOS process is logically divided into four parts namely Shared Library, Heap, Code and Stack . Shared library can be shared by more than one executable file. The maximum size of this memory region is X_LSIZE. Note eXpOS provides a library that provides a unified interface for system calls and dynamic memory allocation/deallocation routines. The library is pre-loaded into memory at the time of OS startup and is linked to the address space of a process when an executable program is loaded into the memory for execution if required (as determined by the Library flag in the executable file ) . The eXpOS implementation for the XSM architecture discussed here sets X_LSIZE to 1024 words. Thus the shared library will be loaded into the region between memory addresses 0 and 1023 in the address space of the process. Heap is the portion of the address space of a process reserved as the memory pool from which dynamic memory allocation is done by the allocator routines in the shared library (for example, memory allocated via malloc in C). The maximum size of this memory region is X_HSIZE. Library functions access this portion of memory for dynamic memory allocation and deallocation. The eXpOS execution semantics specify that when a process executes the Fork system call, this region will be shared between the parent process and the child process. The eXpOS implementation for the XSM architecture discussed here sets X_HSIZE to 1024 words. Thus the heap region will be between memory addresses 1024 and 2047 in the address space of the process. Code contains the header and code part of the XEXE executable file, which is loaded by the eXpOS loader from the file system when the Exec system call is executed. The first eight words of the executable file contains the header. The rest of the code region contains the XSM instructions. The total size of code section cannot exceed X_CSIZE. The eXpOS implementation for the XSM architecture discussed here sets X_CSIZE to 2048 words. Hence, the code region will be between memory addressess 2048 and 4095 in the address space of the process. Stack is the space reserved for the runtime stack of the process. Parameters and local variables associated with functions in a program are allocated in the stack. In the XSM architecture, the stack grows upwards and the maximum stack size is X_SSIZE. Global variables are normally allocated in the stack as the executable file format does not support a separate Data region . The eXpOS implementation for the XSM architecture discussed here sets X_SIZE to 1024 words.Thus the stack will occupy the region between memory address 4096 and 5119 in the address space of the process. A description of the user level address space provided by XSM is given here .","title":"Virtual Address Space Model"},{"location":"abi/#xexe-executable-file-format","text":"Executable files in eXpOS must be in the XEXE format as eXpOS executes only files of such format. An XEXE executable file in eXpOS consists of two parts: 1. Header 2. Code The maximum size of the file (including the header) is limited by the constant EXE_SIZE. The eXpOS implementation for the XSM architecture discussed here sets EXE_SIZE to 2048 words. The first eight words of an executable file are reserved for the header which describes the features of file. The structure of the header is : XMAGIC is a number indicating the type of executable file. All XEXE files will have magic number 0. For more on Magic Number, click here . Entry point contains the virtual address in memory of the first instruction to be executed (entry point) of the program after the OS loader has loaded it. During loading, the program counter must be initialized to this address. Text Size , Data Size , Heap Size and Stack size indicates the sizes of Text, Data, Heap and Stack regions to be allocated by the OS loader when the file is loaded for execution. Note The present eXpOS virtual address space model requires that the data and stack must be in the same memory area and must be managed by the compiler / application program (this means that the program must contain the code to initialize the value of the stack pointer). The value of Data Size field is ignored. Moreover, the eXpOS loader ( exec system call ) sets the size of text region to 2048 words and stack region to 1024 words in memory irrespective of the values present in the header. If the Runtime Library must be included when the file is loaded, the Library Flag is set to 1 in the executable file. If this flag is not set then neither memory is allocated for the heap nor the library linked to the address space of the process by the eXpOS loader at execution time. In summary, the eXpOS loader maps an executable file into its virtual address according to the following table : Region Start Address End Address Library* 0 1023 Heap* 1024 2047 Code** 2048 4095 Stack\u2020 4096 5119 * If Library Flag is set to 1 in the executable header. ** The eXpOS loader sets IP to the value specified in the program header. \u2020 The eXpOS loader does not gurentee that the values of SP and BP are initialised to the base address of the stack region. Hence the executable program must contain code to initialise these registers.","title":"XEXE Executable File Format"},{"location":"abi/#low-level-system-call-interface","text":"The Low level system call interface describes the conventions to be followed by application programs that invoke eXpOS system calls on the XSM architecture. The interface describes the software interrupt instruction (trap) corresponding to each system call and the calling conventions for passing arguments and extracting return values of the system call through the application program's stack. This part is architecture dependent. Note If a high level language like ExpL is used for writing application programs, then the application programs will be using the high level library interface for invoking system calls. The ExpL compiler is responsible for generating assembly language code to translate the call to a corresponding library call using the low level library interface. The ExpL library which is pre-loaded into the system memory during eXpOS boot up contains assembly language code that redirects the library call to the corresponding eXpOS system call using the low level system call interface described here. If you write assembly language application programs as user programs, then you can use the low level system call interface directly bye-passing the library.","title":"Low Level System Call Interface"},{"location":"abi/#system-calls","text":"For an application program, there are two stages in executing a system call: 1) Before the system call : The calling application must set up the arguments in the (user) stack before executing the trap instruction. Important Note The calling application is supposed to save its register context into the stack before making a system call.The system call is not expected to save the user context of the calling application. However, the ExpL calling convention (unfortunately) does not save the Base Pointer Register (BP) before the call. Hence, the OS implementation must be careful to save the value of the register. 2) After the system call : The return value of the system call must be extracted from the stack.","title":"System Calls"},{"location":"abi/#invoking-a-system-call","text":"A user program invokes a system call by first pushing the system call number and then the arguments into the stack and then invoking the INT machine instruction corresponding to the system call. The eXpOS ABI stipulates that the number of arguments pushed into the stack is fixed at three. PUSH System_Call_Number // Push system call number PUSH Argument_1 // Push argument 1 to the stack PUSH Argument_2 // Push argument 2 to the stack PUSH Argument_3 // Push argument 3 to the stack PUSH R0 // Push an empty space for RETURN VALUE INT number // Invoke the corresponding INT instruction. // The number can be any number between 4 and 18 A system call invocation using the high level application programmer's interface of a programming language like ExpL compiles to a set of machine instructions (see the instructions to the left). They are the stack operations that must be performed by the user program before the INT instruction is executed. The arguments must be pushed into the stack in such a way that the last argument comes on the top. An additional push instruction ('PUSH R0') is inserted to have an empty space in the stack for the return value. The system call implementation must ensure that the return value is stored in this space. The system call number is also pushed to the stack. The interrupt routine needs this value to identify the system call. The figure to the left shows the data stored in process stack just before an INT instruction. The INT instruction in XSM will push the value of IP + 2 on to the stack. This is the address of the instruction immediately following the INT instruction in the user program. Each instruction is 2 words, hence IP is incremented by 2. Upon execution of the IRET instruction from the system call, execution resumes from this value of IP. The INT instruction changes mode from User mode to Kernel mode and passes control to the Interrupt Routine corresponding to the system call. The figure to the right shows the contents of the stack immediately after the execution of the INT instruction.","title":"Invoking a system call"},{"location":"abi/#after-return-from-the-system-call","text":"The IRET instruction transfers control back to the user program to the instruction immediately following the INT instruction. The following machine instructions are present after the INT instruction in the ExpL compiled machine code given in the previous step. POP Ri // Pop and save the return value into some register Ri POP Rj // Pop and discard argument 3 POP Rj // Pop and discard argument 2 POP Rj // Pop and discard argument 1 POP Rj // Pop and discard the system call number // Now the stack is popped back to the state before call The machine code to the left pops the values from the stack. The system call number and arguments were inputs to the system call and hence they may be discarded now. The return value which is stored in the stack by the system call is fetched and used by the user program by popping out to some register.","title":"After return from the system call"},{"location":"abi/#system-calls-and-their-translation","text":"Associated with each system call, there is a system call number and interrupt routine number. The system call number is used to identify a system call. The interrupt routine number denotes the number of the interrupt routine which handles the system call. An interrupt routine may handle more than one system call. Mapping of system calls to interrupt numbers and corresponding system call interface specification with details of arguments and return values of system calls are given in the eXpOS Low Level System Call Interface Documentation.","title":"System calls and their translation"},{"location":"abi/#low-level-runtime-library-interface","text":"The eXpOS library consists of a collection of user level routines provided as part of the operating system. These routines are loaded to the memory during OS start up and can be linked to the address space of any user process by the OS loader (exec system call). The OS loader will link these routines to the shared library region of the address space (see address space) if the library flag in the header of the executable file being loaded is set to 1 (see xexe). The library provides a uniform interface through which an application program can invoke system calls and dynamic memory allocation / deallocation routines by providing the function code and the arguments. The interface hides the details of the interrupt service routines corresponding to the system calls from the application, thereby making them architecture independent. The library also provides user level routines for dynamic memory management (allocation and de-allocation) from the heap region of the application. The library routine is linked to virtual address 0 of the address space of a process by the OS loader and requires four arguments (function code and three arguments to the system call / memory management routine) to be passed through the stack. The routine invokes the corresponding low level system call / memory management routine and returns to the user program the return value of the system call / memory management routine through the stack. The figure to the side shows the contents of the stack immediately before a call to this library routine. The invocation details for the system calls and the dynamic memory management routines using the library interface can be seen in the eXpOS High Level Library Interface documentation.","title":"Low Level Runtime Library Interface"},{"location":"abi/#invoking-a-library-module","text":"PUSH Function_Code // Push Function Code PUSH Argument_1 // Push argument 1 to the stack PUSH Argument_2 // Push argument 2 to the stack PUSH Argument_3 // Push argument 3 to the stack PUSH R0 // Push an empty space for RETURN VALUE CALL 0 // Pass the control to virtual address 0. // (eXpOS loader links the library to virtual address 0) A library module invocation using the high level application programmer's interface of a programming language like ExpL compiles to a set of machine instructions (see the instructions to the right). They are the stack operations that must be performed by the user program before the CALL instruction is executed.","title":"Invoking a library module"},{"location":"abi/#after-return-from-the-library-module","text":"The following machine instructions are present after the CALL instruction in the ExpL compiled machine code given in the previous step. POP Ri // Pop and save the return value into some register Ri POP Rj // Pop and discard argument 3 POP Rj // Pop and discard argument 2 POP Rj // Pop and discard argument 1 POP Rj // Pop and discard the function code // Now the stack is popped back to the state before call The machine code to the left pops the values from the stack. The function code and arguments were inputs to the library module and hence they may be discarded now. The return value which is stored in the stack by the system call is fetched and used by the user program by popping out to some register. Note If application programs are written in a high level language like ExpL, the exposcall() function will be used to make system calls/invoke dynamic memory routines. The programmer does not have to worry about the library interface specified here because the ExpL compiler will automatically generate assembly code that translate the high level call to a low level call to the library using the above interface and retrieve return values from the call. eXpOS pre-loads the library into the memory at boot time. The library re-directs system call requests to the OS through the low level system call interface. Dynamic memory mangement functions are implemented as part of the library itself.","title":"After return from the library module"},{"location":"about/","text":"eXpOS Philosophy \u00b6 Any pedagogical operating system project offered as part of an undergraduate junior level operating system course needs to satisfy two requirements: The student must be given as much depth and detail as possible about the central operating system concepts. The quantity of work involved must not exceed what a student is able to do in a four month semester. The problem before the teacher is to decide on how much compromise on (1) must be done in favour of (2). eXpOS is our stance in this matter. There are three central principles that have been kept in mind in designing the eXpOS educational tool: Separation of concerns Things shall be made as simple as possible, but no simpler \"Build to learn\" rather than \"learn to build\" These thoughts have translated into the following decisions: Keep the upward and downward interfaces of the OS kernel idealistically simple \u2013 This means: The architecture platform on which the OS is implemented is kept simple to understand and program, yet capable of supporting virtual memory, interrupt driven disk/IO, time sharing, exception handling, demand paging etc. The application programming interface ( API ) (and the application binary interface \u00ad(ABI) ) provided by the OS are kept simple and minimal. The OS specification has been kept as simple as possible from the viewpoint of the OS programmer. The OS features are minimal, some of them being: co-operative multi-tasking a simple single-directory file system where processes can create, write, read and delete data files provision for processes to share files and memory primitives for interprocess communication (binary semaphores) and process synchronization (signal-wait) support for multiple users demand-paged memory management The OS code has to be completely written by the student with no built-in code given, except for a bootstrap ROM code and code implementing an application level library interface . The programming support has been kept minimal to avoid high level programming tools hiding too many low level issues from the OS programmer. Essentially, the student has to do \u201clow level programming\u201d on a \u201chigh level hardware\". The system is designed to help the student appreciate the functioning of a \u201csufficiently complex\u201d operating system and not to help him/her gain experience with real operating systems programming. The architecture, the OS, the API, ABI etc. are all different from any of the existing real systems or standards in use, but designed to make the task of programming the OS as simple as possible. Since the operating system kernel is a software that forms a layer between the hardware and the application program, the first major hurdle that a student faces while writing an OS is in understanding the complexities of the underlying hardware. The eXpOS package simplifies this by providing a hypothetical simple-to-program hardware abstraction \u2013 the XSM Machine . What makes XSM simple is that its memory words can store an arbitrary string or a number. This means that data formatting \u2013 one of the major technicalities while working with machines - is simplified. Further simplifications include the assumption that each disk block fits into exactly one memory page etc. The OS code can be written by programming the machine using a simple to learn SPL language (which is just an enriched XSM assembler). The second interface of the OS is its upward interface \u2013 the interface to application programs. This interface, called the application binary interface ( \u00adABI ), defines the low level system call interface between the application and the OS, the virtual address space model for an application, the format of executable files etc. The ABI too is kept minimal. It is easy to load executables into the memory. Only small programs are permitted. Parameter passing between applications and the system calls is also extremely simple. The eXpOS \u00adABI is too primitive to support application programs in the C programming language. Hence we provide a separate language (called ExpL ) using which applications can be created and compiled. The ExpL compiler given to the student supports the eXpOS high level application program interface ( API ). We note here that, implementing an ExpL compiler for the eXpOS ABI on the XSM machine would be an instructive exercise for an undergraduate compiler design laboratory. (See ExpL compiler project .) We are of the view that insisting the student to work with real systems diverts his/her attention to the details of various \u201cformats, standards and interfaces\" which often comes in the way of appreciating the underlying principles of OS design. eXpOS separates concerns by providing minimal interfaces that are just sufficient to achieve the required functionality. The development methodology suggested is to start from scratch with a simple bootstrap loader. Routines for handling the timer, disk and I/O devices shall be added next. A simple program loader that can load and execute applications from the disk can be written at this point. Single process operation will be possible at this stage. Following this, modules to support multi-tasking, Interprocess communication and process synchronization can be added. A file system can now be built on top of this structure. Multi-user support may be added next and finally full scale virtual memory management with swapping and demand paging shall be implemented. (A final stage adding support for multiprocessor operation is also intended.) The roadmap guides the student systematically through these stages, asking him/her to follow the links and learn the concepts relevant to the OS modules developed in each stage. There are two aspects associated with the design and implementation of each major component of an OS. \u2013 1) A Policy and 2) An implementation Mechanism. For example, the OS may specify a policy that each process is allowed it's own logical address space starting from 0 to a particular limit. Paging is a hardware mechanism that allows the OS to implement the policy. As another example, child processes inheriting open file instances from its parent process is a policy. The mechanism used by eXpOS to implement the policy is to keep a shared file seek position in an open file table. The pedagogical strategy followed here is to keep policies excessively simple so that the student can easily implement the policy, once the implementation mechanism is understood. For instance, in this project, size of the address space of a process is fixed by the OS, the file system does not have a directory structure and so on. To quickly prepare the students for the implementation, we provide detailed tutorials on various implementation mechanisms (like hardware paging) necessary to implement the policies. Our belief is that once the student completes the implementation of a simple policy using a particular mechanism, she will be in a position to visualize the implementation of more sophisticated policies that uses similar mechanisms without actually going through another implementation project. It is our belief that the experiment will provide the student with a feel for how the OS modules for process management, memory management, file management, device management, inter-process communication, process sychronization, demand paging and user management can be glued together to form a functional operating system. An appreciation for the Operating System's hardware interface, application interface and run time library linkage is also intended. We had tried our best to ensure that the spirit of the subject matter is not lost. However there have been compromises. The multi-user support, the file system and device handling are very primitive. Address space of a process is small and cannot expand at run time. Going further in these directions would make it difficult for the project to be completed in a semester. Some of these extensions are not \u201cin principle\u201d hard, once the basic OS is built. However topics such as pre-emptive multitasking, fault tolerance, system security etc. are beyond the scope of this project. The project presumes that the student has undergone a basic sophomore course in computer organization and data structures and has either completed or is currently undergoing a theory course in operating systems. The project does not require the student to be familar with the principles of compilers. It is not expected that the student has a high level of proficiency in programming or computer hardware. The required background on paging hardware, interrupts, run\u00adtime stack of application programs etc. are provided as reading material at appropriate places in the project roadmap. The parameter passing convention of ExpL as well as the system call interface are pretty simple so that students will have no serious difficulty in extracting parameters inside system calls and sending back return values to the application, despite not having undergone a compiler design course. It must be emphasized that the project by no means a replacement to a theory course in operating systems, but is only designed to suppliment it. eXpOS evolved from an earlier version (called XOS ) which was successfully used for undergraduate instruction at the department of Computer Science and Engineering, NIT Calicut. eXpOS extends XOS with multi\u00aduser support, co\u00adoperative multi\u00adtasking, interrupt based disk transfer and interprocess communication facility. Both these platforms were developed by teams of undergraduate CSE students of NIT Calicut through a series of undergraduate major projects. Authors \u00b6 The content in the website and the documentation has been authored in the Department of Computer Science and Engineering, National Institute of Technology, Calicut under the guidance of Dr. Murali Krishnan K. The project's activity started in the year 2010 and is currently under progress. Below is a list of co-authors and contributors to the project. The work evolved from an earlier version of the project called the XOS project under the guidance of Dr. Murali Krishnan K. 2018-2019 Arun Joseph Rohith Vishnumolakala 2017-2018 Kandhala Naveena Navaneeth Kishore Sumedha Birajdar 2016-2017 Akhil S Karthika Aravind N Ruthvik Thallam Sai Sree Datta 2015-2016 Anjana Babu Christin V Jose Kurian Jacob Leny W V Aleena Thomas Reshma Sreekumar Reshma Thomas Nunnaguppala Surya Harsha Vishnupriya Matha 2014-2015 Kruthika Suresh Ved Sikha V Manoj Sonia V Mathew Aswathy T Revi Subhisha Gautham R Warrier Glen Martin Govind R 2012-2013 Shamil C M Sreeraj S Vivek Anand T Kallampally 2010-2012 Ajeet Kumar Albin Suresh Avinash Deepak Goyal Jeril K George K Dinesh Mathew Kumpalamthanam Naseem Iqbal Nitish Kumar Ramnath Jayachandran Sathyam Doraswamy Sumesh B Yogesh Mishra Technical Contributors Shajahan Fariz Nikhil Sojan License \u00b6 eXpOS by Dr. Murali Krishnan K, Department of Computer Science and Engineering, National Institute of Technology, Calicut is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License . Based on a work at https://github.com/eXpOSNitc Acknowledgement \u00b6 We thank GitHub for providing the free for use platform on which this tutoring system has been hosted. We also thank an uncountable collecton of individuals who have supported the work in one form or the other.","title":"About"},{"location":"about/#expos-philosophy","text":"Any pedagogical operating system project offered as part of an undergraduate junior level operating system course needs to satisfy two requirements: The student must be given as much depth and detail as possible about the central operating system concepts. The quantity of work involved must not exceed what a student is able to do in a four month semester. The problem before the teacher is to decide on how much compromise on (1) must be done in favour of (2). eXpOS is our stance in this matter. There are three central principles that have been kept in mind in designing the eXpOS educational tool: Separation of concerns Things shall be made as simple as possible, but no simpler \"Build to learn\" rather than \"learn to build\" These thoughts have translated into the following decisions: Keep the upward and downward interfaces of the OS kernel idealistically simple \u2013 This means: The architecture platform on which the OS is implemented is kept simple to understand and program, yet capable of supporting virtual memory, interrupt driven disk/IO, time sharing, exception handling, demand paging etc. The application programming interface ( API ) (and the application binary interface \u00ad(ABI) ) provided by the OS are kept simple and minimal. The OS specification has been kept as simple as possible from the viewpoint of the OS programmer. The OS features are minimal, some of them being: co-operative multi-tasking a simple single-directory file system where processes can create, write, read and delete data files provision for processes to share files and memory primitives for interprocess communication (binary semaphores) and process synchronization (signal-wait) support for multiple users demand-paged memory management The OS code has to be completely written by the student with no built-in code given, except for a bootstrap ROM code and code implementing an application level library interface . The programming support has been kept minimal to avoid high level programming tools hiding too many low level issues from the OS programmer. Essentially, the student has to do \u201clow level programming\u201d on a \u201chigh level hardware\". The system is designed to help the student appreciate the functioning of a \u201csufficiently complex\u201d operating system and not to help him/her gain experience with real operating systems programming. The architecture, the OS, the API, ABI etc. are all different from any of the existing real systems or standards in use, but designed to make the task of programming the OS as simple as possible. Since the operating system kernel is a software that forms a layer between the hardware and the application program, the first major hurdle that a student faces while writing an OS is in understanding the complexities of the underlying hardware. The eXpOS package simplifies this by providing a hypothetical simple-to-program hardware abstraction \u2013 the XSM Machine . What makes XSM simple is that its memory words can store an arbitrary string or a number. This means that data formatting \u2013 one of the major technicalities while working with machines - is simplified. Further simplifications include the assumption that each disk block fits into exactly one memory page etc. The OS code can be written by programming the machine using a simple to learn SPL language (which is just an enriched XSM assembler). The second interface of the OS is its upward interface \u2013 the interface to application programs. This interface, called the application binary interface ( \u00adABI ), defines the low level system call interface between the application and the OS, the virtual address space model for an application, the format of executable files etc. The ABI too is kept minimal. It is easy to load executables into the memory. Only small programs are permitted. Parameter passing between applications and the system calls is also extremely simple. The eXpOS \u00adABI is too primitive to support application programs in the C programming language. Hence we provide a separate language (called ExpL ) using which applications can be created and compiled. The ExpL compiler given to the student supports the eXpOS high level application program interface ( API ). We note here that, implementing an ExpL compiler for the eXpOS ABI on the XSM machine would be an instructive exercise for an undergraduate compiler design laboratory. (See ExpL compiler project .) We are of the view that insisting the student to work with real systems diverts his/her attention to the details of various \u201cformats, standards and interfaces\" which often comes in the way of appreciating the underlying principles of OS design. eXpOS separates concerns by providing minimal interfaces that are just sufficient to achieve the required functionality. The development methodology suggested is to start from scratch with a simple bootstrap loader. Routines for handling the timer, disk and I/O devices shall be added next. A simple program loader that can load and execute applications from the disk can be written at this point. Single process operation will be possible at this stage. Following this, modules to support multi-tasking, Interprocess communication and process synchronization can be added. A file system can now be built on top of this structure. Multi-user support may be added next and finally full scale virtual memory management with swapping and demand paging shall be implemented. (A final stage adding support for multiprocessor operation is also intended.) The roadmap guides the student systematically through these stages, asking him/her to follow the links and learn the concepts relevant to the OS modules developed in each stage. There are two aspects associated with the design and implementation of each major component of an OS. \u2013 1) A Policy and 2) An implementation Mechanism. For example, the OS may specify a policy that each process is allowed it's own logical address space starting from 0 to a particular limit. Paging is a hardware mechanism that allows the OS to implement the policy. As another example, child processes inheriting open file instances from its parent process is a policy. The mechanism used by eXpOS to implement the policy is to keep a shared file seek position in an open file table. The pedagogical strategy followed here is to keep policies excessively simple so that the student can easily implement the policy, once the implementation mechanism is understood. For instance, in this project, size of the address space of a process is fixed by the OS, the file system does not have a directory structure and so on. To quickly prepare the students for the implementation, we provide detailed tutorials on various implementation mechanisms (like hardware paging) necessary to implement the policies. Our belief is that once the student completes the implementation of a simple policy using a particular mechanism, she will be in a position to visualize the implementation of more sophisticated policies that uses similar mechanisms without actually going through another implementation project. It is our belief that the experiment will provide the student with a feel for how the OS modules for process management, memory management, file management, device management, inter-process communication, process sychronization, demand paging and user management can be glued together to form a functional operating system. An appreciation for the Operating System's hardware interface, application interface and run time library linkage is also intended. We had tried our best to ensure that the spirit of the subject matter is not lost. However there have been compromises. The multi-user support, the file system and device handling are very primitive. Address space of a process is small and cannot expand at run time. Going further in these directions would make it difficult for the project to be completed in a semester. Some of these extensions are not \u201cin principle\u201d hard, once the basic OS is built. However topics such as pre-emptive multitasking, fault tolerance, system security etc. are beyond the scope of this project. The project presumes that the student has undergone a basic sophomore course in computer organization and data structures and has either completed or is currently undergoing a theory course in operating systems. The project does not require the student to be familar with the principles of compilers. It is not expected that the student has a high level of proficiency in programming or computer hardware. The required background on paging hardware, interrupts, run\u00adtime stack of application programs etc. are provided as reading material at appropriate places in the project roadmap. The parameter passing convention of ExpL as well as the system call interface are pretty simple so that students will have no serious difficulty in extracting parameters inside system calls and sending back return values to the application, despite not having undergone a compiler design course. It must be emphasized that the project by no means a replacement to a theory course in operating systems, but is only designed to suppliment it. eXpOS evolved from an earlier version (called XOS ) which was successfully used for undergraduate instruction at the department of Computer Science and Engineering, NIT Calicut. eXpOS extends XOS with multi\u00aduser support, co\u00adoperative multi\u00adtasking, interrupt based disk transfer and interprocess communication facility. Both these platforms were developed by teams of undergraduate CSE students of NIT Calicut through a series of undergraduate major projects.","title":"eXpOS Philosophy"},{"location":"about/#authors","text":"The content in the website and the documentation has been authored in the Department of Computer Science and Engineering, National Institute of Technology, Calicut under the guidance of Dr. Murali Krishnan K. The project's activity started in the year 2010 and is currently under progress. Below is a list of co-authors and contributors to the project. The work evolved from an earlier version of the project called the XOS project under the guidance of Dr. Murali Krishnan K. 2018-2019 Arun Joseph Rohith Vishnumolakala 2017-2018 Kandhala Naveena Navaneeth Kishore Sumedha Birajdar 2016-2017 Akhil S Karthika Aravind N Ruthvik Thallam Sai Sree Datta 2015-2016 Anjana Babu Christin V Jose Kurian Jacob Leny W V Aleena Thomas Reshma Sreekumar Reshma Thomas Nunnaguppala Surya Harsha Vishnupriya Matha 2014-2015 Kruthika Suresh Ved Sikha V Manoj Sonia V Mathew Aswathy T Revi Subhisha Gautham R Warrier Glen Martin Govind R 2012-2013 Shamil C M Sreeraj S Vivek Anand T Kallampally 2010-2012 Ajeet Kumar Albin Suresh Avinash Deepak Goyal Jeril K George K Dinesh Mathew Kumpalamthanam Naseem Iqbal Nitish Kumar Ramnath Jayachandran Sathyam Doraswamy Sumesh B Yogesh Mishra Technical Contributors Shajahan Fariz Nikhil Sojan","title":"Authors"},{"location":"about/#license","text":"eXpOS by Dr. Murali Krishnan K, Department of Computer Science and Engineering, National Institute of Technology, Calicut is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License . Based on a work at https://github.com/eXpOSNitc","title":"License"},{"location":"about/#acknowledgement","text":"We thank GitHub for providing the free for use platform on which this tutoring system has been hosted. We also thank an uncountable collecton of individuals who have supported the work in one form or the other.","title":"Acknowledgement"},{"location":"changelog/","text":"22nd July 2021 Website: Added link to modern documentation build using mkDocs in main website Docker based environment setup added 05 April 2021 Website: Add student feedback for 2020 batch. Add bootstrap script that automatically pulls the latest version of code from the git repo. Fixed a few typos. Added link to Google Groups. Created a repo to host user contributed content and added the link to the home page's sidebar. Code: Expl: Fixed linker error introduced by a breaking change in GCC10. Expl: Fixed strings containing colon getting parsed as labels. xfs-interface: Allow specifying path to disk.xfs using --disk flag. 23rd April 2020 Setup instructions for Debian, Red Hat based distros and arch linux added 21st April 2020 The definitions for User and Login have been added to the terminologies in the overview section of OS specifications. 22nd October 2019 The merge_sort.expl program to be used in assignment 5, stage 27 has been modified to work properly. Each process is made to wait for all the processes wth PID greater than itself inorer to prevent each process from closing leading to a reuse of PIDs. 31st August 2019 The high level library interface contained a typo. The 3rd argument for read instruction was changed from Memory Address (Buffer) to variable name(to which data is to be read) 24th August 2019 The roadmap contained typos in stage 7 and stage 14. In stage 7, logical pages for heap were changed from 3 and 4 to 2 and 3. In stage 14 a typo of OS startup code was changed to boot module. 4th August 2019 The project was failing to make on some operating systems. This was due to a dependency issue on some systems and has been fixed in the new release. The mem command in the XSM debug mode had an issue when called for a range of pages. It would just keep overwriting the contents of the mem file after writing a page and the mem file would contain the contents of only the last page in the range specified in the command call. Changes were made to the following directories:- xsm: The mem command was fixed and tested. 2nd August 2019 The roadmap contained a typo in the assignment question b of Stage 6. The memory locations 29714 in the question and 5160 in the answer has been corrected to 29706 and 51640 respectively. The rm command of the xfs-interface encountered segmentation faults upon execution. Changes were made to the following directories:- xfs-interface: The rm command was fixed and tested. 22th April 2019 NEXSM (a dual-core extension of XSM) is introduced. Stage 28 (Multi-Core Extension) describing how the OS can be ported to a two-core extension of the XSM machine has been added. The documentation for NEXSM architecture specification and eXpOS Design for NEXSM machine have been added. The changes in the sub-directories are:- expl: Library is modified to include INT 19. nespl: Three new instructions, start , reset and tsl , have been added. nexfs-interface: Commands for loading Bootstrap code for secondary core, software interrupt 19 and module 8-11 are added. nexsm: XSM machine is modified to simulate a two-core machine. 20th January 2019 Stage 27 (Pager Module) has been modified. A swapper daemon is introduced as a new process similar to the idle program, with PID=15, and the Pager Module is called from the context of this process. To add fairness for the swapped out processes, if the TICK field of any swapped out process exceeds a threshold, that process is swapped in after swapping out another process in memory. The changes in the sub-directories are:- xsm: A few additional commands, including commands for displaying all the data structures, is added to the XSM debugger. 5th November 2018 The changes in the sub-directories are:- expl: Modified the library ( library.lib ) to include INT 18 (Test0, Test1, Test2, Test3). 26th October 2018 The Execption Handler has been modified to allocate 2 heap pages when a page fault for a heap page occurs. In Stage 27 (Pager Module), Get Free Page function in Memory Manager and Exit Process function in Process Manager has been modified to call Swap Out and Swap In function, respectively. 23th October 2018 A new asignment problem has been added to Stage 27 (Pager Module). 20th October 2018 A new step has been added to the algorithm for Login and Logout system calls regarding the current userID in the system status table. The algorithm for Fork system call has been modified to allocate heap pages for parent process (if not yet assigned already), so that parent and child processes will still have a shared heap after Fork. 14th October 2018 The code for the Stage 22 assignment problem ( Merge Sort ) has been modified to avoid the stack overflow problem. A new assignment problem has been added to Stage 25 (File Write). The changes in the sub-directories are:- expl: Fixed a bug which caused an exception when function with more than one argument was called after an exposcall with more than one argument. xfs-interface: Fixed a bug which stored the file size of data files 1 more than the actual value. xsm: Fixed a bug in which the EIP value stored was 2 less than the actual value. 4th October 2018 The Fork system call had a problem - if a process forks, the parent first gets a PCB entry and then calls Get Free Page function to allocate pages for Stack/User Area pages for the child. If the Get Free Page causes the parent process to change the state to WAIT_MEM, the PCB entry allocated for the child may also be given for another process. The problem has been fixed by modifying the Get Pcb Entry function in Process Manager . Two new assignments has been added to Stage 22 (Semaphores). The changes in the sub-directories are:- spl: The constant ALLOCATED has been added to the SPL pre-defined constants . 20th September 2018 The algorithm for Release Page function in Memory Manager module has been modified to change the state of process from WAIT_MEM to READY when a free page is available. Makefile for myexpos directory is updated for make clean . The changes in the sub-directories are:- expl: a) Fixed a bug which caused return value of function to be overwritten when timer is called. The earlier version lowered the SP value before extracting return value from the call stack. If any interrupt occured in the meanwhile, the value in the stack was overwritten. b) Modified DIV instruction such that it doesn't call INT 10 when divisor is 0. spl: Earlier SPL version used the register R20 when large expressions were compiled. However, the machine had only registers up to R19. Hence, \"Illegal register usage\" was reported by the simulator. The SPL compiler is modifed to use only registers upto R19. xsm: Validity check is conducted for page/block number in load/store instructions. 17th September 2018 The exception/interrupt handling documentation has been modified. The simulator will no longer push IP on top of stack when an exception occurs, thus the code for exception handler must be modified as per the new documentation. The changes in the sub-directories are:- expl: Added line numbers during compilation errors. Fixed read(p.x) bug. After compilation of .expl, the target code is stored as both assemblycode.xsm and .xsm. xfs-interface: Fixed long string bug which caused \"Illegal instruction\" when large strings were used. xsm: Machine won't push IP on top of the stack when an exception occurs, anymore. XSM debugger will now show privilege mode and IP along with next instruction. Added usertable and watchpoint in XSM debugger. Fixed the --timer 1 bug which caused the timer to be called infinitely when timer is initialised as 1.","title":"Changelog"},{"location":"documentation/","text":"ARCHITECTURE \u00b6 eXpOS is basically built upon the XSM architecture. Architecture includes the specifications for the machine organisation, paging and interrupt handling and also provides the machine level instruction set. Specification \u00b6 Virtual Machine Model \u00b6 XSM Tutorial \u00b6 OPERATING SYSTEM \u00b6 eXpOS is a tiny multiprogramming operating system. It has a very simple specification that allows a junior undergraduate computer science student to implement it in a few months. Specification \u00b6 Design \u00b6 Implementation \u00b6 Support Tools \u00b6 To implement the eXpOS certain tools are provided along with the package. This includes SPL and ExpL compilers, XSM simulator and a UNIX-XFS Interface called XFS interface. Setting Up \u00b6 XFS Interface \u00b6 Constants \u00b6 SPL \u00b6 ExpL \u00b6 XSM Simulator \u00b6 APPLICATION INTERFACE \u00b6 The inteface between the application programs and the OS requires the specification of system call intefaces, format of executables, the virtual instruction set, the virtual memory layout and configuration. Application Binary Interface (ABI) \u00b6 Low Level System Call Interface \u00b6 High Level Library Interface (API) \u00b6 Low Level Library Interface \u00b6 ROADMAP \u00b6 The roadmap guides you step by step towards the complete implementation of the operating system. Concepts needed for completing each step will be introduced at the appropriate point. Proceed to Roadmap","title":"Documentation"},{"location":"documentation/#architecture","text":"eXpOS is basically built upon the XSM architecture. Architecture includes the specifications for the machine organisation, paging and interrupt handling and also provides the machine level instruction set.","title":"ARCHITECTURE"},{"location":"documentation/#specification","text":"","title":"Specification"},{"location":"documentation/#virtual-machine-model","text":"","title":"Virtual Machine Model"},{"location":"documentation/#xsm-tutorial","text":"","title":"XSM Tutorial"},{"location":"documentation/#operating-system","text":"eXpOS is a tiny multiprogramming operating system. It has a very simple specification that allows a junior undergraduate computer science student to implement it in a few months.","title":"OPERATING SYSTEM"},{"location":"documentation/#specification_1","text":"","title":"Specification"},{"location":"documentation/#design","text":"","title":"Design"},{"location":"documentation/#implementation","text":"","title":"Implementation"},{"location":"documentation/#support-tools","text":"To implement the eXpOS certain tools are provided along with the package. This includes SPL and ExpL compilers, XSM simulator and a UNIX-XFS Interface called XFS interface.","title":"Support Tools"},{"location":"documentation/#setting-up","text":"","title":"Setting Up"},{"location":"documentation/#xfs-interface","text":"","title":"XFS Interface"},{"location":"documentation/#constants","text":"","title":"Constants"},{"location":"documentation/#spl","text":"","title":"SPL"},{"location":"documentation/#expl","text":"","title":"ExpL"},{"location":"documentation/#xsm-simulator","text":"","title":"XSM Simulator"},{"location":"documentation/#application-interface","text":"The inteface between the application programs and the OS requires the specification of system call intefaces, format of executables, the virtual instruction set, the virtual memory layout and configuration.","title":"APPLICATION INTERFACE"},{"location":"documentation/#application-binary-interface-abi","text":"","title":"Application Binary Interface (ABI)"},{"location":"documentation/#low-level-system-call-interface","text":"","title":"Low Level System Call Interface"},{"location":"documentation/#high-level-library-interface-api","text":"","title":"High Level Library Interface (API)"},{"location":"documentation/#low-level-library-interface","text":"","title":"Low Level Library Interface"},{"location":"documentation/#roadmap","text":"The roadmap guides you step by step towards the complete implementation of the operating system. Concepts needed for completing each step will be introduced at the appropriate point. Proceed to Roadmap","title":"ROADMAP"},{"location":"faq/","text":"1. What is eXpOS? What is its purpose? eXpOS stands for eXperimental Operating System. The eXpOS specification describes a very simple multi-user multi-tasking operating system. eXpOS is not intended to be used as a practical operating system. It is designed with the following intentions: To have a multi-tasking OS specification that can be comprehended by a junior undergraduate student in computer science who is undergoing a first course in Operating System such that he/she will be able to implement the OS in two or three months. This educational package comes with enough guidance and support tools as well as documentation to allow the student to achieve this goal without the supervision of a specialist teacher. The student will write the complete code for the OS from scratch. He/She will not be building the OS on top of a given code base. The only programming support provided will be a compiler for a programming language (called SPL) in which the OS kernel will be written. 2. Who will benefit by implementing eXpOS? If you are a non-expert in computer science \u2013 like an undergraduate student or some non-specialist systems enthusiast \u2013 and you have a basic understanding of programming, and computer organization, implementing eXpOS will help you to get a feel of some of the core ideas involved in implementing a multi-tasking operating system on a single processor. You will learn how to: Initally load the operating system from secondary storage to memory \u2013 Bootstrapping . Manage several processess in memory simultaneously \u2013 Process Management . Handle allocation and de-allocation of memory to processes \u2013 Memory Management (includes virtual memory management). Manage organization of data and program files in secondary storage \u2013 File Management . Implement a mechanism to allow multiple processes to share files/memory \u2013 Resource Sharing . Realize primitives that help application programs to avoid inconsistency when resources are shared by several processes executing concurrently \u2013 Process Sychronization . Handling multiple users with different privileges over resources shared among them \u2013 Multi-user Capability. The experiment is akin to guiding a third year aerospace engineering student to build a small unmanned flight in two months. (The flight will not be usable outside the laboratory!) 3. What are the OS concepts that eXpOS will help me to comprehend better than \u2013 say just learning from a text book? Please see FAQ 2. 4. What are the prerequisites for doing the eXpOS project? The project presumes that the student has undergone a basic sophomore course in computer organization and data structures and has either completed or is currently undergoing a theory course in operating systems. The project does not require the student to be familar with the principles of compilers. It is not expected that the student has a high level of proficiency in programming or computer hardware. The required background on paging hardware, interrupts, run\u00adtime stack of application programs etc. are provided as reading material at appropriate places in the project roadmap. 5. Who must not be spending time on eXpOS? People who want to learn about operating systems, but who belong to the following category are not advised to proceed with eXpOS: You are a confident programmer comfortable with reading and understanding professionally written code \u2013 like the source code of linux. In this case, more sophisticated packages like Minix allow you to do real hard stuff. However, this is not for novices. You are not an expert; you want to try out the things listed in FAQ 2, but you do not want to do dirty work at a low level. (Although you can avoid assembly language programming in the eXpOS project, you still will have to get into quite a bit of \u201clow level\u201d architectural details). We suggest you to look for alternatives like NACHOS . 6. Can eXpOS be actually be used in a real application? Please see FAQ 2. 7. What are the important OS concepts I miss out when working with eXpOS? What you learn is very little compared to what is needed to become an OS expert. So, listing out everything is impossible. But here are some important misses: The XSM machine allows you to store a character string in a memory word. No real machine architecture permits you to do such stuff. This is made possible just because XSM is a software simulated. However, XSM makes your data manipulation job much simpler without getting bogged down by details of data formatting. It is in principle possible to implement eXpOS on \u201cmore real\u201d machines like MIPS . However, this would involve considerably more time and effort. The project involves very little work involving input-ouput, device interfacing, security or networking. Moreover the file system and multi-user support are very primitive. The methods studied won't scale up when there is pre-emptive multitasking . 8. What are the system requirements for working on the eXpOS package? We expect you to have a Linux/Unix Machine with Lex/Flex and Yacc/Bison software packages installed. (For Flex/Bison installation on your Linux system, see link ). Once you have these, you can download the eXpOS package by following instructions at Setting Up . 9. What are the contents of the eXpOS package? The eXpOS package available here comes with the following: A simulator for the Experimental String Machine (XSM) on which you implement eXpOS. The machine consists of a CPU, Memory and a disk and a small Input-Ouput subsystem. A compiler (into the XSM machine) for the System Programmer's Language (SPL) using which you will be writing all your code for implementing eXpOS. SPL is a simple programming language which essentially is an extended assembler for the XSM machine, specifically designed for the eXpOS package. A compiler (into the XSM machine) for the Experimental String Language (ExpL) . This language is used for writing application programs that can run on top of eXpOS. You will be using this language for writing some of the user level programs of the OS including the shell. Test programs that are used to test your OS will also be written in ExpL. An interface tool called XFS-interface . that allows you to transfer data files and executable programs from your Unix/Linux system into the hard disk of the XSM machine. You also download the source code of all the above tools and their formal specification documents, the sample test programs testing your OS, some help etc. 10. I have downloaded the eXpOS package. How can I get started with the work? The best way is to follow the eXpOS roadmap. It is a journey taken one simple step at a time. You will be provided with links to learn the concepts on a \u201clearn when needed\u201d way. Just go ahead following this link . 11. What differenciates eXpOS from other educational packages like NACHOS? It is difficult to answer this question for all similar packages available elsewhere, but here is a comparison with NACHOS. NACHOS learning system asks you to implement OS software that allows application programs in the noff executable format, running on a the software simulation of a MIPS machine, to invoke system calls. However, the OS code you write really doesn't run on the MIPS machine! Your code is actually C code running on your Linux/Unix machine. When an application program invokes an OS system call, the MIPS simulator transfers control to a corresponding \u201cstub\u201d function in the simulating environment. You must write C code in the stub to do \u201cwhatever is expected from the OS\u201d to satisfy the calling application program invoking the system call. Since the MIPS machine is simulated, your code has access to its memory, registers etc. Thus you can implement the system call, put return values in appropriate memory locations on the simulated MIPS machine and transfer control back to the calling program. In eXpOS, the OS and the application programs run in the same machine as is the case in real systems. The compromise made in achieving this goal was to make the machine \u201cunreal\u201d and the OS simple enough so that additional complexity is manageable for a short term project. 12. What is the difference between eXpOS and XOS? XOS is an earlier version of this project. XOS did not support blocking system calls. This means that a process will never do a context switch while it is running in the kernel mode. However eXpOS, system calls may block in the kernel mode and other processes could be scheduled. The version of XSM provided with eXpOS has the necessary hardware support for doing this. The addition of this single feature makes the eXpOS substantially more complex than XOS. This is because a blocked process might have made partial updates to some OS data structures before blocking and a newly scheduled process, while executing in the kernel mode, must be careful not to modify these data structures and leave the OS in an inconsistent state. Apart from the above feature, eXpOS adds support for semaphores, shared memory, file locking etc. There is also limited multi-user support. However, the additional complexity introduced by these features is minor. 13. How do I write OS code and load the OS in the eXpOS system? You have to write your OS code from your Linux/Unix system in a custom programming language called SPL that comes with the eXpOS package, compile the code and install the target code into the hard disk of the XSM machine. The xfs-interface tool allows you to do this pre-loading. Your OS code must include set up code that will be executed when the system is started. This code must load the rest of the OS into memory during bootstrap. 14. How do I write application programs that run on eXpOS? Application programs must be compiled in the Linux/Unix environment outside and pre-loaded into the XSM machine's disk. The ExpL language allows applications to be written and compiled into the eXpOS executable format called the XEXE format. 15. What is meant by user mode and kernel mode? In a multitasking OS like Linux, there are two types of programs running. Firstly, there are application programs that users write. These are called \"user mode programs\". Secondly, there are \"kernel mode programs\" which constitute the OS code. These routines implement the system call interface for application programs and other OS functions like process, memory, file and device management etc. User mode programs can execute only a restricted instruction set and has access only to a limited memory (called the virtual address space). These programs must invoke OS system calls to do tasks which involve capacity beyond their limited instruction set. Kernel mode programs on the other hand have full access to the machine instruction set. Any machine supporting eXpOS needs to recognize and support two modes of program execution. The OS must be designed such that the machine switches to kernel mode when a user mode program invokes a system call and goes back to user mode when the system call returns. This requires architecture support. XSM machine is equipped with the necessary hardware support. 16. Why do you need two programming languages in the eXpOS package \u2013 the SPL and ExpL? We need separate programming systems for writing user mode programs and kernel mode programs because these languages serve different purposes. The high level language - ExpL provided with the package can be used for writing application programs that run on top of the operating system. However, ExpL does not support low level programming necessary to write the OS. The SPL language (which is essentially an enriched XSM assembly language) must be used to write the OS modules. 17. What is eXpOS Library? The ExpOS library is a piece of code that provides a generic interface for application programs to access OS services like system calls and dynamic memory management routines. ExpL permits applications to invoke OS routines only through the library interface. The compiler simply translates the library call to a low level library call. However, ExpL compiler will not attach the library to the application at compile time. The OS loader must attach the library to the application at run time. 18. What is XFS interface? XFS interface is a tool that permits you to transfer programs and data files between your host system and the XSM machine's simulated hard disk. The tool is capable of handling various eXpOS file types (like OS modules, application programs, data files, library etc.) and store them in the XSM disk, updating the disk data structures appropriately. 19. My friend has implemented eXpOS after downloading the package and following the roadmap. I want to write a program and test his implementation. How to do it? You must write your code in ExpL language in your Unix/Linux machine, compile it using the ExpL compiler that comes with the eXpOS package and load the target executable file into the XSM machine's disk using the xfs-interface tool. Now start the machine (assuming that your friend has already written his OS routines in SPL, compiled it using the SPL compiler and loaded it into the disk) so that her OS boots up and runs the shell program. From the shell, you will be able to type in the name of your executable program and execute it, just like in bash. 20. I am a teacher and wants to use eXpOS for laboratory instruction. How should I proceed? You are welcome use eXpOS. You may also fork the project on GitHub and customize the project to your own needs subject to the Creative Commons license conditions. Pro Tip: Suppose your institution has the name ABC University, to host your project on GitHub as exposabc.github.io, create a GitHub account by the name eXpOSABC, fork this project, rename your repository to exposabc.github.io, and host your website using GitHub Pages","title":"FAQ"},{"location":"os-implementation/","text":"Introduction \u00b6 This document discusses the mapping of various eXpOS data structures to the XSM machine's disk and memory. The implementation of eXpOS on XSM discussed in the project modularises the code of system calls into smaller module functions. An interface description of the module functions is given here. The document also outlines the useage of kernel stack of user processes. Disk Organization \u00b6 Block Number Contents Number of Blocks 0 - 1 Bootstrap 2 2 Disk Free List 1 3 - 4 Inode + User Table 2 5 Root File 1 6 Reserved for future use 1 7 - 8 Init/Login Code 2 9 - 10 Shell Code 2 11 - 12 Idle Code 2 13 - 14 Library 2 15 - 16 Exception Handler 2 17 - 18 Timer Interrupt Routine 2 19 - 20 Disk Controller Interrupt Routine 2 21 - 22 Console Interrupt Routine 2 23 - 24 Interrupt 4 Routine: Create, Delete 2 25 - 26 Interrupt 5 Routine: Seek, Open, Close 2 27 - 28 Interrupt 6 Routine: Read 2 29 - 30 Interrupt 7 Routine: Write 2 31 - 32 Interrupt 8 Routine: Fork 2 33 - 34 Interrupt 9 Routine: Exec 2 35 - 36 Interrupt 10 Routine: Exit 2 37 - 38 Interrupt 11 Routine: Getpid, Getppid, Wait, Signal 2 39 - 40 Interrupt 12 Routine: Logout 2 41 - 42 Interrupt 13 Routine: Semget, Semrelease 2 43 - 44 Interrupt 14 Routine: SemLock, SemUnLock 2 45 - 46 Interrupt 15 Routine: Shutdown 2 47 - 48 Interrupt 16 Routine: Newusr, Remusr, Setpwd, Getuname, Getuid 2 49 - 50 Interrupt 17 Routine: Login 2 51 - 52 Interrupt 18 Routine: Test0, Test1, Test2, Test3 2 53 - 54 Module 0: Resource Manager 2 55 - 56 Module 1: Process Manager 2 57 - 58 Module 2: Memory Manager 2 59 - 60 Module 3: File Manager 2 61 - 62 Module 4: Device Manager 2 63 - 64 Module 5: Context Switch Module (Scheduler Module) 2 65 - 66 Module 6: Pager Module 2 67 - 68 Module 7: Boot Module 2 69 - 255 User Blocks 187 256 - 511 Swap Area 256 512 - 513 Secondary Bootstrap 2 514 - 515 Interrupt 19 Routine: Test4, Test5, Test6, Test8 2 516 - 517 Module 8: Access Control Module 2 518 - 519 Module 9: TestA (Unused) 2 520 - 521 Module 10: TestB (Unused) 2 522 - 523 Module 11: TestC (Unused) 2 524 - 527 Unallocated 4 The Inode table occupies the first 960 words (60 entries each of size 16 words) in the disk blocks 3 and 4. User table occupies the next 32 words (16 entries each of size 2 words) and the last 32 words are reserved for future use. The Root File occupies the first 480 words of the 5th block and the last 32 words are unallocated. These disk blocks are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine. Memory Organization \u00b6 The Memory layout of the XSM machine is as follows : Page Number Contents Word Address Number of Words 0 ROM Code 0 - 511 512 1 Page for loading the BOOT block ( OS Startup Code ) 512 - 1023 512 2 - 3 Exception Handler 1024 - 2047 1024 4 - 5 Timer Interrupt Routine 2048 - 3071 1024 6 - 7 Disk Controller Interrupt Routine 3072 - 4095 1024 8 - 9 Console Interrupt Routine 4096 - 5119 1024 10 - 11 Interrupt 4 Routine: Create , Delete 5120 - 6143 1024 12 - 13 Interrupt 5 Routine: Seek , Open , Close 6144 - 7167 1024 14 - 15 Interrupt 6 Routine: Read 7168 - 8191 1024 16 - 17 Interrupt 7 Routine: Write 8192 - 9215 1024 18 - 19 Interrupt 8 Routine: Fork 9216 - 10239 1024 20 - 21 Interrupt 9 Routine: Exec 10240 - 11263 1024 22 - 23 Interrupt 10 Routine: Exit 11264 - 12287 1024 24 - 25 Interrupt 11 Routine: Getpid , Getppid , Wait , Signal 12288 - 13311 1024 26 - 27 Interrupt 12 Routine: Logout 13312 - 14335 1024 28 - 29 Interrupt 13 Routine: Semget , Semrelease 14336 - 15359 1024 30 - 31 Interrupt 14 Routine: SemLock , SemUnLock 15360 - 16383 1024 32 - 33 Interrupt 15 Routine: Shutdown 16384 - 17407 1024 34 - 35 Interrupt 16 Routine: Newusr , Remusr , Setpwd , Getuname , Getuid 17408 - 18431 1024 36 - 37 Interrupt 17 Routine: Login 18432 - 19455 1024 38 - 39 Interrupt 18 Routine: Test0, Test1, Test2, Test3 19456 - 20479 1024 40 - 41 Module 0: Resource Manager 20480 - 21503 1024 42 - 43 Module 1: Process Manager 21504 - 22527 1024 44 - 45 Module 2: Memory Manager 22528 - 23551 1024 46 - 47 Module 3: File Manager 23552 - 24575 1024 48 - 49 Module 4: Device Manager 24576 - 25599 1024 50 - 51 Module 5: Context Switch Module (Scheduler Module) 25600 - 26623 1024 52 - 53 Module 6: Pager Module 26624 - 27647 1024 54 - 55 Module 7: Boot Module 27648 - 28671 1024 56 Process Table 28672 - 28927 256 Open File Table 28928 - 29055 128 Semaphore Table 29056 - 29183 128 57 Memory Free List 29184 - 29311 128 File Status Table 29312 - 29551 240 Disk Status Table 29552 - 29559 8 System Status Table 29560 - 29567 8 Terminal Status Table 29568 - 29575 8 Access Lock Table * 29576 - 29583 8 Unallocated 29584 - 29695 112 58 Page tables 29696 - 30015 320 Buffer Table 30016 - 30031 16 Disk Map Table 30032 - 30191 160 Unallocated 30192 - 30207 16 59 - 60 Memory copy of Inode Table 30208 - 31167 960 Memory copy of User Table 31168 - 31199 32 Unallocated 31200 - 31231 32 61 Memory copy of Disk Free List 31232 - 31743 512 62 Memory copy of Root File 31744 - 32223 480 Unallocated 32224 - 32255 32 63 - 64 Expos Library 32256 - 33279 1024 65 - 66 INIT/Login Program 33280 - 34303 1024 67 - 68 Shell Program 34304 - 35327 1024 69 - 70 Idle Program 35328 - 36351 1024 71 - 74 Buffer (disk cache) 36352 - 38399 2048 75 Reserved for future use (Exam!) 38400 - 38911 512 76 - 127 User Programs 38912 - 65535 26624 128 - 129 Page for loading the Secondary BOOT Block * 65536 - 66559 1024 130 - 131 Interrupt 19 Routine: Test4, Test5, Test6, Test7 * 66560 - 67583 1024 132 - 133 Module 8: Access Control Module * 67584 - 68607 1024 134 - 135 Module 9: TestA (Unused) * 68608 - 69631 1024 136 - 137 Module 10: TestB (Unused) * 69632 - 70655 1024 138 - 139 Module 11: TestC (Unused) * 70656 - 71679 1024 140 - 143 Reserved for future use * 71680 - 73727 2048 * These memory pages are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine. Note Constants can be found here Kernel Module Interface \u00b6 Kernel Stack Management \u00b6 Kernel Stack Management during System Calls \u00b6 Kernel Stack Management during Hardware interrupts or exceptions \u00b6 Kernel Stack Management during Module calls \u00b6 Kernel Stack Management during Context Switch \u00b6 eXpOS Procees management implementation \u00b6 eXpOS File-System and implementation \u00b6 eXpOS Multi-User implementation \u00b6","title":"Implementation"},{"location":"os-implementation/#introduction","text":"This document discusses the mapping of various eXpOS data structures to the XSM machine's disk and memory. The implementation of eXpOS on XSM discussed in the project modularises the code of system calls into smaller module functions. An interface description of the module functions is given here. The document also outlines the useage of kernel stack of user processes.","title":"Introduction"},{"location":"os-implementation/#disk-organization","text":"Block Number Contents Number of Blocks 0 - 1 Bootstrap 2 2 Disk Free List 1 3 - 4 Inode + User Table 2 5 Root File 1 6 Reserved for future use 1 7 - 8 Init/Login Code 2 9 - 10 Shell Code 2 11 - 12 Idle Code 2 13 - 14 Library 2 15 - 16 Exception Handler 2 17 - 18 Timer Interrupt Routine 2 19 - 20 Disk Controller Interrupt Routine 2 21 - 22 Console Interrupt Routine 2 23 - 24 Interrupt 4 Routine: Create, Delete 2 25 - 26 Interrupt 5 Routine: Seek, Open, Close 2 27 - 28 Interrupt 6 Routine: Read 2 29 - 30 Interrupt 7 Routine: Write 2 31 - 32 Interrupt 8 Routine: Fork 2 33 - 34 Interrupt 9 Routine: Exec 2 35 - 36 Interrupt 10 Routine: Exit 2 37 - 38 Interrupt 11 Routine: Getpid, Getppid, Wait, Signal 2 39 - 40 Interrupt 12 Routine: Logout 2 41 - 42 Interrupt 13 Routine: Semget, Semrelease 2 43 - 44 Interrupt 14 Routine: SemLock, SemUnLock 2 45 - 46 Interrupt 15 Routine: Shutdown 2 47 - 48 Interrupt 16 Routine: Newusr, Remusr, Setpwd, Getuname, Getuid 2 49 - 50 Interrupt 17 Routine: Login 2 51 - 52 Interrupt 18 Routine: Test0, Test1, Test2, Test3 2 53 - 54 Module 0: Resource Manager 2 55 - 56 Module 1: Process Manager 2 57 - 58 Module 2: Memory Manager 2 59 - 60 Module 3: File Manager 2 61 - 62 Module 4: Device Manager 2 63 - 64 Module 5: Context Switch Module (Scheduler Module) 2 65 - 66 Module 6: Pager Module 2 67 - 68 Module 7: Boot Module 2 69 - 255 User Blocks 187 256 - 511 Swap Area 256 512 - 513 Secondary Bootstrap 2 514 - 515 Interrupt 19 Routine: Test4, Test5, Test6, Test8 2 516 - 517 Module 8: Access Control Module 2 518 - 519 Module 9: TestA (Unused) 2 520 - 521 Module 10: TestB (Unused) 2 522 - 523 Module 11: TestC (Unused) 2 524 - 527 Unallocated 4 The Inode table occupies the first 960 words (60 entries each of size 16 words) in the disk blocks 3 and 4. User table occupies the next 32 words (16 entries each of size 2 words) and the last 32 words are reserved for future use. The Root File occupies the first 480 words of the 5th block and the last 32 words are unallocated. These disk blocks are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine.","title":"Disk Organization"},{"location":"os-implementation/#memory-organization","text":"The Memory layout of the XSM machine is as follows : Page Number Contents Word Address Number of Words 0 ROM Code 0 - 511 512 1 Page for loading the BOOT block ( OS Startup Code ) 512 - 1023 512 2 - 3 Exception Handler 1024 - 2047 1024 4 - 5 Timer Interrupt Routine 2048 - 3071 1024 6 - 7 Disk Controller Interrupt Routine 3072 - 4095 1024 8 - 9 Console Interrupt Routine 4096 - 5119 1024 10 - 11 Interrupt 4 Routine: Create , Delete 5120 - 6143 1024 12 - 13 Interrupt 5 Routine: Seek , Open , Close 6144 - 7167 1024 14 - 15 Interrupt 6 Routine: Read 7168 - 8191 1024 16 - 17 Interrupt 7 Routine: Write 8192 - 9215 1024 18 - 19 Interrupt 8 Routine: Fork 9216 - 10239 1024 20 - 21 Interrupt 9 Routine: Exec 10240 - 11263 1024 22 - 23 Interrupt 10 Routine: Exit 11264 - 12287 1024 24 - 25 Interrupt 11 Routine: Getpid , Getppid , Wait , Signal 12288 - 13311 1024 26 - 27 Interrupt 12 Routine: Logout 13312 - 14335 1024 28 - 29 Interrupt 13 Routine: Semget , Semrelease 14336 - 15359 1024 30 - 31 Interrupt 14 Routine: SemLock , SemUnLock 15360 - 16383 1024 32 - 33 Interrupt 15 Routine: Shutdown 16384 - 17407 1024 34 - 35 Interrupt 16 Routine: Newusr , Remusr , Setpwd , Getuname , Getuid 17408 - 18431 1024 36 - 37 Interrupt 17 Routine: Login 18432 - 19455 1024 38 - 39 Interrupt 18 Routine: Test0, Test1, Test2, Test3 19456 - 20479 1024 40 - 41 Module 0: Resource Manager 20480 - 21503 1024 42 - 43 Module 1: Process Manager 21504 - 22527 1024 44 - 45 Module 2: Memory Manager 22528 - 23551 1024 46 - 47 Module 3: File Manager 23552 - 24575 1024 48 - 49 Module 4: Device Manager 24576 - 25599 1024 50 - 51 Module 5: Context Switch Module (Scheduler Module) 25600 - 26623 1024 52 - 53 Module 6: Pager Module 26624 - 27647 1024 54 - 55 Module 7: Boot Module 27648 - 28671 1024 56 Process Table 28672 - 28927 256 Open File Table 28928 - 29055 128 Semaphore Table 29056 - 29183 128 57 Memory Free List 29184 - 29311 128 File Status Table 29312 - 29551 240 Disk Status Table 29552 - 29559 8 System Status Table 29560 - 29567 8 Terminal Status Table 29568 - 29575 8 Access Lock Table * 29576 - 29583 8 Unallocated 29584 - 29695 112 58 Page tables 29696 - 30015 320 Buffer Table 30016 - 30031 16 Disk Map Table 30032 - 30191 160 Unallocated 30192 - 30207 16 59 - 60 Memory copy of Inode Table 30208 - 31167 960 Memory copy of User Table 31168 - 31199 32 Unallocated 31200 - 31231 32 61 Memory copy of Disk Free List 31232 - 31743 512 62 Memory copy of Root File 31744 - 32223 480 Unallocated 32224 - 32255 32 63 - 64 Expos Library 32256 - 33279 1024 65 - 66 INIT/Login Program 33280 - 34303 1024 67 - 68 Shell Program 34304 - 35327 1024 69 - 70 Idle Program 35328 - 36351 1024 71 - 74 Buffer (disk cache) 36352 - 38399 2048 75 Reserved for future use (Exam!) 38400 - 38911 512 76 - 127 User Programs 38912 - 65535 26624 128 - 129 Page for loading the Secondary BOOT Block * 65536 - 66559 1024 130 - 131 Interrupt 19 Routine: Test4, Test5, Test6, Test7 * 66560 - 67583 1024 132 - 133 Module 8: Access Control Module * 67584 - 68607 1024 134 - 135 Module 9: TestA (Unused) * 68608 - 69631 1024 136 - 137 Module 10: TestB (Unused) * 69632 - 70655 1024 138 - 139 Module 11: TestC (Unused) * 70656 - 71679 1024 140 - 143 Reserved for future use * 71680 - 73727 2048 * These memory pages are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine. Note Constants can be found here","title":"Memory Organization"},{"location":"os-implementation/#kernel-module-interface","text":"","title":"Kernel Module Interface"},{"location":"os-implementation/#kernel-stack-management","text":"","title":"Kernel Stack Management"},{"location":"os-implementation/#kernel-stack-management-during-system-calls","text":"","title":"Kernel Stack Management during System Calls"},{"location":"os-implementation/#kernel-stack-management-during-hardware-interrupts-or-exceptions","text":"","title":"Kernel Stack Management during Hardware interrupts or exceptions"},{"location":"os-implementation/#kernel-stack-management-during-module-calls","text":"","title":"Kernel Stack Management during Module calls"},{"location":"os-implementation/#kernel-stack-management-during-context-switch","text":"","title":"Kernel Stack Management during Context Switch"},{"location":"os-implementation/#expos-procees-management-implementation","text":"","title":"eXpOS Procees management implementation"},{"location":"os-implementation/#expos-file-system-and-implementation","text":"","title":"eXpOS File-System and implementation"},{"location":"os-implementation/#expos-multi-user-implementation","text":"","title":"eXpOS Multi-User implementation"},{"location":"reports/","text":"XOS/eXpOS was contributed by 11 teams in National Institute of Technology, Calicut from 2010 onwards under the guidance of Dr. K Murali Krishnan . You can download their project reports from the following links. 2015-2016 Batch Group 1 Anjana Babu, Christin V Jose, Kurian Jacob, Leny W V Download Group 2 Aleena Thomas, Reshma Sreekumar, Reshma Thomas Download Group 3 Nunnaguppala Surya Harsha, Vishnupriya Matha Download 2014-2015 Batch Group 1 Kruthika Suresh Ved, Sikha V Manoj, Sonia V Mathew Download Group 2 Aswathy T Revi, Subhisha Download Group 3 Gautham R Warrier, Glen Martin, Govind R Download 2012-2013 Batch Group 1 Shamil C M, Sreeraj S, Vivek Anand T Kallampally Download 2010-2012 Batch Group 1 Ajeet Kumar, Albin Suresh, Avinash, Deepak Goyal, Jeril K George, K Dinesh, Mathew Kumpalamthanam Naseem Iqbal, Nitish Kumar, Ramnath Jayachandran, Sathyam Doraswamy, Shamil C M, Sreeraj S, Sumesh B, Vivek Anand T Kallampally, Yogesh Mishra Download","title":"Project Reports"},{"location":"virtual-machine-spec/","text":"Scope of the Document \u00b6 The Virtual Machine model defines the view of the machine to user mode programs. User mode programs are executed in the unprivileged mode. Consequently, the privileged mode instructions cannot be used by them. Their memory view and registers available are also limited. This restricted model is discussed below. Virtual Machine Organisation \u00b6 The XSM virtual machine model defines the machine model provided by XSM to a program running in user mode . This model comprises of a restricted subset of the machine registers, a restricted instruction set and a restricted memory address space (called the virtual/logical address space ). Registers \u00b6 The XSM architecture maintains several registers and ports, each capable of storing a number/string, out of which, only some are accessible in unprivileged mode. The registers available in the unprivileged mode are Registers Purpose R0-R19 General purpose program registers BP, SP, IP Base, Stack and Instruction Pointers Virtual (Memory) Address Space \u00b6 The virtual (or logical) memory addresses that can be generated by a user mode program is determined by the value of the PTLR register. The virtual address space of a user mode program is a contiguous address space starting from 0 to 512*PTLR-1. The virtual addreses generated by a user mode program are translated into physical addresses by the address translation scheme of XSM. The user mode program is oblivious to the address translation. Operating systems using the XSM architecture typically specifies the maximum value of PTLR permitted for its user processes and divide the allocated address space for an application into library, code, data, stack, heap etc. Interrupts \u00b6 Software Interrupts (traps) are the mechanisms by which user mode programs can transfer control to the code that runs in the kernel mode. Software interrupt service routines typically contain the OS code for various system calls. Upon return from a software interrupt, execution resumes from the next instruction in the user mode program. A total of 15 software interrupts are available to a user mode program (Interrupt 4 - Interrupt 18). Instruction Set \u00b6 Every instruction in XSM is two words long. The unprivileged instructions are categorized into : Data Transfer Instructions Family of instructions concerned with moving data between a register and a register/memory location/ integer or string constant. The MOV instruction supports data transfer through various addressing modes. Arithmetic Instructions Arithmetic Instructions perform arithmetic operations on registers containing integers. If the register contains a non-integer value, an exception is raised. The arithmetic instructions are ADD, SUB, MUL, DIV, MOD, INR and DCR. Logical Instructions Logical instructions are used for comparing values in registers. Strings can also be compared according to the lexicographic ordering of ASCII. Logical instructions are GT, LT, EQ, NE, GE and LE. Branching Instructions Branching is achieved by changing the value of the IP to the word address of the target instruction specified by target_address. The branching instructions are JZ, JNZ, JMP Stack Instructions The stack instructions are PUSH and POP. Subroutine Instructions The subroutine instructions provide a mechanism for procedure invocations. The subroutine instructions are CALL and RET. Debug Instructions The machine when run in debug mode invokes the debugger when this instruction is executed. This instruction can be used for debugging system code. The instruction for entering the debug mode is BRKP. Software Interrupt Generates an interrupt to the kernel with n (4 to 18) as a parameter. The instruction for triggering interrupt is INT n, where n is the interrupt routine number. The details of the semantics of these instructions is given in here","title":"Virtual Machine Model"},{"location":"virtual-machine-spec/#scope-of-the-document","text":"The Virtual Machine model defines the view of the machine to user mode programs. User mode programs are executed in the unprivileged mode. Consequently, the privileged mode instructions cannot be used by them. Their memory view and registers available are also limited. This restricted model is discussed below.","title":"Scope of the Document"},{"location":"virtual-machine-spec/#virtual-machine-organisation","text":"The XSM virtual machine model defines the machine model provided by XSM to a program running in user mode . This model comprises of a restricted subset of the machine registers, a restricted instruction set and a restricted memory address space (called the virtual/logical address space ).","title":"Virtual Machine Organisation"},{"location":"virtual-machine-spec/#registers","text":"The XSM architecture maintains several registers and ports, each capable of storing a number/string, out of which, only some are accessible in unprivileged mode. The registers available in the unprivileged mode are Registers Purpose R0-R19 General purpose program registers BP, SP, IP Base, Stack and Instruction Pointers","title":"Registers"},{"location":"virtual-machine-spec/#virtual-memory-address-space","text":"The virtual (or logical) memory addresses that can be generated by a user mode program is determined by the value of the PTLR register. The virtual address space of a user mode program is a contiguous address space starting from 0 to 512*PTLR-1. The virtual addreses generated by a user mode program are translated into physical addresses by the address translation scheme of XSM. The user mode program is oblivious to the address translation. Operating systems using the XSM architecture typically specifies the maximum value of PTLR permitted for its user processes and divide the allocated address space for an application into library, code, data, stack, heap etc.","title":"Virtual (Memory) Address Space"},{"location":"virtual-machine-spec/#interrupts","text":"Software Interrupts (traps) are the mechanisms by which user mode programs can transfer control to the code that runs in the kernel mode. Software interrupt service routines typically contain the OS code for various system calls. Upon return from a software interrupt, execution resumes from the next instruction in the user mode program. A total of 15 software interrupts are available to a user mode program (Interrupt 4 - Interrupt 18).","title":"Interrupts"},{"location":"virtual-machine-spec/#instruction-set","text":"Every instruction in XSM is two words long. The unprivileged instructions are categorized into : Data Transfer Instructions Family of instructions concerned with moving data between a register and a register/memory location/ integer or string constant. The MOV instruction supports data transfer through various addressing modes. Arithmetic Instructions Arithmetic Instructions perform arithmetic operations on registers containing integers. If the register contains a non-integer value, an exception is raised. The arithmetic instructions are ADD, SUB, MUL, DIV, MOD, INR and DCR. Logical Instructions Logical instructions are used for comparing values in registers. Strings can also be compared according to the lexicographic ordering of ASCII. Logical instructions are GT, LT, EQ, NE, GE and LE. Branching Instructions Branching is achieved by changing the value of the IP to the word address of the target instruction specified by target_address. The branching instructions are JZ, JNZ, JMP Stack Instructions The stack instructions are PUSH and POP. Subroutine Instructions The subroutine instructions provide a mechanism for procedure invocations. The subroutine instructions are CALL and RET. Debug Instructions The machine when run in debug mode invokes the debugger when this instruction is executed. This instruction can be used for debugging system code. The instruction for entering the debug mode is BRKP. Software Interrupt Generates an interrupt to the kernel with n (4 to 18) as a parameter. The instruction for triggering interrupt is INT n, where n is the interrupt routine number. The details of the semantics of these instructions is given in here","title":"Instruction Set"},{"location":"arch-spec/","text":"Introduction \u00b6 The Experimental String Machine (XSM) is a hypothetical interrupt driven uniprocessor machine. The basic unit of data which the machine handles is the string . A string is a sequence of characters terminated by the special character '\\0'. The length of a string is at most XSM_WSIZE characters including the '\\0' character. (The value of XSM_WSIZE is implementation dependent and is left unspecified in this documentation). The machine treats integers, characters or sequence of characters as strings. The basic data storage components of the machine are registers , memory and the disk . The memory and the disk are organised as sequences of words. The word is the fundamental memory/disk storage element and each memory/disk word can store a string. In the following, we often (mis)use notation and use the term \u201cword\u201d to refer to the \u201cstring stored in the memory/disk word\u201d. Important Note Througout the architecture documentation, we have used the terms kernel mode for previleged mode and user mode for unprevileged mode of machine execution. However, \"kernel\" and \"user\" are OS level abstractions and not connected with the hardware. Hence the above usage is incorrect technically. However since the kernel of an OS normally runs in the previliged mode and user programs execute in the unpreviliged mode, the (incorrect) terminology has been used. This document contains the following sections: Machine Organization \u00b6 Interrupts and Exception Handling \u00b6 Instruction Set \u00b6 Paging Hardware and Address Translation \u00b6 NEXSM (Two Core) Architecture Specification \u00b6","title":"XSM Architecture Specifcation"},{"location":"arch-spec/#introduction","text":"The Experimental String Machine (XSM) is a hypothetical interrupt driven uniprocessor machine. The basic unit of data which the machine handles is the string . A string is a sequence of characters terminated by the special character '\\0'. The length of a string is at most XSM_WSIZE characters including the '\\0' character. (The value of XSM_WSIZE is implementation dependent and is left unspecified in this documentation). The machine treats integers, characters or sequence of characters as strings. The basic data storage components of the machine are registers , memory and the disk . The memory and the disk are organised as sequences of words. The word is the fundamental memory/disk storage element and each memory/disk word can store a string. In the following, we often (mis)use notation and use the term \u201cword\u201d to refer to the \u201cstring stored in the memory/disk word\u201d. Important Note Througout the architecture documentation, we have used the terms kernel mode for previleged mode and user mode for unprevileged mode of machine execution. However, \"kernel\" and \"user\" are OS level abstractions and not connected with the hardware. Hence the above usage is incorrect technically. However since the kernel of an OS normally runs in the previliged mode and user programs execute in the unpreviliged mode, the (incorrect) terminology has been used. This document contains the following sections:","title":"Introduction"},{"location":"arch-spec/#machine-organization","text":"","title":"Machine Organization"},{"location":"arch-spec/#interrupts-and-exception-handling","text":"","title":"Interrupts and Exception Handling"},{"location":"arch-spec/#instruction-set","text":"","title":"Instruction Set"},{"location":"arch-spec/#paging-hardware-and-address-translation","text":"","title":"Paging Hardware and Address Translation"},{"location":"arch-spec/#nexsm-two-core-architecture-specification","text":"","title":"NEXSM (Two Core) Architecture Specification"},{"location":"arch-spec/instruction-set/","text":"Important Note Througout the architecture documentation, we have used the terms kernel mode for previleged mode and user mode for unprevileged mode of machine execution. However, \"kernel\" and \"user\" are OS level abstractions and not connected with the hardware. Hence the above usage is incorrect technically. However since the kernel of an OS normally runs in the previliged mode and user programs execute in the unpreviliged mode, the (incorrect) terminology has been used. Every instruction in XSM is 2 words long. The instructions provided by the XSM architecture can be classified into unprivileged (user) and privileged (kernel) instructions. The semantics of each instruction is different, depending on the mode in which the machine is running. Unprivileged Instructions \u00b6 XSM provides a set of unprivileged instructions, which are the only instructions available when the machine is executing in the user mode. The machine can execute unprivileged instructions in kernel mode also, however, the instruction semantics will be different as explained in Paging hardware . The unprivileged instructions are Data Transfer Instructions , Arithmetic Instructions , Logical Instructions , Stack Instructions , Sub-routine instructions , Debug instructions and Software interrupts . Registers available in user mode are R0-R19, SP, BP and IP. [Data Transfer Instructions] \u00b6 1. Register Addressing : \u00b6 Syntax : MOV Ri, Rj Semantics : Copies the contents of the register Rj to Ri. 2. Immediate Addressing : \u00b6 Syntax : MOV Ri, INTEGER/STRING Semantics : Copies the INTEGER/STRING to the register Ri. 3. Register Indirect Addressing : \u00b6 Syntax : MOV Ri, [Rj] Semantics : Copy contents of memory location pointed by Rj to register Ri. Syntax : MOV [Ri], Rj Semantics : Copy contents of Rj to the location whose address is in Ri. 4. Direct Addressing : \u00b6 Syntax : MOV [LOC], Rj Semantics : Copy contents of Rj to the memory address LOC. Syntax : MOV Rj, [LOC] Semantics : Copy contents of the memory location LOC to the register Rj. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise. [Arithmetic Instructions] \u00b6 Arithmetic Instructions perform arithmetic operations on registers containing integers. If the register contains a non-integer value, an exception (illegal instruction) is raised. 1. ADD, SUB, MUL, DIV and MOD \u00b6 Syntax : OP Ri, Rj Semantics : The result of Ri op Rj is stored in Ri. Syntax : OP Ri, INTEGER Semantics : The result of Ri op INTEGER is stored in Ri. 2. INR, DCR \u00b6 Syntax : OP Ri Semantics : Increments/Decrements the value of register Ri by 1. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise. [Logical Instructions] \u00b6 Logical instructions are used for comparing values in registers. Strings can also be compared according to the lexicographic ordering of ASCII. If one of the operands is a string, the other operand will also be considered as a string. The logical instructions are LT, GT, EQ, NE, GE and LE. LT, GT, EQ, NE, GE, LE Syntax : OP Ri, Rj Semantics : Stores 1 in Ri if the value stored in Ri is less than/greater than/equal to/not equal to/greater than or equal to/less than or equal to that in Rj. Ri is set to 0 otherwise. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise. [Branching Instructions] \u00b6 Branching is achieved by changing the value of the IP to the word address of the target instruction specified by 'target_address'. 1. JZ \u00b6 Syntax : JZ Ri, target_address Semantics : Jumps to target_address if the contents of Ri is zero. 2. JNZ \u00b6 Syntax : JNZ Ri, target_address Semantics : Jumps to target_address if the contents of Ri is not zero. 3. JMP \u00b6 Syntax : JMP target_address Semantics : Unconditional jump to target_address. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise. [Stack Instructions] \u00b6 1. PUSH \u00b6 Syntax : PUSH Ri Semantics : Increment SP by 1 and copy contents of Ri to the location pointed to by SP. 2. POP \u00b6 Syntax : POP Ri Semantics : Copy contents of the location pointed to by SP into Ri and decrement SP by 1. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise. [Subroutine Instructions] \u00b6 The CALL instruction copies the address of the next instruction to be fetched(this value must be IP + 2 since each instruction is two memory words) on to location SP + 1. It also increments SP by one and transfers control to the instruction specified by the target_address. The RET instruction restores the IP value stored at location pointed by SP, decrements SP by one and continues execution fetching the next instruction pointed to by IP. 1. CALL \u00b6 Syntax : CALL target_address / Ri Semantics : Increments SP by 1, transfers IP + 2 to location pointed to by SP and jumps to instruction specified by target_address/Ri. For the CALL instruction, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise. 2. RET \u00b6 Syntax : RET Semantics : Sets IP to the value pointed to by SP and decrements SP. [Debug Instruction] \u00b6 Syntax : BRKP Semantics : The machine when run in debug mode invokes the debugger when this intruction is executed. This instruction can be used for debugging system code. [Software Interrupts] \u00b6 Syntax : INT n Semantics : Generates an interrupt to the kernel with n (4 to 18) as a parameter. This involves a change of mode from user to kernel mode . It also disables the interrupts. The Stack Pointer is first incremented, the physical address of SP is calculated and the (virtual) address of the next instruction after the current value of IP is stored into that location (See Address Translation ). After this, the execution mode is switched to Kernel mode. Note that, INT can be invoked only from the User Mode. The IP value must contain a virtual address and hence, the value pushed into stack is a virtual address and not a physical address. Finally, the IP value is set according to the value of n as specified here . [NOP Instruction] \u00b6 Syntax : NOP Semantics : Instruction that does nothing. Privileged Instructions \u00b6 Privileged instructions can be executed only in the kernel mode (both priviliged instructions and unpriviliged instructions can be executed in the kernel mode). It should be noted that all the addresses in the kernel mode should be physical addresses , whereas the user mode uses logical addresses , with address translation done using the Paging hardware . Privileged Instructions are: [LOADI] \u00b6 Syntax : LOADI pagenum blocknum Semantics : This instruction loads the disk block specified by blocknum to the memory page specified by pagenum. Blocknum and pagenum should be numbers or registers containing numbers. The machine will wait for the disk transfer to complete and continue execution of the next instruction only after the block transfer is completed by the disk controller. [LOAD] \u00b6 Syntax : LOAD pagenum blocknum Semantics : This instruction initiates the transfer of the disk block specified by blocknum to the memory page specified by pagenum, using the disk controller. Blocknum and pagenum should be numbers or registers containing numbers. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. The disk controller raises the disk interrupt when the transfer is completed. [STORE] \u00b6 Syntax : STORE pagenum blocknum Semantics : This instruction initiates the transfer of the memory page specified by pagenum to the disk block specified by blocknum, using the disk controller. Blocknum and pagenum should be numbers or registers containing numbers. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. The disk controller raises the disk interrupt when the transfer is completed. [ENCRYPT] \u00b6 Syntax : ENCRYPT Ri Semantics : This instruction replaces the value in the register Ri with its encrypted value. The details of the encryption scheme used is left unspecified. [BACKUP] \u00b6 Syntax : BACKUP Semantics : This instruction is used to backup all the machine registers (except SP, IP, exception flag registers and ports) into the memory locations starting from the address pointed to by SP in the order : BP, R0 - R19. The value of SP gets incremented accordingly. [RESTORE] \u00b6 Syntax : RESTORE Semantics : This instruction is used to restore the backed up machine registers from memory. The registers are restored from contiguous memory locations starting from the address pointed to by SP in the order : R19-R0, BP. The value of SP gets decremented accordingly. [PORT] \u00b6 Syntax : PORT Ri, Pj Semantics : Transfers the contents of port Pj to register Ri. Syntax : PORT Pi, Rj Semantics : Transfers the contents of register Rj to port Pi. [IN] \u00b6 Syntax : IN Semantics : IN initiates reading a word from the standard console. The machine proceeds to the execution of the next instruction without waiting for the console read to complete. When a word is read from the console, the console controller stores the word to the port P0 (which is reserved for the console input) and raises the console interrupt . [INI] \u00b6 Syntax : INI Semantics : INI initiates reading a word from the standard console. This instruction gets enabled in the debug mode only. The machine waits for the console read to complete before proceeding to the execution of the next instruction. When a word is read from the console, the console controller stores the word to the port P0. Console interrupt is not raised here. [OUT] \u00b6 Syntax : OUT Semantics : Transfers the contents of P1 to the standard output immediately. [IRET] \u00b6 Syntax : IRET Semantics : This instruction is used to return control to a user mode program from an interrupt service routine/exception handler. This involves a change of mode from kernel to user mode. With the execution of the IRET instruction, interrupts are enabled. The address of the next instruction to be executed by the user program is popped from the stack and set to the IP Register, following which the Stack Pointer is decremented. Since the IP value must contain a virtual address while executing in User Mode, the value obtained from stack is treated as a virtual address and not a physical address (See Address Translation ). Note that the machine switches to user mode just before the execution of the IRET instruction. Thus the address pointed to by SP is treated as a virtual address and the machine translates this address into physical address using the page translation scheme , before popping the IP value. [HALT] \u00b6 Syntax : HALT Semantics : This instruction causes the machine to halt immediately. NEXSM Additional Privileged Instructions \u00b6 Important Note These instructions are available only on NEXSM (a two-core extension of XSM) machine. Additional Privileged Instructions in NEXSM are: TSL \u00b6 Syntax : TSL Rj, [loc] Semantics : The contents of the memory location [loc] is copied to register Rj. The value of [loc] is set to 1. This instruction is atomic . That is, when one of the cores is executing the TSL instruction, the memory bus is locked to avoid the other processor from simultaneously accessing [loc]. START \u00b6 Syntax : START Semantics : If this instruction is executed by the primary while the machine is in reset mode, then secondary core starts parallel execution at the starting address of memory page 128 (physical address 65536). The START instruction is ignored if executed when the machine is in active mode. RESET \u00b6 Syntax : RESET Semantics : The instruction, when executed in active mode sets the machine to reset mode. The instruction is ignored if executed in reset mode.","title":"Instruction Set"},{"location":"arch-spec/instruction-set/#unprivileged-instructions","text":"XSM provides a set of unprivileged instructions, which are the only instructions available when the machine is executing in the user mode. The machine can execute unprivileged instructions in kernel mode also, however, the instruction semantics will be different as explained in Paging hardware . The unprivileged instructions are Data Transfer Instructions , Arithmetic Instructions , Logical Instructions , Stack Instructions , Sub-routine instructions , Debug instructions and Software interrupts . Registers available in user mode are R0-R19, SP, BP and IP.","title":"Unprivileged Instructions"},{"location":"arch-spec/instruction-set/#data-transfer-instructions","text":"","title":"[Data Transfer Instructions]"},{"location":"arch-spec/instruction-set/#1-register-addressing","text":"Syntax : MOV Ri, Rj Semantics : Copies the contents of the register Rj to Ri.","title":"1. Register Addressing :"},{"location":"arch-spec/instruction-set/#2-immediate-addressing","text":"Syntax : MOV Ri, INTEGER/STRING Semantics : Copies the INTEGER/STRING to the register Ri.","title":"2. Immediate Addressing :"},{"location":"arch-spec/instruction-set/#3-register-indirect-addressing","text":"Syntax : MOV Ri, [Rj] Semantics : Copy contents of memory location pointed by Rj to register Ri. Syntax : MOV [Ri], Rj Semantics : Copy contents of Rj to the location whose address is in Ri.","title":"3. Register Indirect Addressing:"},{"location":"arch-spec/instruction-set/#4-direct-addressing","text":"Syntax : MOV [LOC], Rj Semantics : Copy contents of Rj to the memory address LOC. Syntax : MOV Rj, [LOC] Semantics : Copy contents of the memory location LOC to the register Rj. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise.","title":"4. Direct Addressing :"},{"location":"arch-spec/instruction-set/#arithmetic-instructions","text":"Arithmetic Instructions perform arithmetic operations on registers containing integers. If the register contains a non-integer value, an exception (illegal instruction) is raised.","title":"[Arithmetic Instructions]"},{"location":"arch-spec/instruction-set/#1-add-sub-mul-div-and-mod","text":"Syntax : OP Ri, Rj Semantics : The result of Ri op Rj is stored in Ri. Syntax : OP Ri, INTEGER Semantics : The result of Ri op INTEGER is stored in Ri.","title":"1. ADD, SUB, MUL, DIV and MOD"},{"location":"arch-spec/instruction-set/#2-inr-dcr","text":"Syntax : OP Ri Semantics : Increments/Decrements the value of register Ri by 1. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise.","title":"2. INR, DCR"},{"location":"arch-spec/instruction-set/#logical-instructions","text":"Logical instructions are used for comparing values in registers. Strings can also be compared according to the lexicographic ordering of ASCII. If one of the operands is a string, the other operand will also be considered as a string. The logical instructions are LT, GT, EQ, NE, GE and LE. LT, GT, EQ, NE, GE, LE Syntax : OP Ri, Rj Semantics : Stores 1 in Ri if the value stored in Ri is less than/greater than/equal to/not equal to/greater than or equal to/less than or equal to that in Rj. Ri is set to 0 otherwise. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise.","title":"[Logical Instructions]"},{"location":"arch-spec/instruction-set/#branching-instructions","text":"Branching is achieved by changing the value of the IP to the word address of the target instruction specified by 'target_address'.","title":"[Branching Instructions]"},{"location":"arch-spec/instruction-set/#1-jz","text":"Syntax : JZ Ri, target_address Semantics : Jumps to target_address if the contents of Ri is zero.","title":"1. JZ"},{"location":"arch-spec/instruction-set/#2-jnz","text":"Syntax : JNZ Ri, target_address Semantics : Jumps to target_address if the contents of Ri is not zero.","title":"2. JNZ"},{"location":"arch-spec/instruction-set/#3-jmp","text":"Syntax : JMP target_address Semantics : Unconditional jump to target_address. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise.","title":"3. JMP"},{"location":"arch-spec/instruction-set/#stack-instructions","text":"","title":"[Stack Instructions]"},{"location":"arch-spec/instruction-set/#1-push","text":"Syntax : PUSH Ri Semantics : Increment SP by 1 and copy contents of Ri to the location pointed to by SP.","title":"1. PUSH"},{"location":"arch-spec/instruction-set/#2-pop","text":"Syntax : POP Ri Semantics : Copy contents of the location pointed to by SP into Ri and decrement SP by 1. For all the above instructions, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise.","title":"2. POP"},{"location":"arch-spec/instruction-set/#subroutine-instructions","text":"The CALL instruction copies the address of the next instruction to be fetched(this value must be IP + 2 since each instruction is two memory words) on to location SP + 1. It also increments SP by one and transfers control to the instruction specified by the target_address. The RET instruction restores the IP value stored at location pointed by SP, decrements SP by one and continues execution fetching the next instruction pointed to by IP.","title":"[Subroutine Instructions]"},{"location":"arch-spec/instruction-set/#1-call","text":"Syntax : CALL target_address / Ri Semantics : Increments SP by 1, transfers IP + 2 to location pointed to by SP and jumps to instruction specified by target_address/Ri. For the CALL instruction, Ri/Rj may be any register except IP . Note Only registers R0-R19, SP and BP shall be used in code that executes in unpreviliged mode. An exception (illegal instruction) will be generated otherwise.","title":"1. CALL"},{"location":"arch-spec/instruction-set/#2-ret","text":"Syntax : RET Semantics : Sets IP to the value pointed to by SP and decrements SP.","title":"2. RET"},{"location":"arch-spec/instruction-set/#debug-instruction","text":"Syntax : BRKP Semantics : The machine when run in debug mode invokes the debugger when this intruction is executed. This instruction can be used for debugging system code.","title":"[Debug Instruction]"},{"location":"arch-spec/instruction-set/#software-interrupts","text":"Syntax : INT n Semantics : Generates an interrupt to the kernel with n (4 to 18) as a parameter. This involves a change of mode from user to kernel mode . It also disables the interrupts. The Stack Pointer is first incremented, the physical address of SP is calculated and the (virtual) address of the next instruction after the current value of IP is stored into that location (See Address Translation ). After this, the execution mode is switched to Kernel mode. Note that, INT can be invoked only from the User Mode. The IP value must contain a virtual address and hence, the value pushed into stack is a virtual address and not a physical address. Finally, the IP value is set according to the value of n as specified here .","title":"[Software Interrupts]"},{"location":"arch-spec/instruction-set/#nop-instruction","text":"Syntax : NOP Semantics : Instruction that does nothing.","title":"[NOP Instruction]"},{"location":"arch-spec/instruction-set/#privileged-instructions","text":"Privileged instructions can be executed only in the kernel mode (both priviliged instructions and unpriviliged instructions can be executed in the kernel mode). It should be noted that all the addresses in the kernel mode should be physical addresses , whereas the user mode uses logical addresses , with address translation done using the Paging hardware . Privileged Instructions are:","title":"Privileged Instructions"},{"location":"arch-spec/instruction-set/#loadi","text":"Syntax : LOADI pagenum blocknum Semantics : This instruction loads the disk block specified by blocknum to the memory page specified by pagenum. Blocknum and pagenum should be numbers or registers containing numbers. The machine will wait for the disk transfer to complete and continue execution of the next instruction only after the block transfer is completed by the disk controller.","title":"[LOADI]"},{"location":"arch-spec/instruction-set/#load","text":"Syntax : LOAD pagenum blocknum Semantics : This instruction initiates the transfer of the disk block specified by blocknum to the memory page specified by pagenum, using the disk controller. Blocknum and pagenum should be numbers or registers containing numbers. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. The disk controller raises the disk interrupt when the transfer is completed.","title":"[LOAD]"},{"location":"arch-spec/instruction-set/#store","text":"Syntax : STORE pagenum blocknum Semantics : This instruction initiates the transfer of the memory page specified by pagenum to the disk block specified by blocknum, using the disk controller. Blocknum and pagenum should be numbers or registers containing numbers. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. The disk controller raises the disk interrupt when the transfer is completed.","title":"[STORE]"},{"location":"arch-spec/instruction-set/#encrypt","text":"Syntax : ENCRYPT Ri Semantics : This instruction replaces the value in the register Ri with its encrypted value. The details of the encryption scheme used is left unspecified.","title":"[ENCRYPT]"},{"location":"arch-spec/instruction-set/#backup","text":"Syntax : BACKUP Semantics : This instruction is used to backup all the machine registers (except SP, IP, exception flag registers and ports) into the memory locations starting from the address pointed to by SP in the order : BP, R0 - R19. The value of SP gets incremented accordingly.","title":"[BACKUP]"},{"location":"arch-spec/instruction-set/#restore","text":"Syntax : RESTORE Semantics : This instruction is used to restore the backed up machine registers from memory. The registers are restored from contiguous memory locations starting from the address pointed to by SP in the order : R19-R0, BP. The value of SP gets decremented accordingly.","title":"[RESTORE]"},{"location":"arch-spec/instruction-set/#port","text":"Syntax : PORT Ri, Pj Semantics : Transfers the contents of port Pj to register Ri. Syntax : PORT Pi, Rj Semantics : Transfers the contents of register Rj to port Pi.","title":"[PORT]"},{"location":"arch-spec/instruction-set/#in","text":"Syntax : IN Semantics : IN initiates reading a word from the standard console. The machine proceeds to the execution of the next instruction without waiting for the console read to complete. When a word is read from the console, the console controller stores the word to the port P0 (which is reserved for the console input) and raises the console interrupt .","title":"[IN]"},{"location":"arch-spec/instruction-set/#ini","text":"Syntax : INI Semantics : INI initiates reading a word from the standard console. This instruction gets enabled in the debug mode only. The machine waits for the console read to complete before proceeding to the execution of the next instruction. When a word is read from the console, the console controller stores the word to the port P0. Console interrupt is not raised here.","title":"[INI]"},{"location":"arch-spec/instruction-set/#out","text":"Syntax : OUT Semantics : Transfers the contents of P1 to the standard output immediately.","title":"[OUT]"},{"location":"arch-spec/instruction-set/#iret","text":"Syntax : IRET Semantics : This instruction is used to return control to a user mode program from an interrupt service routine/exception handler. This involves a change of mode from kernel to user mode. With the execution of the IRET instruction, interrupts are enabled. The address of the next instruction to be executed by the user program is popped from the stack and set to the IP Register, following which the Stack Pointer is decremented. Since the IP value must contain a virtual address while executing in User Mode, the value obtained from stack is treated as a virtual address and not a physical address (See Address Translation ). Note that the machine switches to user mode just before the execution of the IRET instruction. Thus the address pointed to by SP is treated as a virtual address and the machine translates this address into physical address using the page translation scheme , before popping the IP value.","title":"[IRET]"},{"location":"arch-spec/instruction-set/#halt","text":"Syntax : HALT Semantics : This instruction causes the machine to halt immediately.","title":"[HALT]"},{"location":"arch-spec/instruction-set/#nexsm-additional-privileged-instructions","text":"Important Note These instructions are available only on NEXSM (a two-core extension of XSM) machine. Additional Privileged Instructions in NEXSM are:","title":"NEXSM Additional Privileged Instructions"},{"location":"arch-spec/instruction-set/#tsl","text":"Syntax : TSL Rj, [loc] Semantics : The contents of the memory location [loc] is copied to register Rj. The value of [loc] is set to 1. This instruction is atomic . That is, when one of the cores is executing the TSL instruction, the memory bus is locked to avoid the other processor from simultaneously accessing [loc].","title":"TSL"},{"location":"arch-spec/instruction-set/#start","text":"Syntax : START Semantics : If this instruction is executed by the primary while the machine is in reset mode, then secondary core starts parallel execution at the starting address of memory page 128 (physical address 65536). The START instruction is ignored if executed when the machine is in active mode.","title":"START"},{"location":"arch-spec/instruction-set/#reset","text":"Syntax : RESET Semantics : The instruction, when executed in active mode sets the machine to reset mode. The instruction is ignored if executed in reset mode.","title":"RESET"},{"location":"arch-spec/interrupts-exception-handling/","text":"Important Note Througout the architecture documentation, we have used the terms kernel mode for previleged mode and user mode for unprevileged mode of machine execution. However, \"kernel\" and \"user\" are OS level abstractions and not connected with the hardware. Hence the above usage is incorrect technically. However since the kernel of an OS normally runs in the previliged mode and user programs execute in the unpreviliged mode, the (incorrect) terminology has been used. XSM supports a total of 19 interrupts. Each interrupt is identified by its number between 0 and 18. Among these, Interrupt 0 is the exception handler, Interrupt 1 is the timer interrupt, Interrupt 2 is the disk controller interrupt and Interrupt 3 is the console interrupt. Interrupts 1, 2 and 3 are hardware interrupts. The interrupts 4 to 18 are software interrupts. Software interrupts occur when they are invoked by a program in execution. A program can invoke a software interrupt using the INT machine instruction. However, hardware interrupts and the exception handler cannot be invoked from user mode programs. Associated with each interrupt/exception, there is an interrupt handler. When an interrupt occurs, the corresponding handler is executed. XSM specification reserves two contiguous memory pages for loading each interrupt handler according to the table given in Memory Organisation . When an interrupt/exception occurs, the machine transfers control to the beginning of the first page of the corresponding handler. It is the responsibility of the OS/Kernel programmer to store the interrupt handler routines in the disk and load them to the corresponding pages at the time of system startup. Note: Internally XSM machine has an interrupt vector table that maps each interrupt number to a corresponding address (of the interrupt handler). The vector table is stored starting from physical address 492 of the ROM memory. Locations 492,493,494 and 495 stores the addresses of exception handler, timer interrupt handler, disk interrupt handler and console interrupt handler. Location 496 contains the address of the first software interrupt handler - INT 4, location 497 contains address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address and IP is set to this value. Since the values are hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of these handlers. See here for more details about Boot ROM and interrupt vector table. Note XSM does not allow the INT instruction to be executed in kernel mode. Timer Interrupt \u00b6 The XSM architecture includes a timer that can cause periodic interrupts during execution in unprivileged mode. The timer ticks with each unprivileged instruction executed and once the number of ticks reaches a threshold specified during boot-time (see --timer option of the XSM simulator ), the tick counter is reset and a timer interrupt is raised. At that point, the machine executes the following actions: Increment the value of the SP register and push the value in the IP register into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the interrupt vector table entry for the timer interrupt handler. The vector table entry for timer interrupt is located at physical address 493 in page 0 (ROM) of XSM and the value 2048 is preset in this location. Hence, the IP register gets value 2048 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 2048, and the machine will continue execution in previliged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Thus the occurance of the timer interrupt results in machine execution to be transferred to the timer interrupt handler (INT 1) stored in page 4-5. Disk Controller Interrupt \u00b6 The Disk Controller allows for imitating asynchronous disk access by the OS. Whenever the machine executes the LOAD/STORE instruction, the Disk Controller initiates a counter that ticks with each unprivileged instruction executed after the LOAD/STORE instruction. Once the counter reaches a threshold value specified during boot-time (see --disk option of the XSM simulator ), the counter is reset and a disk interrupt (INT 2) is raised. At that point, the machine executes the following actions: Increment the value of the SP register and push the value in the IP register into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the interrupt vector table entry for the disk interrupt handler. The vector table entry for disk interrupt is located at physical address 494 in page 0 (ROM) of XSM and the value 3072 is preset in this location. Hence, the IP register gets value 3072 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 3072, and the machine will continue execution in previliged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Thus the occurance of the disk interrupt results in machine execution to be transferred to the disk interrupt handler (INT 2) stored in page 6-7. As noted above, the macros LOAD/STORE are used to send requests to the Disk Controller. The Disk Controller does not support parallel input requests. Thus it is the OS Programmer's duty to ensure that multiple disk requests are not raised. That is, the OS must take care of ensuring that after a LOAD/STORE instruction is executed, another LOAD/STORE instruction is executed only after the device controller has raised the device interrupt, marking the completion of the first request. Console Interrupt \u00b6 The XSM Architecture has a Console Device which acts as the IO interface for user interaction. When a program requires interacting with the user, the macros 'IN', 'INI' and 'OUT' are used to invoke the Console Device. Output (OUT instruction) is a synchronous process and works immediately. Whenever the machine executes the console input instruction (IN instruction), the Console Device initiates a counter that ticks with each unprivileged instruction executed after the IN instruction. Once the counter reaches a threshold value specified during boot-time (see --console option of the XSM simulator ), the counter and the machine simulator waits for the user to enter some data into the console. When the user eventually enters the input, the counter is reset and the console interrupt (INT 3) is raised. At that point, the machine executes the following actions: Increment the value of the SP register and push the value in the IP register into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the interrupt vector table entry for the console interrupt handler. The vector table entry for console interrupt is located at physical address 495 in page 0 (ROM) of XSM and the value 4096 is preset in this location. Hence, the IP register gets value 4096 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 4096, and the machine will continue execution in previleged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Thus the occurance of the console interrupt results in machine execution to be transferred to the console interrupt handler (INT 3) stored in page 8-9. As noted above, the macro instruction IN is used to send input requests to the Console device. The Console Device does not support parallel input requests. Thus it is the OS Programmer's duty to ensure that multiple IN requests are not raised. Control is transferred to the user program by the interrupt routine only after the user inputs a word from the Console. The INI instruction (which can be used only in debug mode) is a special instruction which allows synchronous console input where the machine doesn't raise an interrupt but waits for the user to enter the data before proceeding to the next instruction. Race Conditions \u00b6 After the execution of an instruction in unpriviliged mode, suppose the machine finds that multiple interrupts are pending - say the disk, console and timer interrupts are simultaniously due, then the machine executes the interrupts in the following order - first timer, second disk and third console. After executing the first handler, the machine returns to unpreviliged mode and immedietely executes steps (1) and (2) in the next interrupt and so on till all pending interrupts are processed. As noted above, if an exception occurs at the point of handling any of the above interrupts, the exception is handled first. Exceptions \u00b6 Exceptions are anomalous situations which changes the normal flow of execution. The machine raises an exception when it runs in user mode and encounters an anomalous situation during program execution like division by zero or generation of an invalid address. All exceptions raise Interrupt 0. The XSM Register set consists of four special registers for storing the details regarding exceptions. The exception registers are as shown below 1) Exception IP (EIP) : Stores the value of IP at the point where the exception occurred. 2) Exception Page Number (EPN) : This field is relevant when a Page Fault Exception occurs. The logical page number which caused a page fault exception is stored here. 3) Exception Cause (EC) : This field indicates a number which corresponds to the cause of the exception. Exceptions can be caused when the following events occur. Page Fault : The value stored in the EC register for this exception is 0. Illegal instruction : The value stored in the EC register for this exception is 1. Illegal memory access : The value stored in the EC register for this exception is 2. Arithmetic exception : The value stored in the EC register for this exception is 3. 4) Exception Memory Address (EMA) : Exception Memory Address register is relevant only in the case of illegal memory access . The illegal memory which was tried to be accessed is stored in the register. This field is relevant only when either the address referred to is outside the range 0 - 512*(PTLR-1) or a write is attempted to a page which is read-only. A detailed discussion on various conditions leading to the machine raising an exception are below:- Illegal instruction \u00b6 occurs when one of the following conditions occur:- Destination of a MOV operation is a constant. A register/port not allowed in user mode is accessed. A privileged mode instruction is executed. There is an instruction that does not belong to XSM instruction set or an instruction is given with more/less operands than allowed - syntax error. INT n instruction - n is not in the valid range (4-18). When one of the above events occur, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contents are not valid for this exception. EC is set to value 1 corresponding to illegal instruction. EMA contents are not valid for this exception. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without peforming address translation). Illegal Memory Access \u00b6 occurs when one of the following conditions occur:- A MOV instruction has an address not in the range 0 to PTLR*512-1. (Even indirect addressing as in MOV R0, [R1] can cause such addresses) RET/POP executed with SP not between 0 and PTLR*512-1. CALL/INT/PUSH/hardware interrupt executed with SP not between -1 and PTLR*512-2. JZ/JNZ/JMP Instruction is executed with IP value not in the range 0 to PTLR*512-1. Write is attempted to a page whose write permission bit in the page table entry has been set to 0. When one of the above events occur, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contents are not valid for this exception. EC is set to value 2 corresponding to illegal memory access. EMA is set to logical address that caused the illegal memory access. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without performing address translation). Arithmetic exception \u00b6 Occurs during DIV/MOD instruction with the second operator having value zero. When an arithmetic exception occurs, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contents are not valid for this exception. EC is set to value 3 corresponding to arithmetic exception. EMA contents are not valid for this exception. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without performing address translation). Page Fault \u00b6 Occurs when none of the conditions above hold, and the valid bit of the page referenced is set to 0. When one of the above events occur, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contains the logical page number of the page accessed, that caused the exception. EC is set to value 0 corresponding to page fault. EMA contents are not valid for this exception. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without performing address translation). Software Interrupts \u00b6 Software Interrupts are the primary mechanisms by which a user mode program transfers control to the corresponding interrupt handler that runs in the kernel mode. Software interrupt service routines typically contain the OS code for various system calls. Upon return from a software interrupt using the IRET instruction, execution resumes from the next instruction in the user mode program. A total of 15 software interrupts are available (Interrupt 4 - Interrupt 18). Note that user mode programs cannot invoke the hardware interrupt routines . When an INT n (n in the range 4-18) instruction occurs, the machine executes the following actions: Increment the value of the SP register and push the value in the IP + 2 (logical address of the next instruction to be executed upon return from the interrupt handler) into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the vector table entry for the corresponding interrupt. The vector table entry for INT n is located at physical address 492 + n in page 0 (ROM) of XSM and the values are preset as specified in the Boot ROM and Boot Block section of XSM Machine Organisation documentation. Hence, the IP register gets the value preset in the interrupt vector table and the machine switches to privileged mode. Consequently, the next instruction will be fetched from the preset value, and the machine will continue execution in previleged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section above on exception handling). Note INT instruction cannot be executed when the machine is executing in privileged mode. (see instruction set )","title":"Interrupts and Exception Handling"},{"location":"arch-spec/interrupts-exception-handling/#timer-interrupt","text":"The XSM architecture includes a timer that can cause periodic interrupts during execution in unprivileged mode. The timer ticks with each unprivileged instruction executed and once the number of ticks reaches a threshold specified during boot-time (see --timer option of the XSM simulator ), the tick counter is reset and a timer interrupt is raised. At that point, the machine executes the following actions: Increment the value of the SP register and push the value in the IP register into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the interrupt vector table entry for the timer interrupt handler. The vector table entry for timer interrupt is located at physical address 493 in page 0 (ROM) of XSM and the value 2048 is preset in this location. Hence, the IP register gets value 2048 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 2048, and the machine will continue execution in previliged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Thus the occurance of the timer interrupt results in machine execution to be transferred to the timer interrupt handler (INT 1) stored in page 4-5.","title":"Timer Interrupt"},{"location":"arch-spec/interrupts-exception-handling/#disk-controller-interrupt","text":"The Disk Controller allows for imitating asynchronous disk access by the OS. Whenever the machine executes the LOAD/STORE instruction, the Disk Controller initiates a counter that ticks with each unprivileged instruction executed after the LOAD/STORE instruction. Once the counter reaches a threshold value specified during boot-time (see --disk option of the XSM simulator ), the counter is reset and a disk interrupt (INT 2) is raised. At that point, the machine executes the following actions: Increment the value of the SP register and push the value in the IP register into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the interrupt vector table entry for the disk interrupt handler. The vector table entry for disk interrupt is located at physical address 494 in page 0 (ROM) of XSM and the value 3072 is preset in this location. Hence, the IP register gets value 3072 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 3072, and the machine will continue execution in previliged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Thus the occurance of the disk interrupt results in machine execution to be transferred to the disk interrupt handler (INT 2) stored in page 6-7. As noted above, the macros LOAD/STORE are used to send requests to the Disk Controller. The Disk Controller does not support parallel input requests. Thus it is the OS Programmer's duty to ensure that multiple disk requests are not raised. That is, the OS must take care of ensuring that after a LOAD/STORE instruction is executed, another LOAD/STORE instruction is executed only after the device controller has raised the device interrupt, marking the completion of the first request.","title":"Disk Controller Interrupt"},{"location":"arch-spec/interrupts-exception-handling/#console-interrupt","text":"The XSM Architecture has a Console Device which acts as the IO interface for user interaction. When a program requires interacting with the user, the macros 'IN', 'INI' and 'OUT' are used to invoke the Console Device. Output (OUT instruction) is a synchronous process and works immediately. Whenever the machine executes the console input instruction (IN instruction), the Console Device initiates a counter that ticks with each unprivileged instruction executed after the IN instruction. Once the counter reaches a threshold value specified during boot-time (see --console option of the XSM simulator ), the counter and the machine simulator waits for the user to enter some data into the console. When the user eventually enters the input, the counter is reset and the console interrupt (INT 3) is raised. At that point, the machine executes the following actions: Increment the value of the SP register and push the value in the IP register into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the interrupt vector table entry for the console interrupt handler. The vector table entry for console interrupt is located at physical address 495 in page 0 (ROM) of XSM and the value 4096 is preset in this location. Hence, the IP register gets value 4096 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 4096, and the machine will continue execution in previleged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Thus the occurance of the console interrupt results in machine execution to be transferred to the console interrupt handler (INT 3) stored in page 8-9. As noted above, the macro instruction IN is used to send input requests to the Console device. The Console Device does not support parallel input requests. Thus it is the OS Programmer's duty to ensure that multiple IN requests are not raised. Control is transferred to the user program by the interrupt routine only after the user inputs a word from the Console. The INI instruction (which can be used only in debug mode) is a special instruction which allows synchronous console input where the machine doesn't raise an interrupt but waits for the user to enter the data before proceeding to the next instruction.","title":"Console Interrupt"},{"location":"arch-spec/interrupts-exception-handling/#race-conditions","text":"After the execution of an instruction in unpriviliged mode, suppose the machine finds that multiple interrupts are pending - say the disk, console and timer interrupts are simultaniously due, then the machine executes the interrupts in the following order - first timer, second disk and third console. After executing the first handler, the machine returns to unpreviliged mode and immedietely executes steps (1) and (2) in the next interrupt and so on till all pending interrupts are processed. As noted above, if an exception occurs at the point of handling any of the above interrupts, the exception is handled first.","title":"Race Conditions"},{"location":"arch-spec/interrupts-exception-handling/#exceptions","text":"Exceptions are anomalous situations which changes the normal flow of execution. The machine raises an exception when it runs in user mode and encounters an anomalous situation during program execution like division by zero or generation of an invalid address. All exceptions raise Interrupt 0. The XSM Register set consists of four special registers for storing the details regarding exceptions. The exception registers are as shown below 1) Exception IP (EIP) : Stores the value of IP at the point where the exception occurred. 2) Exception Page Number (EPN) : This field is relevant when a Page Fault Exception occurs. The logical page number which caused a page fault exception is stored here. 3) Exception Cause (EC) : This field indicates a number which corresponds to the cause of the exception. Exceptions can be caused when the following events occur. Page Fault : The value stored in the EC register for this exception is 0. Illegal instruction : The value stored in the EC register for this exception is 1. Illegal memory access : The value stored in the EC register for this exception is 2. Arithmetic exception : The value stored in the EC register for this exception is 3. 4) Exception Memory Address (EMA) : Exception Memory Address register is relevant only in the case of illegal memory access . The illegal memory which was tried to be accessed is stored in the register. This field is relevant only when either the address referred to is outside the range 0 - 512*(PTLR-1) or a write is attempted to a page which is read-only. A detailed discussion on various conditions leading to the machine raising an exception are below:-","title":"Exceptions"},{"location":"arch-spec/interrupts-exception-handling/#illegal-instruction","text":"occurs when one of the following conditions occur:- Destination of a MOV operation is a constant. A register/port not allowed in user mode is accessed. A privileged mode instruction is executed. There is an instruction that does not belong to XSM instruction set or an instruction is given with more/less operands than allowed - syntax error. INT n instruction - n is not in the valid range (4-18). When one of the above events occur, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contents are not valid for this exception. EC is set to value 1 corresponding to illegal instruction. EMA contents are not valid for this exception. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without peforming address translation).","title":"Illegal instruction"},{"location":"arch-spec/interrupts-exception-handling/#illegal-memory-access","text":"occurs when one of the following conditions occur:- A MOV instruction has an address not in the range 0 to PTLR*512-1. (Even indirect addressing as in MOV R0, [R1] can cause such addresses) RET/POP executed with SP not between 0 and PTLR*512-1. CALL/INT/PUSH/hardware interrupt executed with SP not between -1 and PTLR*512-2. JZ/JNZ/JMP Instruction is executed with IP value not in the range 0 to PTLR*512-1. Write is attempted to a page whose write permission bit in the page table entry has been set to 0. When one of the above events occur, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contents are not valid for this exception. EC is set to value 2 corresponding to illegal memory access. EMA is set to logical address that caused the illegal memory access. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without performing address translation).","title":"Illegal Memory Access"},{"location":"arch-spec/interrupts-exception-handling/#arithmetic-exception","text":"Occurs during DIV/MOD instruction with the second operator having value zero. When an arithmetic exception occurs, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contents are not valid for this exception. EC is set to value 3 corresponding to arithmetic exception. EMA contents are not valid for this exception. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without performing address translation).","title":"Arithmetic exception"},{"location":"arch-spec/interrupts-exception-handling/#page-fault","text":"Occurs when none of the conditions above hold, and the valid bit of the page referenced is set to 0. When one of the above events occur, the machine does the following:- EIP is set to the value of the IP register, from which instruction that caused the exception was fetched. EPN contains the logical page number of the page accessed, that caused the exception. EC is set to value 0 corresponding to page fault. EMA contents are not valid for this exception. Set IP to value stored in the interrupt vector table entry for the exception handler. The vector table entry for exception handler is located at physical address 492 in page 0 (ROM) of XSM and the value 1024 is preset in this location. Hence, the IP register gets value 1024 and the machine switches to privileged mode. Consequently, the next instruction will be fetched from physical address 1024, and the machine will continue execution in previleged mode (without performing address translation).","title":"Page Fault"},{"location":"arch-spec/interrupts-exception-handling/#software-interrupts","text":"Software Interrupts are the primary mechanisms by which a user mode program transfers control to the corresponding interrupt handler that runs in the kernel mode. Software interrupt service routines typically contain the OS code for various system calls. Upon return from a software interrupt using the IRET instruction, execution resumes from the next instruction in the user mode program. A total of 15 software interrupts are available (Interrupt 4 - Interrupt 18). Note that user mode programs cannot invoke the hardware interrupt routines . When an INT n (n in the range 4-18) instruction occurs, the machine executes the following actions: Increment the value of the SP register and push the value in the IP + 2 (logical address of the next instruction to be executed upon return from the interrupt handler) into the memory address pointed to by SP. Since the machine is executing in unpreviliged mode, the address in SP is treated as a logical address and the machine performs address translation to calculate the physical address corresponding to the SP value. Set IP to value stored in the vector table entry for the corresponding interrupt. The vector table entry for INT n is located at physical address 492 + n in page 0 (ROM) of XSM and the values are preset as specified in the Boot ROM and Boot Block section of XSM Machine Organisation documentation. Hence, the IP register gets the value preset in the interrupt vector table and the machine switches to privileged mode. Consequently, the next instruction will be fetched from the preset value, and the machine will continue execution in previleged mode (without peforming address translation). Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section above on exception handling). Note INT instruction cannot be executed when the machine is executing in privileged mode. (see instruction set )","title":"Software Interrupts"},{"location":"arch-spec/machine-organization/","text":"Processor \u00b6 The processor consists of a set of registers and ports along with the hardware for performing control and arithmetic/logic operations, paging etc. Each register/port can store a string. The machine is equipped with an instruction set . Two contiguous memory words are necessary to store each XSM instruction. The reader is assumed to have a basic understanding of the general principles of computer organization, hardware and software interrupts, exceptions, and hardware paging to follow the processor description in this document. The processor has two fundamental modes of operation - privileged execution mode and the unprivileged execution mode . A program executing in the privileged mode can execute any XSM instruction and has the full view of the memory and the disk. A program executing in the unprivileged mode has access only to a restricted machine model called the XSM virtual machine . The instruction set and the memory model available to a program executing in unprivileged mode is a subset of that in the privileged mode. These are called the virtual machine instruction set and the virtual machine memory model respectively. ( See Virtual Machine Specification for more). XSM implements the virtual machine model using its paging hardware . XSM Machine Registers/Ports \u00b6 The XSM architecture maintains 29 registers, each capable of storing a word. Only a few of them are accessible in unprivileged mode. Several registers are special purpose registers reserved for specific purposes. The machine also contains 4 ports, of which one port is used for Standard Input and another one is used for Standard Output. The remaining ports are unused in the present version of XSM. The following table gives an overview of XSM registers/ports according to their category. Registers Purpose Access Mode *R0-R19 General Purpose User Registers Unprivileged BP, SP, IP Base, Stack and Instruction Pointers Unprivileged PTBR, PTLR Page Table (Base, Length) Registers Privileged EIP, EC, EPN, EMA Exception Status Registers Privileged P0-P3 (Ports) P0-Input port, P1-Output port P2,P3-Unused Privileged * The registers R12 - R15 (both inclusive) must be used by the system programmer with caution as they may be used by the OS. Memory \u00b6 Memory refers to the physical memory of the machine and is a volatile storage. The memory is organized as a sequence of pages . Each page is a sequence of 512 words. The total number of memory pages available is 128. Thus there are in total 512 x 128 = 65536 words of storage. The memory is word addressable. The machine contains data transfer instructions that allow a word to be transferred from memory to a register/port and back. When the machine is executing in privileged mode, a memory address \u201cN\u201d between 0 and 65535 refers to the word with offset (N mod 512) in page number (N div 512). Note Since the memory model is different when the machine operates in unprivileged mode, the total amount of memory and the interpretation of addresses are different and will be discussed in the Virtual Machine Specification . The Memory of the XSM Machine is organised as follows : Page Number Contents Word Address Number of Words 0 ROM Code 0 - 511 512 1 Page for loading the BOOT block 512 - 1023 512 2 - 3 Exception handler (INT 0) 1024 - 2047 1024 4 - 5 Timer Interrupt (INT 1) 2048 - 3071 1024 6 - 7 Disk Interrupt (INT 2) 3072 \u2013 4095 1024 8 - 9 Console Interrupt (INT 3) 4096 \u2013 5119 1024 10 - 11 INT 4 (Create, Delete) 5120 - 6143 1024 12 - 13 INT 5 (Seek, Open, Close) 6144 - 7167 1024 14 - 15 INT 6 (Read) 7168 - 8191 1024 16 - 17 INT 7 (Write) 8192 - 9215 1024 18 - 19 INT 8 (Fork) 9216 - 10239 1024 20 - 21 INT 9 (Exec) 10240 - 11263 1024 22 - 23 INT 10 (Exit) 11264 - 12287 1024 24 - 25 INT 11 (Getpid, Getppid, Wait, Signal) 12288 - 13311 1024 26 - 27 INT 12 (Logout) 13312 - 14335 1024 28 - 29 INT 13 (Semget, Semrelease) 14336 - 15359 1024 30 - 31 INT 14 (SemLock, SemUnLock) 15360 - 16383 1024 32 - 33 INT 15 (Shutdown) 16384 - 17407 1024 34 - 35 INT 16 (Newusr, Remusr, Setpwd, Getuname, Getuid) 17408 - 18431 1024 36 - 37 INT 17 (Login) 18432 - 19455 1024 38 - 39 INT 18 (Test0, Test1, Test2, Test3) 19456 - 20479 1024 40 - 127 Unreserved Pages 20480 - 65535 45056 Note The last 19 words of page 0 are reserved for an interrupt vector table with 19 entries. The kth entry contains the page number where the handler for the kth interrupt service routine begins. Upon encountering the INT k instruction during machine execution, the machine transfers control to the beginning of the page indicated in the corresponding vector table entry. The version of the XSM machine described here assumes that the vector table entries are hard coded in the ROM code according to the above table. Disk \u00b6 The disk is organized as a sequence of 512 blocks . Each block is a sequence of 512 words . Thus there are a total of 512x512=262144 words of secondary storage. The disk is block accessible and not word accessible. This means that a word within a block can be accessed individually only after transferring the block into memory and then accessing the corresponding word from the memory. A block index between 0 and 511 refers to the corresponding disk block. The block 0 of the disk is reserved for boot block and will be loaded into the memory at the time of system startup. The machine instruction set includes four special disk access macro routines (load, loadi and store - see instruction set ) for disk-block to memory-page data transfer and back. These are actually macros whose internal details are hidden from programs. These macros are accessible only when the machine is executing in privileged mode. XSM gives no provision for programs to access the disk directly while executing in unprivileged mode. Note The fact that both page-size and block-size are the same makes disk to memory transfer easy in XSM. In real machines, this is normally not the case and the disk access routines have to do the necessary size mappings. Timer \u00b6 Timer is a device that can be set to interrupt the processor each time after the machine executes XSM_TICKS instructions in unprivileged mode (If the XSM_TICKS numbered instruction changes mode from unprivileged to privileged, then the interrupt occurs before executing the next instruction after the machine is back to unprivileged mode). The value of XSM_TICKS must be set externally. (XSM specification leaves how XSM_TICKS is initialized to the implementation.) Upon receipt of the interrupt, the machine switches to the privileged mode and executes the timer interrupt service routine . Disk Controller \u00b6 Disk Controller is the device that controls the data transfer between the memory and the disk. If the load macro or store macro is used for disk-memory transfer, then upon subsequent completion of XSM_DTIME instructions in the unprivileged mode, the disk controller interrupts the machine. (If the XSM_DTIME numbered instruction changes mode from unprivileged to privileged, then the interrupt occurs before executing the next instruction after the machine is back to unprivileged mode). Upon receipt of the interrupt, the machine executes disk interrupt service routine . If the loadi macro is used for disk-memory transfer, the machine will wait for the block transfer and will continue the execution of next instruction only after the block transfer is complete. Console/Terminal \u00b6 The console device is a single device that handles the standard input and output. The OUT instruction displays the contents of port P1 onto the terminal (see instruction set) . If the XSM machine executes an IN instruction, the console device waits for the user to enter a word into the console. When a word is entered, the console device transfers the word to the port P0 and raises the console interrupt (see console interrupt handling) . The console device ignores any further input entered by the user before the execution of another IN/INI instruction. While the console waits for the user input, the XSM machine proceeds the execution of the next instruction. If the XSM machine executes the INI instruction (which can be used only in debug mode), the console device as well as the XSM machine waits for the user input and the data entered is immediately transferred to the port P0, only after which the next instruction is executed. No interrupt is generated by the INI instruction. The contents of port P0 may be transfered to other registers/memory using the MOV instruction inside the console interrupt routine. Note that P0 will contain valid data only after the console has sent an interrupt for the IN instruction. Boot ROM and Boot block \u00b6 When XSM machine starts up, program execution starts at the first word of the first page (Page 0) of memory. There is a pre-loaded ROM code in Page 0 called the bootstrap loader . This code loads the 1st disk block (block 0) called the boot block from the disk to page 1 of memory and then transfers control (using the jump instruction) to the 1st instruction in page 1. This mechanism allows programmers to write their code and store it in the boot block so that when the machine starts up, control is transferred to this code. The XSM machine has an interrupt vector table that maps each interrupt number to a corresponding address (of the interrupt handler). The vector table is stored starting from physical address 492 of memory. Locations 492,493,494 and 495 stores the addresses of exception handler, timer interrupt handler, disk interrupt handler and console interrupt handler. Location 496 contains the address of the first trap handler - INT 4, location 497 contains address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address and IP is set to this value. Note that the interrupt vector table is hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of the handlers. Note Boot ROM code contains just 2 instructions (to load the Boot Block to page 1 and then jump to page 1 which now contains Boot Block). So, after the execution of Boot ROM, control is transferred to 1st instruction in page 1.","title":"Machine Organisation"},{"location":"arch-spec/machine-organization/#processor","text":"The processor consists of a set of registers and ports along with the hardware for performing control and arithmetic/logic operations, paging etc. Each register/port can store a string. The machine is equipped with an instruction set . Two contiguous memory words are necessary to store each XSM instruction. The reader is assumed to have a basic understanding of the general principles of computer organization, hardware and software interrupts, exceptions, and hardware paging to follow the processor description in this document. The processor has two fundamental modes of operation - privileged execution mode and the unprivileged execution mode . A program executing in the privileged mode can execute any XSM instruction and has the full view of the memory and the disk. A program executing in the unprivileged mode has access only to a restricted machine model called the XSM virtual machine . The instruction set and the memory model available to a program executing in unprivileged mode is a subset of that in the privileged mode. These are called the virtual machine instruction set and the virtual machine memory model respectively. ( See Virtual Machine Specification for more). XSM implements the virtual machine model using its paging hardware .","title":"Processor"},{"location":"arch-spec/machine-organization/#xsm-machine-registersports","text":"The XSM architecture maintains 29 registers, each capable of storing a word. Only a few of them are accessible in unprivileged mode. Several registers are special purpose registers reserved for specific purposes. The machine also contains 4 ports, of which one port is used for Standard Input and another one is used for Standard Output. The remaining ports are unused in the present version of XSM. The following table gives an overview of XSM registers/ports according to their category. Registers Purpose Access Mode *R0-R19 General Purpose User Registers Unprivileged BP, SP, IP Base, Stack and Instruction Pointers Unprivileged PTBR, PTLR Page Table (Base, Length) Registers Privileged EIP, EC, EPN, EMA Exception Status Registers Privileged P0-P3 (Ports) P0-Input port, P1-Output port P2,P3-Unused Privileged * The registers R12 - R15 (both inclusive) must be used by the system programmer with caution as they may be used by the OS.","title":"XSM Machine Registers/Ports"},{"location":"arch-spec/machine-organization/#memory","text":"Memory refers to the physical memory of the machine and is a volatile storage. The memory is organized as a sequence of pages . Each page is a sequence of 512 words. The total number of memory pages available is 128. Thus there are in total 512 x 128 = 65536 words of storage. The memory is word addressable. The machine contains data transfer instructions that allow a word to be transferred from memory to a register/port and back. When the machine is executing in privileged mode, a memory address \u201cN\u201d between 0 and 65535 refers to the word with offset (N mod 512) in page number (N div 512). Note Since the memory model is different when the machine operates in unprivileged mode, the total amount of memory and the interpretation of addresses are different and will be discussed in the Virtual Machine Specification . The Memory of the XSM Machine is organised as follows : Page Number Contents Word Address Number of Words 0 ROM Code 0 - 511 512 1 Page for loading the BOOT block 512 - 1023 512 2 - 3 Exception handler (INT 0) 1024 - 2047 1024 4 - 5 Timer Interrupt (INT 1) 2048 - 3071 1024 6 - 7 Disk Interrupt (INT 2) 3072 \u2013 4095 1024 8 - 9 Console Interrupt (INT 3) 4096 \u2013 5119 1024 10 - 11 INT 4 (Create, Delete) 5120 - 6143 1024 12 - 13 INT 5 (Seek, Open, Close) 6144 - 7167 1024 14 - 15 INT 6 (Read) 7168 - 8191 1024 16 - 17 INT 7 (Write) 8192 - 9215 1024 18 - 19 INT 8 (Fork) 9216 - 10239 1024 20 - 21 INT 9 (Exec) 10240 - 11263 1024 22 - 23 INT 10 (Exit) 11264 - 12287 1024 24 - 25 INT 11 (Getpid, Getppid, Wait, Signal) 12288 - 13311 1024 26 - 27 INT 12 (Logout) 13312 - 14335 1024 28 - 29 INT 13 (Semget, Semrelease) 14336 - 15359 1024 30 - 31 INT 14 (SemLock, SemUnLock) 15360 - 16383 1024 32 - 33 INT 15 (Shutdown) 16384 - 17407 1024 34 - 35 INT 16 (Newusr, Remusr, Setpwd, Getuname, Getuid) 17408 - 18431 1024 36 - 37 INT 17 (Login) 18432 - 19455 1024 38 - 39 INT 18 (Test0, Test1, Test2, Test3) 19456 - 20479 1024 40 - 127 Unreserved Pages 20480 - 65535 45056 Note The last 19 words of page 0 are reserved for an interrupt vector table with 19 entries. The kth entry contains the page number where the handler for the kth interrupt service routine begins. Upon encountering the INT k instruction during machine execution, the machine transfers control to the beginning of the page indicated in the corresponding vector table entry. The version of the XSM machine described here assumes that the vector table entries are hard coded in the ROM code according to the above table.","title":"Memory"},{"location":"arch-spec/machine-organization/#disk","text":"The disk is organized as a sequence of 512 blocks . Each block is a sequence of 512 words . Thus there are a total of 512x512=262144 words of secondary storage. The disk is block accessible and not word accessible. This means that a word within a block can be accessed individually only after transferring the block into memory and then accessing the corresponding word from the memory. A block index between 0 and 511 refers to the corresponding disk block. The block 0 of the disk is reserved for boot block and will be loaded into the memory at the time of system startup. The machine instruction set includes four special disk access macro routines (load, loadi and store - see instruction set ) for disk-block to memory-page data transfer and back. These are actually macros whose internal details are hidden from programs. These macros are accessible only when the machine is executing in privileged mode. XSM gives no provision for programs to access the disk directly while executing in unprivileged mode. Note The fact that both page-size and block-size are the same makes disk to memory transfer easy in XSM. In real machines, this is normally not the case and the disk access routines have to do the necessary size mappings.","title":"Disk"},{"location":"arch-spec/machine-organization/#timer","text":"Timer is a device that can be set to interrupt the processor each time after the machine executes XSM_TICKS instructions in unprivileged mode (If the XSM_TICKS numbered instruction changes mode from unprivileged to privileged, then the interrupt occurs before executing the next instruction after the machine is back to unprivileged mode). The value of XSM_TICKS must be set externally. (XSM specification leaves how XSM_TICKS is initialized to the implementation.) Upon receipt of the interrupt, the machine switches to the privileged mode and executes the timer interrupt service routine .","title":"Timer"},{"location":"arch-spec/machine-organization/#disk-controller","text":"Disk Controller is the device that controls the data transfer between the memory and the disk. If the load macro or store macro is used for disk-memory transfer, then upon subsequent completion of XSM_DTIME instructions in the unprivileged mode, the disk controller interrupts the machine. (If the XSM_DTIME numbered instruction changes mode from unprivileged to privileged, then the interrupt occurs before executing the next instruction after the machine is back to unprivileged mode). Upon receipt of the interrupt, the machine executes disk interrupt service routine . If the loadi macro is used for disk-memory transfer, the machine will wait for the block transfer and will continue the execution of next instruction only after the block transfer is complete.","title":"Disk Controller"},{"location":"arch-spec/machine-organization/#consoleterminal","text":"The console device is a single device that handles the standard input and output. The OUT instruction displays the contents of port P1 onto the terminal (see instruction set) . If the XSM machine executes an IN instruction, the console device waits for the user to enter a word into the console. When a word is entered, the console device transfers the word to the port P0 and raises the console interrupt (see console interrupt handling) . The console device ignores any further input entered by the user before the execution of another IN/INI instruction. While the console waits for the user input, the XSM machine proceeds the execution of the next instruction. If the XSM machine executes the INI instruction (which can be used only in debug mode), the console device as well as the XSM machine waits for the user input and the data entered is immediately transferred to the port P0, only after which the next instruction is executed. No interrupt is generated by the INI instruction. The contents of port P0 may be transfered to other registers/memory using the MOV instruction inside the console interrupt routine. Note that P0 will contain valid data only after the console has sent an interrupt for the IN instruction.","title":"Console/Terminal"},{"location":"arch-spec/machine-organization/#boot-rom-and-boot-block","text":"When XSM machine starts up, program execution starts at the first word of the first page (Page 0) of memory. There is a pre-loaded ROM code in Page 0 called the bootstrap loader . This code loads the 1st disk block (block 0) called the boot block from the disk to page 1 of memory and then transfers control (using the jump instruction) to the 1st instruction in page 1. This mechanism allows programmers to write their code and store it in the boot block so that when the machine starts up, control is transferred to this code. The XSM machine has an interrupt vector table that maps each interrupt number to a corresponding address (of the interrupt handler). The vector table is stored starting from physical address 492 of memory. Locations 492,493,494 and 495 stores the addresses of exception handler, timer interrupt handler, disk interrupt handler and console interrupt handler. Location 496 contains the address of the first trap handler - INT 4, location 497 contains address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address and IP is set to this value. Note that the interrupt vector table is hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of the handlers. Note Boot ROM code contains just 2 instructions (to load the Boot Block to page 1 and then jump to page 1 which now contains Boot Block). So, after the execution of Boot ROM, control is transferred to 1st instruction in page 1.","title":"Boot ROM and Boot block"},{"location":"arch-spec/nexsm/","text":"NEXSM is an extension of the XSM architecture with a dual-core feature. The machine has two identical cores with the same set of internal registers sharing a common memory. All registers in XSM are present in both the cores. Additionally, NEXSM cores contain an extra register called the core flag . A few additional privileged instructions provide primitives for synchronization between the two cores. One of the processors is called the primary core and the other called the secondary core . The machine can operate in two modes \u2013 active mode and reset mode . In the reset mode, the secondary is non-functional. The mode in which the machine operates can be controlled by the primary using a pair of special privileged instructions \u2013 START and RESET. Additional Registers \u00b6 The only additional register in NEXSM that is not present in XSM is the core flag (CORE). The core flag is a read-only machine register . The contents of the core flag are set to 0 in the primary core and 1 in the secondary core. The core flag allows a program to test whether it is currently executing in the primary or the secondary. Usage Example: JZ CORE, [Address] /** Tests the value of CORE and branches **/ Dual-Core Bootstrap \u00b6 When powered on, the machine starts in reset mode. The primary core starts execution and the secondary core is non-functional. Here, the functioning is similar to XSM. The secondary core starts execution when the primary core executes a START instruction. Upon execution of the START instruction, the machine enters the active mode. The START instruction sets the IP value of the secondary to physical address 65536 (page 128) and secondary is powered on. Normally, when the machine is powered on, the primary executes a bootstrap code which loads the initialization code for the secondary into memory page 128 before executing START. When the machine is running in active mode, if a RESET instruction is executed by either the primary or the secondary, then the machine goes back to reset mode and the secondary stops execution. Note: The START instruction is ignored if executed in active mode. Similarly, the RESET instruction is ignored when executed in reset mode. Memory Organization \u00b6 NEXSM machine has 144 memory pages (as against 128 pages of XSM). The memory organization of pages 0 to 127 are exactly as in XSM. The organization of the remaining 16 pages are as: Page 128 and 129 are reserved for loading the bootstrap code for the second core. Pages 130 and 131 are reserved for an additional software interrupt INT 19 . Pages 132 to 143 are available as free memory. Disk Organization \u00b6 NEXSM has 16 additional free blocks of disk space, with block numbers 512 to 527. Additional Privileged mode Instructions \u00b6 1. Test and Set Lock Syntax: TSL Rj, [loc] Semantics: The contents of the memory location [loc] is copied to register Rj. The value of [loc] is set to 1. This instruction is atomic . That is, when one of the cores is executing the TSL instruction, the memory bus is locked to avoid the other processor from simultaneously accessing [loc]. 2. Dual-core initialization Syntax: START Semantics: If this instruction is executed by the primary while the machine is in reset mode, then secondary core starts parallel execution at the starting address of memory page 128 (physical address 65536). The START instruction is ignored if executed when the machine is in active mode. 3. Reset instruction Syntax: RESET Semantics: The instruction, when executed in active mode sets the machine to reset mode. The instruction is ignored if executed in reset mode. Interrupts and Exceptions \u00b6 The way NEXSM machine enters privileged mode is similar to XSM. Switch from unprivileged mode to privileged mode happens only when a software/hardware interrupt or exception occurs. The following are the details. The disk and the terminal interrupts apply to the primary core only. Software interrupts, exceptions and timer interrupt applies to both the cores. As with XSM, when a core enters protected mode, interrupts are disabled (on the core). The memory addresses of all interrupt/exception handlers in NEXSM are exactly those in XSM. NEXSM permits an additional software interrupt INT19 (address 66560, pages 130 and 131).","title":"NEXSM (Two Core) Architecture Specification"},{"location":"arch-spec/nexsm/#additional-registers","text":"The only additional register in NEXSM that is not present in XSM is the core flag (CORE). The core flag is a read-only machine register . The contents of the core flag are set to 0 in the primary core and 1 in the secondary core. The core flag allows a program to test whether it is currently executing in the primary or the secondary. Usage Example: JZ CORE, [Address] /** Tests the value of CORE and branches **/","title":"Additional Registers"},{"location":"arch-spec/nexsm/#dual-core-bootstrap","text":"When powered on, the machine starts in reset mode. The primary core starts execution and the secondary core is non-functional. Here, the functioning is similar to XSM. The secondary core starts execution when the primary core executes a START instruction. Upon execution of the START instruction, the machine enters the active mode. The START instruction sets the IP value of the secondary to physical address 65536 (page 128) and secondary is powered on. Normally, when the machine is powered on, the primary executes a bootstrap code which loads the initialization code for the secondary into memory page 128 before executing START. When the machine is running in active mode, if a RESET instruction is executed by either the primary or the secondary, then the machine goes back to reset mode and the secondary stops execution. Note: The START instruction is ignored if executed in active mode. Similarly, the RESET instruction is ignored when executed in reset mode.","title":"Dual-Core Bootstrap"},{"location":"arch-spec/nexsm/#memory-organization","text":"NEXSM machine has 144 memory pages (as against 128 pages of XSM). The memory organization of pages 0 to 127 are exactly as in XSM. The organization of the remaining 16 pages are as: Page 128 and 129 are reserved for loading the bootstrap code for the second core. Pages 130 and 131 are reserved for an additional software interrupt INT 19 . Pages 132 to 143 are available as free memory.","title":"Memory Organization"},{"location":"arch-spec/nexsm/#disk-organization","text":"NEXSM has 16 additional free blocks of disk space, with block numbers 512 to 527.","title":"Disk Organization"},{"location":"arch-spec/nexsm/#additional-privileged-mode-instructions","text":"1. Test and Set Lock Syntax: TSL Rj, [loc] Semantics: The contents of the memory location [loc] is copied to register Rj. The value of [loc] is set to 1. This instruction is atomic . That is, when one of the cores is executing the TSL instruction, the memory bus is locked to avoid the other processor from simultaneously accessing [loc]. 2. Dual-core initialization Syntax: START Semantics: If this instruction is executed by the primary while the machine is in reset mode, then secondary core starts parallel execution at the starting address of memory page 128 (physical address 65536). The START instruction is ignored if executed when the machine is in active mode. 3. Reset instruction Syntax: RESET Semantics: The instruction, when executed in active mode sets the machine to reset mode. The instruction is ignored if executed in reset mode.","title":"Additional Privileged mode Instructions"},{"location":"arch-spec/nexsm/#interrupts-and-exceptions","text":"The way NEXSM machine enters privileged mode is similar to XSM. Switch from unprivileged mode to privileged mode happens only when a software/hardware interrupt or exception occurs. The following are the details. The disk and the terminal interrupts apply to the primary core only. Software interrupts, exceptions and timer interrupt applies to both the cores. As with XSM, when a core enters protected mode, interrupts are disabled (on the core). The memory addresses of all interrupt/exception handlers in NEXSM are exactly those in XSM. NEXSM permits an additional software interrupt INT19 (address 66560, pages 130 and 131).","title":"Interrupts and Exceptions"},{"location":"arch-spec/paging-hardware/","text":"The hardware paging scheme of XSM maps the virtual address space of a user mode program to the physical address space of the machine. Read the XSM Virtual Machine Model before proceeding further. Page Table \u00b6 Every user mode program has an associated page table which maps its virtual address space to the machine's physical address space. For the hardware address translation to work, the base address of the Page Table (of the user mode program currently in execution) must be stored in the Page Table Base Register ( PTBR ) and the number of entries in this Page Table must be stored in the Page Table Length Register ( PTLR ). The page tables must be set up in the privileged mode . Each Page Table stores the physical page number corresponding to all the logical pages of a user mode program. The logical page numbers of a user mode program can vary from 0 to PTLR - 1 . Therefore, each user mode program has a Page Table with PTLR entries. Each page table entry for a logical page is of 2 words . The 1st word must be set to the physical page number in the memory where the logical page is actually loaded. In this case, the page table entry is said to be valid . If the page has not been loaded into the memory, the page table entry is said to be invalid . The 2nd word in a page table entry stores a sequence of flag bits storing information regarding whether the page a) is valid or not b) is read only/read write , c) has been referenced in the user mode after being set to valid and d) has been modified in the user mode after being set to valid ( dirty ). The layout of this word is given below: Reference Bit (R) : This bit must be initialised to 0 (unreferenced) when a page table entry is initially made valid. On a page access, this bit is set to 1 by the machine hardware i.e, as soon as the page is accessed for the first time, this bit is changed from 0 to 1. Page replacement algorithms of operating systems use this bit. Valid/Invalid Bit (V) : This bit indicates whether the entry of the page table is valid or invalid. The Valid/Invalid bit must be set to 1 if the first word of this entry corresponds to a valid physical page number. Its value is set to 0 if the entry is invalid. The Valid/Invalid bit is set by the application, typically the operating system. If memory access is made to a page whose page table entry is invalid, the machine transfers control to the Exception Handler routine . Write Permission Bit (W) : This bit must be set to 1 if the user mode program is permitted to write into the page, otherwise it must be set to 0. If a user mode program tries to modify a page whose Write Permision bit is set to 0, the machine transfers control to the Exception Handler routine . Dirty Bit (D) : This bit is set to 1 by the machine if an instruction modifies the contents of the page. Address Translation Scheme \u00b6 The addresses generated by the machine while executing in user mode are logical addresses. The paging hardware translates these addresses to physical addresses as described below. Address translation is done using the Page Table. Logical address/512 gives the logical page number which is the index of the page table entry for the logical page in the page table. Since each page table entry has 2 words, multiplying the logical page number by 2 and adding the base address of the page table given in the PTBR to it gives the location of the page table entry corresponding to the given logical address. Location of page table entry = PTBR + 2 x (Logical Address / 512) The value stored in the 1st word in the page table entry corresponds to the physical page number. Physical Page Number = [ Location of page table entry ] Offset into the page is calculated as offset = Logical Address % 512 The physical address is computed by multiplying the physical page number by page size (=512) and adding the offset. Physical Address = Physical Page Number x 512 + offset Example \u00b6 Assume the per-process page table is as shown below: Physical Page Number Auxiliary Information (R,V,W,D) 19 0110 20 0110 -1 0000 -1 0000 57 1111 72 1110 48 1111 -1 0000 Example 1 \u00b6 Given a logical address of 3532, the translation occurs as follows: Logical page number = index of page table entry /* index starts from 0 */ = 3532/512 = 6 Location of page table entry = PTBR + 2 * 6 Physical Page Number = [PTBR + 2 * 6 ] = first word of the 7th entry in page table = 48 Offset = 3532%512 = 460 Physical Address = 48 * 512 + 460 = 25036 Example 2 \u00b6 Suppose the machine runs in user mode with IP register pointing to the virtual address 40, and this memory contains the machine instruction MOV R0, [1032] . Memory address 1032 will be resolved as follows: Logical page number = 1032/512 = 2 Since the valid bit is set to 0, in the page table, the page is not physically present in the memory. Hence, the hardware will generate a page fault exception with the exception flag registers set as the following: EIP : 40 (Virtual IP address) EPN : 02 (exception page number) EC : 0 (exception cause - page fault) EMA : 1032","title":"Paging Hardware and Address Translation"},{"location":"arch-spec/paging-hardware/#page-table","text":"Every user mode program has an associated page table which maps its virtual address space to the machine's physical address space. For the hardware address translation to work, the base address of the Page Table (of the user mode program currently in execution) must be stored in the Page Table Base Register ( PTBR ) and the number of entries in this Page Table must be stored in the Page Table Length Register ( PTLR ). The page tables must be set up in the privileged mode . Each Page Table stores the physical page number corresponding to all the logical pages of a user mode program. The logical page numbers of a user mode program can vary from 0 to PTLR - 1 . Therefore, each user mode program has a Page Table with PTLR entries. Each page table entry for a logical page is of 2 words . The 1st word must be set to the physical page number in the memory where the logical page is actually loaded. In this case, the page table entry is said to be valid . If the page has not been loaded into the memory, the page table entry is said to be invalid . The 2nd word in a page table entry stores a sequence of flag bits storing information regarding whether the page a) is valid or not b) is read only/read write , c) has been referenced in the user mode after being set to valid and d) has been modified in the user mode after being set to valid ( dirty ). The layout of this word is given below: Reference Bit (R) : This bit must be initialised to 0 (unreferenced) when a page table entry is initially made valid. On a page access, this bit is set to 1 by the machine hardware i.e, as soon as the page is accessed for the first time, this bit is changed from 0 to 1. Page replacement algorithms of operating systems use this bit. Valid/Invalid Bit (V) : This bit indicates whether the entry of the page table is valid or invalid. The Valid/Invalid bit must be set to 1 if the first word of this entry corresponds to a valid physical page number. Its value is set to 0 if the entry is invalid. The Valid/Invalid bit is set by the application, typically the operating system. If memory access is made to a page whose page table entry is invalid, the machine transfers control to the Exception Handler routine . Write Permission Bit (W) : This bit must be set to 1 if the user mode program is permitted to write into the page, otherwise it must be set to 0. If a user mode program tries to modify a page whose Write Permision bit is set to 0, the machine transfers control to the Exception Handler routine . Dirty Bit (D) : This bit is set to 1 by the machine if an instruction modifies the contents of the page.","title":"Page Table"},{"location":"arch-spec/paging-hardware/#address-translation-scheme","text":"The addresses generated by the machine while executing in user mode are logical addresses. The paging hardware translates these addresses to physical addresses as described below. Address translation is done using the Page Table. Logical address/512 gives the logical page number which is the index of the page table entry for the logical page in the page table. Since each page table entry has 2 words, multiplying the logical page number by 2 and adding the base address of the page table given in the PTBR to it gives the location of the page table entry corresponding to the given logical address. Location of page table entry = PTBR + 2 x (Logical Address / 512) The value stored in the 1st word in the page table entry corresponds to the physical page number. Physical Page Number = [ Location of page table entry ] Offset into the page is calculated as offset = Logical Address % 512 The physical address is computed by multiplying the physical page number by page size (=512) and adding the offset. Physical Address = Physical Page Number x 512 + offset","title":"Address Translation Scheme"},{"location":"arch-spec/paging-hardware/#example","text":"Assume the per-process page table is as shown below: Physical Page Number Auxiliary Information (R,V,W,D) 19 0110 20 0110 -1 0000 -1 0000 57 1111 72 1110 48 1111 -1 0000","title":"Example"},{"location":"arch-spec/paging-hardware/#example-1","text":"Given a logical address of 3532, the translation occurs as follows: Logical page number = index of page table entry /* index starts from 0 */ = 3532/512 = 6 Location of page table entry = PTBR + 2 * 6 Physical Page Number = [PTBR + 2 * 6 ] = first word of the 7th entry in page table = 48 Offset = 3532%512 = 460 Physical Address = 48 * 512 + 460 = 25036","title":"Example 1"},{"location":"arch-spec/paging-hardware/#example-2","text":"Suppose the machine runs in user mode with IP register pointing to the virtual address 40, and this memory contains the machine instruction MOV R0, [1032] . Memory address 1032 will be resolved as follows: Logical page number = 1032/512 = 2 Since the valid bit is set to 0, in the page table, the page is not physically present in the memory. Hence, the hardware will generate a page fault exception with the exception flag registers set as the following: EIP : 40 (Virtual IP address) EPN : 02 (exception page number) EC : 0 (exception cause - page fault) EMA : 1032","title":"Example 2"},{"location":"feedback/","text":"eXpOS was used for junior level undergraduate instruction at NIT Calicut for a one semester Operating Systems Laboratory elective Course during Monsoon 2020, Monsoon 2019, and Monsoon 2018. The system was used for instruction for a one semester Operating Systems Laboratory course course at IIT Palakkad in 2018. The student feedback from these courses are reported below. An analysis of the feedback is also provided in the end, based on inputs from the instructors and students during 2018 and 2019. NIT-C 2021 NIT-C 2020 NIT-C 2019 NIT-C 2018 IIT PKD 2018 IIT PKD 2023 Analysis of Student Feedback","title":"Student Feedback"},{"location":"feedback/analysis/","text":"Analysis of Student Feedback \u00b6 Analysis of Student Feedback 2019 \u00b6 60% of respondents at NIT Calicut felt that their background was sufficient as compared to 31% in 2018. This is due to the following: A few theory lectures were arranged in the beginning of the semester to discuss background material in computer organisation (paging and address translation, interrupts and exceptions and other features of XSM which are significantly different from the MIPS architecture). Moreover, one senior student volunteer who had done the project in the previous was assigned to mentor each student doing the project in the present year. These steps helped to solve the difficulties substantially. We conclude that conducting a few theory lectures on topics in computer organization that are relevant to the project at the beginning of the course can bring about substantial improvements in student performance. There was a significant increase in the percentage of students who reported that the project brought about substantial improvements to their coding skills (from 24% to 46%). On discussions with students to analyze this feedback, the following was observed. We had made substantial improvements to the XSM debugging environment (which is more or less similar to the GDB environment) before the laboratory was run in 2019. We had also insisted that the students be familiar with the debugging environment at an early stage of the project. Many students reported that the project helped them in improving their code debugging skills considerably; and this resulted in many students reporting that the project improved their coding skills in the feedback form. A significant drop in the percentage of students completing Phase 5 (file system implementation) was observed (from 76% in 2018 to 48% in 2019). Upon checking the facts which lead to this drop, we found that a significant percentage among the 84% students who had completed Phase 4 was working on the file system implementation, and the feedback was collected before they could complete the file system implementation. Most of these students had completed subtaintial parts of the file system. Hence, we still expect that 60-75% of the class to successfully complete (the whole or significant parts of) the file system implementation phase when the course is conducted in future as well. Analysis of Student Feedback 2018 \u00b6 Almost every respondent reported that they could complete Phase 3 (process management) in both the courses (100% at NIT Calicut and 95% at IIT Palakkad). 42% of the students at IIT Palakkad and 50% of the students at NIT Calicut noted that their background in computer organization was insufficient. Interaction with students seem to suggest the following issue. Computer organization typically are based on the MIPS architecture and tend to stress more on the fetch execute cycle, pipelining, cacheing and other architectural design level issues, but lays less stress on page table address translation and the semantics of instructions like push, pop, call, ret and interrupt/exceptions that manipulate the stack. However these ideas need to be understood clearly for doing the project. 53% of the respondents at IIT Palakkad and 88% of the respondents at NIT Calicut noted that 90% of the project can be done completely based on the road map. 48% of the respondents at IIT Palakkad (and 76% at NIT Calicut) completed Phase 5 (process management, interprocess communication and file system implementation). 33% among those who completed Phase 5 at IIT Palakkad (respectively 47% at NIT Calicut) completed all the phases of the project. The disparity in the effectiveness of the road map and the performance statistics in the courses at NIT Calicut and IIT Palakkad is due to the following. The course at NIT Calicut was an elective and hence only students who had sufficient interest and background to follow the project roadmap had enrolled for the project (64 of a total of 158 CS students (40%)). At IIT Palakkad, the project was part of a compulsory core course. 88% of the respondents at NIT Calicut and 68% of the respondents at IIT Palakkad reported that doing the lab gave a clear advantage in understanding the theory. The difference appears to be due to the difference in the instructional methodology adapted for the OS theory course (core in both the institutions). At NIT Calicut, the theory course had a huge (150+) student enrollment and followed a standard theory approach based on Silberschatz et. al., Operating System Concepts . On the other hand, at IIT Palakkad, the class size was small (30+) and the course was based on the OS kernel design approach based on C. Crowley Operating Systems: A Design-Oriented Approach . As the latter text covers many of the design issues encountered during the project, the enforcement that the laboratory gave to the understanding of theory was less dramatic. Whereas 22% of the students at NIT Calicut who completed Stage 5 or above reported that more than 15 hours of work per week was needed for the project, only 11% of the students at IIT Palakkad who completed Stage 5 or above reported so. 67% of the respondents at IIT Palakkad who had completed Stage 5 or above responded that 10-15 hours/week was sufficient whereas only 44% of the respondents at NIT Calicut reported that 10-15 hours/week was sufficient. These differences appear to be linked to the differences in students' prior exposure to programming in the respective institutions. Consequently 87% of the respondents at NIT Calicut noted that the project helped them in improving their coding skills, whereas only 37% of the respondents at IIT Palakkad noted that the project improved their coding skills.","title":"Analysis of Student Feedback"},{"location":"feedback/analysis/#analysis-of-student-feedback","text":"","title":"Analysis of Student Feedback"},{"location":"feedback/analysis/#analysis-of-student-feedback-2019","text":"60% of respondents at NIT Calicut felt that their background was sufficient as compared to 31% in 2018. This is due to the following: A few theory lectures were arranged in the beginning of the semester to discuss background material in computer organisation (paging and address translation, interrupts and exceptions and other features of XSM which are significantly different from the MIPS architecture). Moreover, one senior student volunteer who had done the project in the previous was assigned to mentor each student doing the project in the present year. These steps helped to solve the difficulties substantially. We conclude that conducting a few theory lectures on topics in computer organization that are relevant to the project at the beginning of the course can bring about substantial improvements in student performance. There was a significant increase in the percentage of students who reported that the project brought about substantial improvements to their coding skills (from 24% to 46%). On discussions with students to analyze this feedback, the following was observed. We had made substantial improvements to the XSM debugging environment (which is more or less similar to the GDB environment) before the laboratory was run in 2019. We had also insisted that the students be familiar with the debugging environment at an early stage of the project. Many students reported that the project helped them in improving their code debugging skills considerably; and this resulted in many students reporting that the project improved their coding skills in the feedback form. A significant drop in the percentage of students completing Phase 5 (file system implementation) was observed (from 76% in 2018 to 48% in 2019). Upon checking the facts which lead to this drop, we found that a significant percentage among the 84% students who had completed Phase 4 was working on the file system implementation, and the feedback was collected before they could complete the file system implementation. Most of these students had completed subtaintial parts of the file system. Hence, we still expect that 60-75% of the class to successfully complete (the whole or significant parts of) the file system implementation phase when the course is conducted in future as well.","title":"Analysis of Student Feedback 2019"},{"location":"feedback/analysis/#analysis-of-student-feedback-2018","text":"Almost every respondent reported that they could complete Phase 3 (process management) in both the courses (100% at NIT Calicut and 95% at IIT Palakkad). 42% of the students at IIT Palakkad and 50% of the students at NIT Calicut noted that their background in computer organization was insufficient. Interaction with students seem to suggest the following issue. Computer organization typically are based on the MIPS architecture and tend to stress more on the fetch execute cycle, pipelining, cacheing and other architectural design level issues, but lays less stress on page table address translation and the semantics of instructions like push, pop, call, ret and interrupt/exceptions that manipulate the stack. However these ideas need to be understood clearly for doing the project. 53% of the respondents at IIT Palakkad and 88% of the respondents at NIT Calicut noted that 90% of the project can be done completely based on the road map. 48% of the respondents at IIT Palakkad (and 76% at NIT Calicut) completed Phase 5 (process management, interprocess communication and file system implementation). 33% among those who completed Phase 5 at IIT Palakkad (respectively 47% at NIT Calicut) completed all the phases of the project. The disparity in the effectiveness of the road map and the performance statistics in the courses at NIT Calicut and IIT Palakkad is due to the following. The course at NIT Calicut was an elective and hence only students who had sufficient interest and background to follow the project roadmap had enrolled for the project (64 of a total of 158 CS students (40%)). At IIT Palakkad, the project was part of a compulsory core course. 88% of the respondents at NIT Calicut and 68% of the respondents at IIT Palakkad reported that doing the lab gave a clear advantage in understanding the theory. The difference appears to be due to the difference in the instructional methodology adapted for the OS theory course (core in both the institutions). At NIT Calicut, the theory course had a huge (150+) student enrollment and followed a standard theory approach based on Silberschatz et. al., Operating System Concepts . On the other hand, at IIT Palakkad, the class size was small (30+) and the course was based on the OS kernel design approach based on C. Crowley Operating Systems: A Design-Oriented Approach . As the latter text covers many of the design issues encountered during the project, the enforcement that the laboratory gave to the understanding of theory was less dramatic. Whereas 22% of the students at NIT Calicut who completed Stage 5 or above reported that more than 15 hours of work per week was needed for the project, only 11% of the students at IIT Palakkad who completed Stage 5 or above reported so. 67% of the respondents at IIT Palakkad who had completed Stage 5 or above responded that 10-15 hours/week was sufficient whereas only 44% of the respondents at NIT Calicut reported that 10-15 hours/week was sufficient. These differences appear to be linked to the differences in students' prior exposure to programming in the respective institutions. Consequently 87% of the respondents at NIT Calicut noted that the project helped them in improving their coding skills, whereas only 37% of the respondents at IIT Palakkad noted that the project improved their coding skills.","title":"Analysis of Student Feedback 2018"},{"location":"feedback/iitpkd18/","text":"Aug-Nov 2018, B.Tech Semester 5, Operating Systems Laboratory, IIT Palakkad Number of respondents: 19 Duration of the course: One semester (13 weeks) Type of course: Core. A feedback questionnaire was circulated to all the students who credited the course one week before the end of the semester. The responses are summarized below Major phases of the Project (Each stage subsumes the previous stages): Phase 1: Stage 12-14: Scheduling and kernel stack management Phase 2: Stage 16-19: Device Handling, interrupts and Exceptions Phase 3: Stage 20: Process Management Phase 4: Stage 21-22: Interprocess Communication - Semaphore and Signal-Wait Phase 5: Stage 23-25: File System Implementation Phase 6: Stage 26: User Management and access permissions Phase 7: Stage 27: Memory Management - Disk swap management Q1. Student Performance: How many phases of the project did you complete? Note: Every student who completed Phase 6 also completed Phase 7. Q2. Time Management: How many hours of work did you put into the project per week on an average to complete up to what you have done? Q3. Effectiveness of road map: What percentage of work could be done without having to refer to material outside the roadmap/documentation of project ? Q4. Contribution to understanding of theory: How much did the lab help to improve your understanding of Operating Systems theory? Q5. Contribution to Coding/Software development skills: How far did this lab contribute to the improvement of your coding / software development skills? Q6. Student background: Was your background sufficient for doing the lab ? If not did you feel that your knowledge in any of the following subjects was inadequate for you?","title":"IIT PKD 2018"},{"location":"feedback/iitpkd23/","text":"Aug-Nov 2023, B.Tech Semester 5, Operating Systems Laboratory, IIT Palakkad Number of respondents: 53 Duration of the course: One semester (13 weeks) Type of course: Core. A feedback questionnaire was circulated to all the students who credited the course one week before the end of the semester. The responses are summarized below Major phases of the Project (Each stage subsumes the previous stages): Phase 1: Stage 12-14: Scheduling and kernel stack management Phase 2: Stage 16-19: Device Handling, interrupts and Exceptions Phase 3: Stage 20: Process Management Phase 4: Stage 21-22: Interprocess Communication - Semaphore and Signal-Wait Phase 5: Stage 23-25: File System Implementation Phase 6: Stage 26: User Management and access permissions Phase 7: Stage 27: Memory Management - Disk swap management Q1. Student Performance: How many phases of the project did you complete? Q2. Time Management: How many hours of work did you put into the project per week on an average to complete up to what you have done? Q3. Effectiveness of road map: What percentage of work could be done without having to refer to material outside the roadmap/documentation of project ? Q4. Contribution to understanding of theory: How much did the lab help to improve your understanding of Operating Systems theory? Q5. Contribution to Coding/Software development skills: How far did this lab contribute to the improvement of your coding / software development skills? Q6. Student background: Was your background sufficient for doing the lab ? If not did you feel that your knowledge in any of the following subjects was inadequate for you?","title":"Index"},{"location":"feedback/nitc18/","text":"Monsoon 2018, B.Tech Semester 5, Operating Systems Laboratory, NIT Calicut Number of respondents: 42 Duration of the course: One semester (13 weeks) Type of course: Elective. A feedback questionnaire was circulated to all the students who credited the course one week before the end of the semester. The responses are summarized below Major phases of the Project (Each stage subsumes the previous stages): Phase 1: Stage 12-14: Scheduling and kernel stack management Phase 2: Stage 16-19: Device Handling, interrupts and Exceptions Phase 3: Stage 20: Process Management Phase 4: Stage 21-22: Interprocess Communication - Semaphore and Signal-Wait Phase 5: Stage 23-25: File System Implementation Phase 6: Stage 26: User Management and access permissions Phase 7: Stage 27: Memory Management - Disk swap management Q1. Student Performance: How many phases of the project did you complete? Q2. Time Management: How many hours of work did you put into the project per week on an average to complete up to what you have done? Q3. Effectiveness of road map: What percentage of work could be done without having to refer to material outside the roadmap/documentation of project ? Q4. Contribution to understanding of theory: How much did the lab help to improve your understanding of Operating Systems theory? Q5. Contribution to Coding/Software development skills: How far did this lab contribute to the improvement of your coding / software development skills? Q6. Student background: Was your background sufficient for doing the lab ? If not did you feel that your knowledge in any of the following subjects was inadequate for you?","title":"NIT-C 2018"},{"location":"feedback/nitc19/","text":"Monsoon 2019, B.Tech Semester 5, Operating Systems Laboratory, NIT Calicut Number of respondents: 58 Duration of the course: One semester (13 weeks) Type of course: Elective A feedback questionnaire was circulated to all the students who credited the course one week before the end of the semester. The responses are summarized below Major phases of the Project (Each stage subsumes the previous stages): Phase 1: Stage 12-14: Scheduling and kernel stack management Phase 2: Stage 16-19: Device Handling, interrupts and Exceptions Phase 3: Stage 20: Process Management Phase 4: Stage 21-22: Interprocess Communication - Semaphore and Signal-Wait Phase 5: Stage 23-25: File System Implementation Phase 6: Stage 26: User Management and access permissions Phase 7: Stage 27: Memory Management - Disk swap management Phase 8: Stage 28: Multi-core Extension Q1. Student Performance: How many phases of the project did you complete? Q2. Time Management: How many hours of work did you put into the project per week on an average to complete up to what you have done? Q3. Effectiveness of road map: What percentage of work could be done without having to refer to material outside the roadmap/documentation of project ? Q4. Contribution to understanding of theory: How much did the lab help to improve your understanding of Operating Systems theory? Q5. Contribution to Coding/Software development skills: How far did this lab contribute to the improvement of your coding / software development skills? Q6. Student background: Was your background sufficient for doing the lab ? If not did you feel that your knowledge in any of the following subjects was inadequate for you?","title":"NIT-C 2019"},{"location":"feedback/nitc20/","text":"Monsoon 2020, B.Tech Semester 5, Operating Systems Laboratory, NIT Calicut Number of respondents: 74 Duration of the course: One semester (13 weeks) Type of course: Elective A feedback questionnaire was circulated to all the students who credited the course one week before the end of the semester. The responses are summarized below Major phases of the Project (Each stage subsumes the previous stages): Phase 1: Stage 12-14: Scheduling and kernel stack management Phase 2: Stage 16-19: Device Handling, interrupts and Exceptions Phase 3: Stage 20: Process Management Phase 4: Stage 21-22: Interprocess Communication - Semaphore and Signal-Wait Phase 5: Stage 23-25: File System Implementation Phase 6: Stage 26: User Management and access permissions Phase 7: Stage 27: Memory Management - Disk swap management Phase 8: Stage 28: Multi-core Extension Q1. Student Performance: How many phases of the project did you complete? Q2. Time Management: How many hours of work did you put into the project per week on an average to complete up to what you have done? Q3. Effectiveness of road map and Documentation: Was the documentation provided in the roadmap and the Expos site sufficient for doing the project? Q4. Contribution to the understanding of theory: How much did the lab help to improve your understanding of Operating Systems theory? Q5. Contribution to Coding/Software development skills: How far did this lab contribute to the improvement of your coding, debugging and software development skills? Q6: Student background: Was your background sufficient for doing the lab? If not did you feel that your knowledge in any of the following subjects was inadequate for you?","title":"NIT-C 2020"},{"location":"feedback/nitc21/","text":"Monsoon 2021, B.Tech Semester 5, Operating Systems Laboratory, NIT Calicut Number of respondents: 36 Duration of the course: One semester (13 weeks) Type of course: Elective A feedback questionnaire was circulated to all the students who credited the course one week before the end of the semester. The responses are summarized below Major phases of the Project (Each stage subsumes the previous stages): Phase 1: Stage 12-14: Scheduling and kernel stack management Phase 2: Stage 16-19: Device Handling, interrupts and Exceptions Phase 3: Stage 20: Process Management Phase 4: Stage 21-22: Interprocess Communication - Semaphore and Signal-Wait Phase 5: Stage 23-25: File System Implementation Phase 6: Stage 26: User Management and access permissions Phase 7: Stage 27: Memory Management - Disk swap management Phase 8: Stage 28: Multi-core Extension Q1. Student Performance: How many phases of the project did you complete? Q2. Time Management: How many hours of work did you put into the project per week on an average to complete up to what you have done? Q3. Effectiveness of road map and Documentation: Was the documentation provided in the roadmap and the Expos site sufficient for doing the project? Q4. Contribution to the understanding of theory: How much did the lab help to improve your understanding of Operating Systems theory? Q5. Contribution to Coding/Software development skills: How far did this lab contribute to the improvement of your coding, debugging and software development skills? Q6: Student background: Was your background sufficient for doing the lab? If not did you feel that your knowledge in any of the following subjects was inadequate for you?","title":"NIT-C 2021"},{"location":"modules/","text":"These routines are invoked from within system calls/interrupts/exception handler. A user program is not allowed to call a kernel module directly. While executing a blocking system call, a process may block inside a module. In that case, the module will invoke the scheduler to execute other processes. The OS, in fact, is designed in such a way that blocking can happen only inside modules. Each module may contain calls to other modules (made through the CALL instruction). A module returns to its caller using the RET instruction. Modules may also be called from interrupt/exception handlers. Note that a process remains in the kernel mode through out the execution (as well as entry and exit) of a module. A module may implement several functions. Each function within a module is identified by a function number which must be passed as an argument to the module through register R1. Other arguments must be passed through registers R2, R3 etc. in that order. The return value from a module must be passed through register R0. (See SPL documentation on module calling conventions here . ) The kernel modules and the functions present in each module are described below. module-0 : Resource Manager \u00b6 Function Number Function Name Arguments 1 Acquire Buffer Buffer Number, PID 2 Release Buffer Buffer Number, PID 3 Acquire Disk* PID 4 Acquire Inode Inodeindex, PID 5 Release Inode Inodeindex, PID 6 Acquire Semaphore PID 7 Release Semaphore PID 8 Acquire Terminal PID 9 Release Terminal PID *Release function for the disk is implimented in the disk interrupt handler. module-1 : Process Manager \u00b6 Function Number Function Name Arguments 1 Get Pcb Entry NIL 2 Free User Area Page PID 3 Exit Process PID 4 Free Page Table PID 5 Kill All PID module-2 : Memory Manager \u00b6 Function Number Function Name Arguments 1 Get Free Page NIL 2 Release Page Page Number 3 Get Free Block NIL 4 Release Block Block Number 5 Get Code Page Block Number, PID 6 Get Swap Block NIL module-3 : File Manager \u00b6 Function Number Function Name Arguments 1 Buffered Write Disk Block Number, Offset, Word 2 Buffered Read Disk Block Number, Offset, Memory Address 3 Open File Name 4 Close File Table Index module-4 : Device Manager \u00b6 Function Number Function Name Arguments 1 Disk Store PID, Page Number, Block Number 2 Disk Load PID, Page Number, Block Number 3 Terminal Write PID, Word 4 Terminal Read PID, Address module-5 : Context Switch Module (Scheduler Module) \u00b6 Function Number Function Name Arguments - Switch Context Nil module-6 : Pager Module \u00b6 Function Number Function Name Arguments 1 Swap Out Nil 2 Swap In Nil module-7 : Boot Module \u00b6 Function Number Function Name Arguments - - Nil module-8: AccessControl Module \u00b6 Function Number Function Name Arguments Return Value ACQUIRE_KERN_LOCK = 1 Acquire Kernel Lock NIL NIL ACQUIRE_SCHED_LOCK = 2 Acquire Scheduler Lock NIL NIL ACQUIRE_GLOCK = 3 Acquire Glock (Unused) NIL NIL RELEASE_LOCK = 4 Release Lock LockVarAddress NIL","title":"Modules"},{"location":"modules/#module-0-resource-manager","text":"Function Number Function Name Arguments 1 Acquire Buffer Buffer Number, PID 2 Release Buffer Buffer Number, PID 3 Acquire Disk* PID 4 Acquire Inode Inodeindex, PID 5 Release Inode Inodeindex, PID 6 Acquire Semaphore PID 7 Release Semaphore PID 8 Acquire Terminal PID 9 Release Terminal PID *Release function for the disk is implimented in the disk interrupt handler.","title":"module-0 : Resource Manager"},{"location":"modules/#module-1-process-manager","text":"Function Number Function Name Arguments 1 Get Pcb Entry NIL 2 Free User Area Page PID 3 Exit Process PID 4 Free Page Table PID 5 Kill All PID","title":"module-1 : Process Manager"},{"location":"modules/#module-2-memory-manager","text":"Function Number Function Name Arguments 1 Get Free Page NIL 2 Release Page Page Number 3 Get Free Block NIL 4 Release Block Block Number 5 Get Code Page Block Number, PID 6 Get Swap Block NIL","title":"module-2 : Memory Manager"},{"location":"modules/#module-3-file-manager","text":"Function Number Function Name Arguments 1 Buffered Write Disk Block Number, Offset, Word 2 Buffered Read Disk Block Number, Offset, Memory Address 3 Open File Name 4 Close File Table Index","title":"module-3 : File Manager"},{"location":"modules/#module-4-device-manager","text":"Function Number Function Name Arguments 1 Disk Store PID, Page Number, Block Number 2 Disk Load PID, Page Number, Block Number 3 Terminal Write PID, Word 4 Terminal Read PID, Address","title":"module-4 : Device Manager"},{"location":"modules/#module-5-context-switch-module-scheduler-module","text":"Function Number Function Name Arguments - Switch Context Nil","title":"module-5 : Context Switch Module (Scheduler Module)"},{"location":"modules/#module-6-pager-module","text":"Function Number Function Name Arguments 1 Swap Out Nil 2 Swap In Nil","title":"module-6 : Pager Module"},{"location":"modules/#module-7-boot-module","text":"Function Number Function Name Arguments - - Nil","title":"module-7 : Boot Module"},{"location":"modules/#module-8-accesscontrol-module","text":"Function Number Function Name Arguments Return Value ACQUIRE_KERN_LOCK = 1 Acquire Kernel Lock NIL NIL ACQUIRE_SCHED_LOCK = 2 Acquire Scheduler Lock NIL NIL ACQUIRE_GLOCK = 3 Acquire Glock (Unused) NIL NIL RELEASE_LOCK = 4 Release Lock LockVarAddress NIL","title":"module-8: AccessControl Module"},{"location":"modules/module-00/","text":"This module is responsible for allocating and releasing the different resources. Note that the Terminal and Disk devices are freed by the corresponding interrupt handlers. Function Number Function Name Arguments Return Value ACQUIRE_BUFFER = 1 Acquire Buffer Buffer Number, PID NIL RELEASE_BUFFER = 2 Release Buffer Buffer Number, PID 0 or -1 ACQUIRE_DISK = 3 Acquire Disk* PID NIL ACQUIRE_INODE = 4 Acquire Inode Inodeindex, PID 0 or -1 RELEASE_INODE = 5 Release Inode Inodeindex, PID 0 or -1 ACQUIRE_SEMAPHORE = 6 Acquire Semaphore PID Semaphore Table Index or -1 RELEASE_SEMAPHORE = 7 Release Semaphore Semaphore Table Index, PID 0 or -1 ACQUIRE_TERMINAL = 8 Acquire Terminal PID NIL RELEASE_TERMINAL = 9 Release Terminal PID 0 or -1 *Release function for the disk is implimented in the disk interrupt handler. Acquire Buffer \u00b6 Description : Acquire the buffer corresponding to buffer number given as input. Assumes a valid PID and a valid buffer number are given. while ( Buffer is locked ){ /* Check the Locking PID field in the Buffer Status Table */ Set state of the process as ( WAIT_BUFFER , Buffer Number ); Call the switch_context() function from the Scheduler Module . } Lock the Buffer by setting the PID of the current process in the Locking PID field in the Buffer Status Table ; return; Called by BufRead and BufWrite functions in the File Manager . Release Buffer \u00b6 Description : Release the buffer corresponding to buffer number given as input. Assumes a valid PID and a valid buffer number are given. If PID given as input is not equal to the LOCKING PID in the Buffer Status Table , return -1. Free the lock in the the Buffer Status Table entry corresponding to the buffer Number; /* Set Locking PID field to -1 */ loop through the process table{ if (the process state is ( WAIT_BUFFER , Buffer Number ) ){ Set state of process as (READY , _ ) } } return 0; Called by BufRead and BufWrite functions in the File Manager . Acquire Disk \u00b6 Description : Locks the disk device. Assumes that a valid PID is given as input. while ( disk is locked ){ /* Check the Status field in the Disk Status Table . */ Set state of the process as ( WAIT_DISK , - ); Call the switch_context() function from the Scheduler Module . } Lock the disk by setting PID and the status field in the Disk Status Table. return; Called by BufRead and BufWrite functions in the File Manager and the exception handler for swap-in. Acquire Inode \u00b6 Description : Locks the Inode entry corresponding to the inodeindex given as input. Assumes a valid PID and a valid inode index are given. while ( inode is locked ){ /* Check the Lock field in the File Status Table . */ Set state of the process as ( WAIT_FILE , Inode Index ); Call the switch_context() function from the Scheduler Module . } If inode becomes invalid, return -1. /* File was deleted by the time the inode was acquired */ Lock the Inode by setting the Lock field in the File Status Table to the PID of the current process.; return 0; Called by Delete, Read, Write and Seek system calls. Release Inode \u00b6 Description : Frees the lock of the inode entry corresponding to the inodeindex given as input. Assumes a valid PID and a valid inode index are given. If PID given as input is not equal to the LOCKING PID in the File Status Table , return -1. Free the lock in the File Status Table corresponding to the inode index; /* Set the Lock field to -1 */ loop through the process table{ if (the process state is ( WAIT_FILE, Inode Index ) ){ Set state of process as (READY , _ ) } } return 0; Called by Read, Write and Seek system calls. Acquire Semaphore \u00b6 Description : Acquires a semaphore and returns it's semaphore number. Assumes a valid PID is given as input. Returns -1 upon failure. Find the index of a free entry in Semaphore table . If no free entry, return -1. /* Free entry is indicated by a Process Count of 0. */ Set the PROCESS_COUNT to 1 and LOCKING_PID to -1. Return the Semaphore table index. /* success */ Called by the Semget system call . Release Semaphore \u00b6 Description : Releases a semaphore. Assumes a valid PID and semaphore table index are given as input. If ( semaphore is locked by the current process) /*Check the Locking PID in the Semaphore table */ Set the Locking PID to -1. /* Unlock the semaphore before release */ loop through the process table{ /*wake up processes blocked by the semaphore */ if (the process state is ( WAIT_SEMAPHORE, SEMTABLEINDEX ) ){ Set state of process as (READY , _ ) } } Decrement the process count of the semaphore in the semaphore table. /* When the count becomes 0, the semaphore is free. */ Called by the Semrelease and exit system call. Acquire Terminal \u00b6 Description : Locks the Terminal device. Assumes a valid PID is given as input. while ( Terminal device is locked ){ /* Check the Status field in the Terminal Status Table */ Set state of the process as ( WAIT_TERMINAL , - ); Call the switch_context() function from the Scheduler Module . } Lock the Terminal device by setting the Status and PID fields in the Terminal Status Table . return; Called by the Terminal Read and Terimnal Write functions of the Device Manager Module . Release Terminal \u00b6 Description : Frees the Terminal device. Assumes a valid PID is given as input. If PID given as input is not equal to the LOCKING PID in the Teminal Status Table , return -1. Release the lock on the Terminal by updating the Terminal Status Table.; loop through the process table{ if (the process state is ( WAIT_TERMINAL , - ) ){ Set state of process as (READY , _ ) } } Return 0 Called by the Terimnal Write function in the Device Manager Module .","title":"Module 0"},{"location":"modules/module-00/#acquire-buffer","text":"Description : Acquire the buffer corresponding to buffer number given as input. Assumes a valid PID and a valid buffer number are given. while ( Buffer is locked ){ /* Check the Locking PID field in the Buffer Status Table */ Set state of the process as ( WAIT_BUFFER , Buffer Number ); Call the switch_context() function from the Scheduler Module . } Lock the Buffer by setting the PID of the current process in the Locking PID field in the Buffer Status Table ; return; Called by BufRead and BufWrite functions in the File Manager .","title":"Acquire Buffer"},{"location":"modules/module-00/#release-buffer","text":"Description : Release the buffer corresponding to buffer number given as input. Assumes a valid PID and a valid buffer number are given. If PID given as input is not equal to the LOCKING PID in the Buffer Status Table , return -1. Free the lock in the the Buffer Status Table entry corresponding to the buffer Number; /* Set Locking PID field to -1 */ loop through the process table{ if (the process state is ( WAIT_BUFFER , Buffer Number ) ){ Set state of process as (READY , _ ) } } return 0; Called by BufRead and BufWrite functions in the File Manager .","title":"Release Buffer"},{"location":"modules/module-00/#acquire-disk","text":"Description : Locks the disk device. Assumes that a valid PID is given as input. while ( disk is locked ){ /* Check the Status field in the Disk Status Table . */ Set state of the process as ( WAIT_DISK , - ); Call the switch_context() function from the Scheduler Module . } Lock the disk by setting PID and the status field in the Disk Status Table. return; Called by BufRead and BufWrite functions in the File Manager and the exception handler for swap-in.","title":"Acquire Disk"},{"location":"modules/module-00/#acquire-inode","text":"Description : Locks the Inode entry corresponding to the inodeindex given as input. Assumes a valid PID and a valid inode index are given. while ( inode is locked ){ /* Check the Lock field in the File Status Table . */ Set state of the process as ( WAIT_FILE , Inode Index ); Call the switch_context() function from the Scheduler Module . } If inode becomes invalid, return -1. /* File was deleted by the time the inode was acquired */ Lock the Inode by setting the Lock field in the File Status Table to the PID of the current process.; return 0; Called by Delete, Read, Write and Seek system calls.","title":"Acquire Inode"},{"location":"modules/module-00/#release-inode","text":"Description : Frees the lock of the inode entry corresponding to the inodeindex given as input. Assumes a valid PID and a valid inode index are given. If PID given as input is not equal to the LOCKING PID in the File Status Table , return -1. Free the lock in the File Status Table corresponding to the inode index; /* Set the Lock field to -1 */ loop through the process table{ if (the process state is ( WAIT_FILE, Inode Index ) ){ Set state of process as (READY , _ ) } } return 0; Called by Read, Write and Seek system calls.","title":"Release Inode"},{"location":"modules/module-00/#acquire-semaphore","text":"Description : Acquires a semaphore and returns it's semaphore number. Assumes a valid PID is given as input. Returns -1 upon failure. Find the index of a free entry in Semaphore table . If no free entry, return -1. /* Free entry is indicated by a Process Count of 0. */ Set the PROCESS_COUNT to 1 and LOCKING_PID to -1. Return the Semaphore table index. /* success */ Called by the Semget system call .","title":"Acquire Semaphore"},{"location":"modules/module-00/#release-semaphore","text":"Description : Releases a semaphore. Assumes a valid PID and semaphore table index are given as input. If ( semaphore is locked by the current process) /*Check the Locking PID in the Semaphore table */ Set the Locking PID to -1. /* Unlock the semaphore before release */ loop through the process table{ /*wake up processes blocked by the semaphore */ if (the process state is ( WAIT_SEMAPHORE, SEMTABLEINDEX ) ){ Set state of process as (READY , _ ) } } Decrement the process count of the semaphore in the semaphore table. /* When the count becomes 0, the semaphore is free. */ Called by the Semrelease and exit system call.","title":"Release Semaphore"},{"location":"modules/module-00/#acquire-terminal","text":"Description : Locks the Terminal device. Assumes a valid PID is given as input. while ( Terminal device is locked ){ /* Check the Status field in the Terminal Status Table */ Set state of the process as ( WAIT_TERMINAL , - ); Call the switch_context() function from the Scheduler Module . } Lock the Terminal device by setting the Status and PID fields in the Terminal Status Table . return; Called by the Terminal Read and Terimnal Write functions of the Device Manager Module .","title":"Acquire Terminal"},{"location":"modules/module-00/#release-terminal","text":"Description : Frees the Terminal device. Assumes a valid PID is given as input. If PID given as input is not equal to the LOCKING PID in the Teminal Status Table , return -1. Release the lock on the Terminal by updating the Terminal Status Table.; loop through the process table{ if (the process state is ( WAIT_TERMINAL , - ) ){ Set state of process as (READY , _ ) } } Return 0 Called by the Terimnal Write function in the Device Manager Module .","title":"Release Terminal"},{"location":"modules/module-01/","text":"This module contains functions that manage the different aspects related to processes. Function Number Function Name Arguments Return Value GET_PCB_ENTRY = 1 Get Pcb Entry NIL Index of Free PCB. FREE_USER_AREA_PAGE = 2 Free User Area Page PID NIL EXIT_PROCESS = 3 Exit Process PID NIL FREE_PAGE_TABLE = 4 Free Page Table PID NIL KILL_ALL = 5 Kill All PID NIL Get PCB entry \u00b6 Returns a Free PCB index. Returns -1 if PCB is full. loop through the Process Table { if ( process table entry is free ) Set the PID to index of the entry Set the STATE to (ALLOCATED, - ) Set PTBR to PAGE_TABLE_BASE + 20*index /* See Memory Organisation */ Set PTLR to 10. /* Address space of processes in eXpOS has 10 pages */ return index; } return -1; Called by Fork system call. Free User Area Page \u00b6 Frees all the resources in the Resource Table inside the User Area page. Also frees the User Area page. Note The function should be called only when no file/buffer/terminal resource is locked by the process. /* If the user are page is swapped out, it has to be swapped back first. */ Get the User Area Page number from the process table entry corresponding to the PID; loop through the Resource Table { if ( the resource table entry is valid ) if (the resource is a file) Close the corresponding file by calling the Close() function in the File Manager Module. if (the resource is a semaphore) Release the semaphore by calling the Release Semaphore() function in the Resource Manager Module. Invalidate the resource table entry. } Free the User Area page by calling the release_page() function in the Memory Manager module; return; Note The user area page holding the return address for the call to free_user_area_page() has been released! Neverthless the return address and the saved context of the calling process will not be lost. This is because release_page() is non blocking and hence the page will never be allocated to another process before control transfers back to the caller. The calling function gets \"time\" to either invoke the scheduler using the same stack page or to reallocate the same page again for a different purpose. Called by the exit_process function. Exit Process \u00b6 Terminate the process whose PID is provided. Note The function should be called only when no file/terminal/disk/buffer resource is locked by the process. if (the current process is not in the exec system call) // check MODE_FLAG { loop though the process table entries { /* Wake up all processes waiting for the current process */ if ( process is waitng for the current process ) /* indicated by the STATE = (WAIT_PROCESS, PID ) */ Set STATE of the process to (READY, - ) /* Set the children of the process as Orphan */ if ( process has PPID as that of the current process) Set PPID to -1. } } Free the Page Table entry corresponding to the process by invoking the Free_Page_Table() function; Free the User Area Page corresponding to the process by calling the Free_User_Area_Page() function; /* After the User Area Page has been deallocated, the process is executing without a kernel stack. Hence the process should immmediately be scehduled out */ Set the state of process as (TERMINATED , - ) return; /* Note that the return statement is executing using a deallocated stack page. See note after free_user_area_page() */ Called by exec system call, exit system call, exception handler, shutdown and logout. Question Why is the loop in the beginning not executed when called from exec system call? Free Page Table \u00b6 Free the page table entry and the used pages. The Disk Map table entries are also freed. Invalidate the page table entries corresponding to the shared library pages; loop through the other page table entries{ if ( the entry is valid ){ free the corresponding page by invoking the release_page() function in the Memory Manager module ; } Invalidate the page table entry; } Loop through the Disk Map Table entries of the process if (the entry is valid and is stack or heap) call release_block() function in the Memory Manager Module. set the entry to -1. return; Called by the exit_process function. Kill All \u00b6 Kills all the processes except the current process, idle and init/login*. /* Lock all files to ensure that no processes are in the middle of a file operation */ For each valid entry in the Inode table Acquire lock on the file by calling the acquire_inode() function in the Resource Manager module. For each pid from 2 to MAX_PROC_NUM - 1 /* PID 0 is idle and 1 is init */ { /* This code is relevant only when the Pager Module is implemented in Stage 27 */ If pid == PID of Swapper Daemon /* Swapper Daemon must not be TERMINATED */ continue; If pid != pid of the current process AND state of the process in the process table entry is not TERMINATED Call exit_process() function from the Process Manager Module. } For each valid entry in the Inode table Release lock on the file by calling the release_inode() function in the Resource Manager module. return; Called by shutdown and logout system call. Note The init process will be the login process in the multi user extension of eXpOS","title":"Module 1"},{"location":"modules/module-01/#get-pcb-entry","text":"Returns a Free PCB index. Returns -1 if PCB is full. loop through the Process Table { if ( process table entry is free ) Set the PID to index of the entry Set the STATE to (ALLOCATED, - ) Set PTBR to PAGE_TABLE_BASE + 20*index /* See Memory Organisation */ Set PTLR to 10. /* Address space of processes in eXpOS has 10 pages */ return index; } return -1; Called by Fork system call.","title":"Get PCB entry"},{"location":"modules/module-01/#free-user-area-page","text":"Frees all the resources in the Resource Table inside the User Area page. Also frees the User Area page. Note The function should be called only when no file/buffer/terminal resource is locked by the process. /* If the user are page is swapped out, it has to be swapped back first. */ Get the User Area Page number from the process table entry corresponding to the PID; loop through the Resource Table { if ( the resource table entry is valid ) if (the resource is a file) Close the corresponding file by calling the Close() function in the File Manager Module. if (the resource is a semaphore) Release the semaphore by calling the Release Semaphore() function in the Resource Manager Module. Invalidate the resource table entry. } Free the User Area page by calling the release_page() function in the Memory Manager module; return; Note The user area page holding the return address for the call to free_user_area_page() has been released! Neverthless the return address and the saved context of the calling process will not be lost. This is because release_page() is non blocking and hence the page will never be allocated to another process before control transfers back to the caller. The calling function gets \"time\" to either invoke the scheduler using the same stack page or to reallocate the same page again for a different purpose. Called by the exit_process function.","title":"Free User Area Page"},{"location":"modules/module-01/#exit-process","text":"Terminate the process whose PID is provided. Note The function should be called only when no file/terminal/disk/buffer resource is locked by the process. if (the current process is not in the exec system call) // check MODE_FLAG { loop though the process table entries { /* Wake up all processes waiting for the current process */ if ( process is waitng for the current process ) /* indicated by the STATE = (WAIT_PROCESS, PID ) */ Set STATE of the process to (READY, - ) /* Set the children of the process as Orphan */ if ( process has PPID as that of the current process) Set PPID to -1. } } Free the Page Table entry corresponding to the process by invoking the Free_Page_Table() function; Free the User Area Page corresponding to the process by calling the Free_User_Area_Page() function; /* After the User Area Page has been deallocated, the process is executing without a kernel stack. Hence the process should immmediately be scehduled out */ Set the state of process as (TERMINATED , - ) return; /* Note that the return statement is executing using a deallocated stack page. See note after free_user_area_page() */ Called by exec system call, exit system call, exception handler, shutdown and logout. Question Why is the loop in the beginning not executed when called from exec system call?","title":"Exit Process"},{"location":"modules/module-01/#free-page-table","text":"Free the page table entry and the used pages. The Disk Map table entries are also freed. Invalidate the page table entries corresponding to the shared library pages; loop through the other page table entries{ if ( the entry is valid ){ free the corresponding page by invoking the release_page() function in the Memory Manager module ; } Invalidate the page table entry; } Loop through the Disk Map Table entries of the process if (the entry is valid and is stack or heap) call release_block() function in the Memory Manager Module. set the entry to -1. return; Called by the exit_process function.","title":"Free Page Table"},{"location":"modules/module-01/#kill-all","text":"Kills all the processes except the current process, idle and init/login*. /* Lock all files to ensure that no processes are in the middle of a file operation */ For each valid entry in the Inode table Acquire lock on the file by calling the acquire_inode() function in the Resource Manager module. For each pid from 2 to MAX_PROC_NUM - 1 /* PID 0 is idle and 1 is init */ { /* This code is relevant only when the Pager Module is implemented in Stage 27 */ If pid == PID of Swapper Daemon /* Swapper Daemon must not be TERMINATED */ continue; If pid != pid of the current process AND state of the process in the process table entry is not TERMINATED Call exit_process() function from the Process Manager Module. } For each valid entry in the Inode table Release lock on the file by calling the release_inode() function in the Resource Manager module. return; Called by shutdown and logout system call. Note The init process will be the login process in the multi user extension of eXpOS","title":"Kill All"},{"location":"modules/module-02/","text":"This module handles allocation and deallocation of memory pages. The memory free list entry denotes the number of processes using(sharing) the memory page. Unused pages are therefore indicated by 0 in the corresponding entry in memory free list. Function Number Function Name Arguments Return Value GET_FREE_PAGE = 1 Get Free Page NIL Free Page number RELEASE_PAGE = 2 Release Page Page Number NIL GET_FREE_BLOCK = 3 Get Free Block NIL Free Block Number or -1 RELEASE_BLOCK = 4 Release Block Block Number, PID NIL GET_CODE_PAGE = 5 Get Code Page Block Number Page Number GET_SWAP_BLOCK = 6 Get Swap Block NIL Block Number Get Free Page \u00b6 Returns the page number of a free page. Increment WAIT_MEM_COUNT field in the System Status Table while ( memory is full ){ /* Check the MEM_FREE_COUNT in the System Status Table */ Set state of the process as ( WAIT_MEM , ____); Call the switch_context() function from the Scheduler Module . } // There is a free page available for use. Decrement the WAIT_MEM_COUNT field and decrement the MEM_FREE_COUNT field in the System Status Table. loop through entries in the Memory Free List { /* Available pages for user processes are from 76- 127. See Memory Organisation . */ if ( a free entry is found ){ Set the Memory Free List entry as 1; Return the corresponding page number; } } Called by fork and exec system calls. Also called by exception handler on page fault. Release Page \u00b6 Decrements the entry corresponding to page in memory free list. Decrement the entry corresponding to the page in the Memory Free List ; If Mem Free List entry becomes 0, increment the MEM_FREE_COUNT field in the System Status Table loop through the process table{ if (the process state is ( WAIT_MEM , _ ) ){ Set state of process as (READY , _ ) } } return; Called by the Free page table and Free UArea Page functions. Note Do not clear the contents of the page. A page may be shared by multiple processes and a call to release may not make the page free. Get Free Block \u00b6 Returns the block number of a free disk block. Returns -1 if disk is full. loop through entries in the Disk Free List from DISK_FREE_AREA to DISK_SWAP_AREA - 1{ /* User Block, not preallocated to the OS or swap area */ if ( a free entry is found ){ Set the Disk Free List entry as 1; Return the corresponding block number; } } return -1; Release Block \u00b6 Decrements the entry corresponding to the disk block in the disk free list. Set the Disk Free List entry corresponding to the block to 0. return; Get Code Page \u00b6 Loads a single code page to memory given the block number of the page in the disk. It takes the block number and PID as an argument. /* If the required code page is already loaded by some other process, we simply increment the share count in the Mem Free List */ Loop though code page entries in the disk map table of all processes If (the block number in the Disk Map Table entry matches the block to be loaded, and it's corresponding page table entry is set to VALID) { increment the share count of the page in the Mem Free List . return the physical page number } /* The code page is not in memory, and has to be loaded from disk */ Get a free memory page by calling the get_free_page() function. Load the disk block into memory page by calling the disk_load() function in the Device Manager Module. Return the memory page number to which the code block has been loaded. Get Swap Block \u00b6 Returns the block number of a free disk block in the swap area. loop through entries in the Disk Free List from DISK_SWAP_AREA to DISK_SIZE - 1{ /* swap area */ if ( a free entry is found ){ Set the Disk Free List entry as 1; Return the corresponding block number; } } return -1;","title":"Module 2"},{"location":"modules/module-02/#get-free-page","text":"Returns the page number of a free page. Increment WAIT_MEM_COUNT field in the System Status Table while ( memory is full ){ /* Check the MEM_FREE_COUNT in the System Status Table */ Set state of the process as ( WAIT_MEM , ____); Call the switch_context() function from the Scheduler Module . } // There is a free page available for use. Decrement the WAIT_MEM_COUNT field and decrement the MEM_FREE_COUNT field in the System Status Table. loop through entries in the Memory Free List { /* Available pages for user processes are from 76- 127. See Memory Organisation . */ if ( a free entry is found ){ Set the Memory Free List entry as 1; Return the corresponding page number; } } Called by fork and exec system calls. Also called by exception handler on page fault.","title":"Get Free Page"},{"location":"modules/module-02/#release-page","text":"Decrements the entry corresponding to page in memory free list. Decrement the entry corresponding to the page in the Memory Free List ; If Mem Free List entry becomes 0, increment the MEM_FREE_COUNT field in the System Status Table loop through the process table{ if (the process state is ( WAIT_MEM , _ ) ){ Set state of process as (READY , _ ) } } return; Called by the Free page table and Free UArea Page functions. Note Do not clear the contents of the page. A page may be shared by multiple processes and a call to release may not make the page free.","title":"Release Page"},{"location":"modules/module-02/#get-free-block","text":"Returns the block number of a free disk block. Returns -1 if disk is full. loop through entries in the Disk Free List from DISK_FREE_AREA to DISK_SWAP_AREA - 1{ /* User Block, not preallocated to the OS or swap area */ if ( a free entry is found ){ Set the Disk Free List entry as 1; Return the corresponding block number; } } return -1;","title":"Get Free Block"},{"location":"modules/module-02/#release-block","text":"Decrements the entry corresponding to the disk block in the disk free list. Set the Disk Free List entry corresponding to the block to 0. return;","title":"Release Block"},{"location":"modules/module-02/#get-code-page","text":"Loads a single code page to memory given the block number of the page in the disk. It takes the block number and PID as an argument. /* If the required code page is already loaded by some other process, we simply increment the share count in the Mem Free List */ Loop though code page entries in the disk map table of all processes If (the block number in the Disk Map Table entry matches the block to be loaded, and it's corresponding page table entry is set to VALID) { increment the share count of the page in the Mem Free List . return the physical page number } /* The code page is not in memory, and has to be loaded from disk */ Get a free memory page by calling the get_free_page() function. Load the disk block into memory page by calling the disk_load() function in the Device Manager Module. Return the memory page number to which the code block has been loaded.","title":"Get Code Page"},{"location":"modules/module-02/#get-swap-block","text":"Returns the block number of a free disk block in the swap area. loop through entries in the Disk Free List from DISK_SWAP_AREA to DISK_SIZE - 1{ /* swap area */ if ( a free entry is found ){ Set the Disk Free List entry as 1; Return the corresponding block number; } } return -1;","title":"Get Swap Block"},{"location":"modules/module-03/","text":"This module contains the functions that manages files. Important Note All functions in this module expect that the inode is locked before they are called. Function Number FunctionName Arguments Return Value BUFFERED_WRITE = 1 Buffered Write Disk Block Number, Offset, Word NIL BUFFERED_READ = 2 Buffered Read Disk Block Number, Offset, Memory Address NIL OPEN = 3 Open File Name File Table Index, -1 or -2 CLOSE = 4 Close File Table Index NIL Buffered Write \u00b6 The disk page provided is loaded to the corresponding buffer. The word provided is written into the offset position of the buffer. Buffer managemnet is handled by this function internally. Identify the buffer ; /* Buffer Number = (Disk Number % 4) is a simple scheme, good enough for our purposes. More efficient schemes are used in real systems */ Acquire the buffer by calling the Acquire_Buffer() function in the Resource Manager module ; if (the buffer contains a different disk block){ /* check block number in Buffer Table . */ if (the buffer contents are dirty){ /* check DIRTY BIT of buffer table */ Write back the contents of the buffer to the disk by invoking disk_store() function in the device manager module ; } Load the required disk block into the buffer by invoking the disk_load() function in the device manager module ; Set the new Disk block number in the Buffer table entry; } Write the contents of the word taken as input into the offset location in the buffer; Mark the buffer as Dirty; Release the buffer by calling the Release_Buffer() function in the Resource Manager module; return; Called by the Write system call. Buffered Read \u00b6 The disk page provided is loaded to the corresponding buffer. The word present at the offset position of the buffer is copied to the Memory address provided as input. Buffer management is handled by this function internally. NOTE: Physical memory address must be provided. Identify the buffer ; /* Buffer Number = (Disk Number % 4) is a simple scheme, good enough for our purposes. More efficient schemes are used in real systems */ Acquire the buffer by calling the Acquire_Buffer() function in the Resource Manager module ; if (the buffer contains a different disk block){ /* check block number in Buffer Table . */ if (the buffer contents are dirty){ /* check DIRTY BIT of buffer table */ Write back the contents of the buffer to the disk by invoking disk_store() function in the device manager module ; Mark the buffer as clean in the corresponding buffer table entry; } Load the required disk block into the buffer by invoking the disk_load() function in the device manager module; Set the new Disk block number in the Buffer table entry; } Copy the contents in the offset location in the buffer to the physical address given as input; Release the buffer by calling the Release_Buffer() function in the Resource Manager module; return; Called by the Read system call. Open \u00b6 Locates the file in the inode table and makes an entry in the Open File Table. Returns the Open File Table index or an error code if file does not exist or the table is full. On a successfull open, the file status table entry of the file is incremented. Note This function must not be called unless a the calling process has a free entry available in the per-process resource table to store the open file table index returned by this function. Find the index of the Inode Table entry of the file. If the entry is not found, return -1. Call the acquire_inode() function in the Resource Manager module. /* Lock the inode */ If the locking fails, return -1. If the file is of type EXEC, release_inode() and return -1. /* Only data files can be opened */ Find a free entry in the Open File Table . If there are no free entries, release_inode() and return -2. /* Reached maximum number of open files in the system. */ If the file name is \"root\" then Set the INODE INDEX field in the open file table entry to INODE_ROOT . else In the File Status Table , if the File Open Count is -1, set it to 1. Otherwise, increment the File Open Count. Set the INODE INDEX field in the open file table entry to the inode table index of the file. Set the OPEN INSTANCE COUNT to 1 and LSEEK to 0 in the open file table entry. Call the release_inode() function in the Resource Manager module. /* Free the inode */ return the Open File Table Index. Called by the open system call. Question Why don't we need to maintain file open count for the root file? We still need to maintain open instance count for the root file, why? Question After acquiring the inode, why do we check if the input file name matches the inode table entry? Close \u00b6 Closes the open instance of a file. Assumes a valid Open File Table index is given as input. Find the index of the Inode Table entry of the file from the Open File Table. In the Open File Table Entry , decrement the Open Instance Count. If the Open Instance Count becomes 0 Invalidate the entry by setting all fields to -1. If the file is not the \"root\", decrement the File Open Count in the File (Inode) Status Table . If the File Open Count in File Status Table becomes 0, set it to -1. /* Check the INODE_INDEX field in the Open File Table entry */ return; Called by the close, exit system call.","title":"Module 3"},{"location":"modules/module-03/#buffered-write","text":"The disk page provided is loaded to the corresponding buffer. The word provided is written into the offset position of the buffer. Buffer managemnet is handled by this function internally. Identify the buffer ; /* Buffer Number = (Disk Number % 4) is a simple scheme, good enough for our purposes. More efficient schemes are used in real systems */ Acquire the buffer by calling the Acquire_Buffer() function in the Resource Manager module ; if (the buffer contains a different disk block){ /* check block number in Buffer Table . */ if (the buffer contents are dirty){ /* check DIRTY BIT of buffer table */ Write back the contents of the buffer to the disk by invoking disk_store() function in the device manager module ; } Load the required disk block into the buffer by invoking the disk_load() function in the device manager module ; Set the new Disk block number in the Buffer table entry; } Write the contents of the word taken as input into the offset location in the buffer; Mark the buffer as Dirty; Release the buffer by calling the Release_Buffer() function in the Resource Manager module; return; Called by the Write system call.","title":"Buffered Write"},{"location":"modules/module-03/#buffered-read","text":"The disk page provided is loaded to the corresponding buffer. The word present at the offset position of the buffer is copied to the Memory address provided as input. Buffer management is handled by this function internally. NOTE: Physical memory address must be provided. Identify the buffer ; /* Buffer Number = (Disk Number % 4) is a simple scheme, good enough for our purposes. More efficient schemes are used in real systems */ Acquire the buffer by calling the Acquire_Buffer() function in the Resource Manager module ; if (the buffer contains a different disk block){ /* check block number in Buffer Table . */ if (the buffer contents are dirty){ /* check DIRTY BIT of buffer table */ Write back the contents of the buffer to the disk by invoking disk_store() function in the device manager module ; Mark the buffer as clean in the corresponding buffer table entry; } Load the required disk block into the buffer by invoking the disk_load() function in the device manager module; Set the new Disk block number in the Buffer table entry; } Copy the contents in the offset location in the buffer to the physical address given as input; Release the buffer by calling the Release_Buffer() function in the Resource Manager module; return; Called by the Read system call.","title":"Buffered Read"},{"location":"modules/module-03/#open","text":"Locates the file in the inode table and makes an entry in the Open File Table. Returns the Open File Table index or an error code if file does not exist or the table is full. On a successfull open, the file status table entry of the file is incremented. Note This function must not be called unless a the calling process has a free entry available in the per-process resource table to store the open file table index returned by this function. Find the index of the Inode Table entry of the file. If the entry is not found, return -1. Call the acquire_inode() function in the Resource Manager module. /* Lock the inode */ If the locking fails, return -1. If the file is of type EXEC, release_inode() and return -1. /* Only data files can be opened */ Find a free entry in the Open File Table . If there are no free entries, release_inode() and return -2. /* Reached maximum number of open files in the system. */ If the file name is \"root\" then Set the INODE INDEX field in the open file table entry to INODE_ROOT . else In the File Status Table , if the File Open Count is -1, set it to 1. Otherwise, increment the File Open Count. Set the INODE INDEX field in the open file table entry to the inode table index of the file. Set the OPEN INSTANCE COUNT to 1 and LSEEK to 0 in the open file table entry. Call the release_inode() function in the Resource Manager module. /* Free the inode */ return the Open File Table Index. Called by the open system call. Question Why don't we need to maintain file open count for the root file? We still need to maintain open instance count for the root file, why? Question After acquiring the inode, why do we check if the input file name matches the inode table entry?","title":"Open"},{"location":"modules/module-03/#close","text":"Closes the open instance of a file. Assumes a valid Open File Table index is given as input. Find the index of the Inode Table entry of the file from the Open File Table. In the Open File Table Entry , decrement the Open Instance Count. If the Open Instance Count becomes 0 Invalidate the entry by setting all fields to -1. If the file is not the \"root\", decrement the File Open Count in the File (Inode) Status Table . If the File Open Count in File Status Table becomes 0, set it to -1. /* Check the INODE_INDEX field in the Open File Table entry */ return; Called by the close, exit system call.","title":"Close"},{"location":"modules/module-04/","text":"Handles Terminal I/O and Disk operations (Load and Store). Function Number Function Name Arguments Return Value DISK_STORE = 1 Disk Store PID, Page Number, Block Number NIL DISK_LOAD = 2 Disk Load PID, Page Number, Block Number NIL TERMINAL_WRITE = 3 Terminal Write PID, Word NIL TERMINAL_READ = 4 Terminal Read PID, Address NIL Disk Store \u00b6 Description : Stores the contents of the page into the disk block. A valid PID as input is assumed. Acquire the lock on the disk device by calling the Acquire_Disk() function in the Resource Manager module; Set the LOAD/STORE BIT, PAGE NUMBER and BLOCK NUMBER in the Disk Status Table . Use the store statement to store the memory page to disk; Set the state as (WAIT_DISK, - ); Call the switch_context() function from the Scheduler Module . return; Called by Shutdown, Buffer Read and Buffer Write. Disk Load \u00b6 Description : Loads the contents of the disk block to the page. A valid PID as input is assumed. Acquire the lock on the disk device by calling the Acquire_Disk() function in the Resource Manager module; Reset the LOAD/STORE BIT, set PAGE NUMBER and BLOCK NUMBER in the Disk Status Table . Use the load statement to load the disk block to memory; Set the state as (WAIT_DISK, - ); Call the switch_context() function from the Scheduler Module . return; Called by the Buffer Read, Buffer Write functions, exec system call (to load the first code page) and the exception handler (demand paging). Note: The bootstrap code must use loadi statement and not this function. Terminal Write \u00b6 Description : Reads a word from the Memory address provided to the terminal. Assumes a valid PID is given. Acquire the lock on the terminal device by calling the Acquire_Terminal() function in the Resource Manager module; Use the print statement to print the contents of the word to the terminal; Release the lock on the terminal device by calling the Release_Terminal() function in the Resource Manager module; return; Called by the Write system call. Terminal Read \u00b6 Description : Reads a word from the terminal and stores it to the memory address provided. Assumes a valid PID is given. Acquire the lock on the disk device by calling the Acquire_Terminal() function in the Resource Manager module; Use the read statement to read the word from the terminal; Set the state as (WAIT_TERMINAL, - ); Call the switch_context() function from the Scheduler Module . Copy the word from the Input Buffer of the Process Table of the process corresponding to PID to the memory address provided. return; Called by the Read system call. Note The Terminal Interrupt Handler will transfer the contents of the input port P0 to the Input Buffer of the process.","title":"Module 4"},{"location":"modules/module-04/#disk-store","text":"Description : Stores the contents of the page into the disk block. A valid PID as input is assumed. Acquire the lock on the disk device by calling the Acquire_Disk() function in the Resource Manager module; Set the LOAD/STORE BIT, PAGE NUMBER and BLOCK NUMBER in the Disk Status Table . Use the store statement to store the memory page to disk; Set the state as (WAIT_DISK, - ); Call the switch_context() function from the Scheduler Module . return; Called by Shutdown, Buffer Read and Buffer Write.","title":"Disk Store"},{"location":"modules/module-04/#disk-load","text":"Description : Loads the contents of the disk block to the page. A valid PID as input is assumed. Acquire the lock on the disk device by calling the Acquire_Disk() function in the Resource Manager module; Reset the LOAD/STORE BIT, set PAGE NUMBER and BLOCK NUMBER in the Disk Status Table . Use the load statement to load the disk block to memory; Set the state as (WAIT_DISK, - ); Call the switch_context() function from the Scheduler Module . return; Called by the Buffer Read, Buffer Write functions, exec system call (to load the first code page) and the exception handler (demand paging). Note: The bootstrap code must use loadi statement and not this function.","title":"Disk Load"},{"location":"modules/module-04/#terminal-write","text":"Description : Reads a word from the Memory address provided to the terminal. Assumes a valid PID is given. Acquire the lock on the terminal device by calling the Acquire_Terminal() function in the Resource Manager module; Use the print statement to print the contents of the word to the terminal; Release the lock on the terminal device by calling the Release_Terminal() function in the Resource Manager module; return; Called by the Write system call.","title":"Terminal Write"},{"location":"modules/module-04/#terminal-read","text":"Description : Reads a word from the terminal and stores it to the memory address provided. Assumes a valid PID is given. Acquire the lock on the disk device by calling the Acquire_Terminal() function in the Resource Manager module; Use the read statement to read the word from the terminal; Set the state as (WAIT_TERMINAL, - ); Call the switch_context() function from the Scheduler Module . Copy the word from the Input Buffer of the Process Table of the process corresponding to PID to the memory address provided. return; Called by the Read system call. Note The Terminal Interrupt Handler will transfer the contents of the input port P0 to the Input Buffer of the process.","title":"Terminal Read"},{"location":"modules/module-05/","text":"Yields control from the current process and schedules the next process for execution. Function Number Function Name Arguments - Switch Context Nil Switch Context \u00b6 Get the pid of the current process from System Status Table ; Push the BP register of the current process to the top of it's kernel stack. /* The ExpL application does not push the Base Pointer register (BP). See ExpL calling conventions . Hence it is saved to the stop of the Kernel Stack */ Save the SP%512, PTBR and PTLR to the Kernel SP, PTBR and PTLR fields of the Process Table entry of the current process; if (PAGING_STATUS in the System Status Table is not 0) /* Paging is ongoing */ If the paging process is blocked /* the paging process is executing a disk operation */ Choose Idle Process for scheduling. else Choose the Swapper Daemon to be scheduled. else { Find the next non swapped process to schedule using the Round Robin scheduling technique, excluding the Swapper Daemon; /* Check the SWAP_FLAG in the process table */ If no process (that is not swapped out) is in READY or CREATED state, select the Idle process; } Set the PTBR and PTLR registers to the corresponding values in the process table entry of the new process; Set the new PID in the System Status Table; if (the new Process is in CREATED state){ /* The process has just been forked from a parent process */ Set SP to the value of UserSP field in the Process table entry of the new process; Set BP to the value stored at the beginning of the kernel stack. /* BP value of the process is saved to the beginning of the kernel stack by Fork() system call at process creation. */ Set the state of the new process as (RUNNING, - ); Set the MODE_FLAG in the process table entry 0. Use ireturn statement to transfer control back to user mode; } Set the state of the new process as (RUNNING, - ); Read the KPTR field and the UArea Page number from the Process table entry of the new process; Set SP to UArea_Page * 512 + KPTR; Restore the BP register of the new process from the top of it's kernel stack. return;","title":"Module 5"},{"location":"modules/module-05/#switch-context","text":"Get the pid of the current process from System Status Table ; Push the BP register of the current process to the top of it's kernel stack. /* The ExpL application does not push the Base Pointer register (BP). See ExpL calling conventions . Hence it is saved to the stop of the Kernel Stack */ Save the SP%512, PTBR and PTLR to the Kernel SP, PTBR and PTLR fields of the Process Table entry of the current process; if (PAGING_STATUS in the System Status Table is not 0) /* Paging is ongoing */ If the paging process is blocked /* the paging process is executing a disk operation */ Choose Idle Process for scheduling. else Choose the Swapper Daemon to be scheduled. else { Find the next non swapped process to schedule using the Round Robin scheduling technique, excluding the Swapper Daemon; /* Check the SWAP_FLAG in the process table */ If no process (that is not swapped out) is in READY or CREATED state, select the Idle process; } Set the PTBR and PTLR registers to the corresponding values in the process table entry of the new process; Set the new PID in the System Status Table; if (the new Process is in CREATED state){ /* The process has just been forked from a parent process */ Set SP to the value of UserSP field in the Process table entry of the new process; Set BP to the value stored at the beginning of the kernel stack. /* BP value of the process is saved to the beginning of the kernel stack by Fork() system call at process creation. */ Set the state of the new process as (RUNNING, - ); Set the MODE_FLAG in the process table entry 0. Use ireturn statement to transfer control back to user mode; } Set the state of the new process as (RUNNING, - ); Read the KPTR field and the UArea Page number from the Process table entry of the new process; Set SP to UArea_Page * 512 + KPTR; Restore the BP register of the new process from the top of it's kernel stack. return;","title":"Switch Context"},{"location":"modules/module-06/","text":"This module is responsible for swapping in and out processes. Swap-out is initiated from the timer interrupt when the free memory is critically low. Similiarly, if there is enough memory available in the system, swap-in is initiated by the timer. Function Number Function Name Arguments Return Value SWAP_OUT = 1 Swap Out PID NIL SWAP_IN = 2 Swap In PID NIL Swap Out \u00b6 Description \u00b6 Invoked when the physical memory is critically low. The function chooses a process to swap out, and free it's memory by moving it to the disk. PID of the currently running process is passed as an argument. Control flow diagram for *Swap Out* Choose a process to swap out. (other than the IDLE, Shell or INIT) Loop through the Process Table and find a non-swapped process that is in the WAIT_PROCESS state. If there are no non-swapped processes in the WAIT_PROCESS state, find a non-swapped process in the WAIT_SEMAPHORE state. If there are no non-swapped processes in the WAIT_PROCESS and WAIT_SEMAPHORE state, find process with the highest TICK which is not running, terminated, allocated or swapped. If no such process exists, set the PAGING_STATUS back to 0 and return. Set the TICK field of the process table entry of the selected process to 0. /* When the process goes to swap, TICK starts again */ Call the release_page() function in the Memory Manager module to deallocate the valid code pages of the process. Invalidate the Page table entry correpsonding to the code pages. For each heap page that is not shared and is valid { /* Shared heap pages are not swapped out. */ Get a free swap block by calling the get_swap_block() function in the Memory Manager module. Store the disk block number in the Disk Map Table entry of the process curresponding to the heap page. Use the disk_store() function in the Device Manager module to write the heap page to the block found above Call the release_page() function in the Memory Manager module to deallocate the page. Invalidate the Page table entry correpsonding to the page. } Get two free swap block by calling the get_swap_block() function in the Memory Manager module. Use the disk_store() function in the Device Manager module to write the two stack pages to the disk blocks found above. Call the release_page() function in the Memory Manager module to deallocate the two pages. Update the Disk Map Table entry of the process to store the disk block numbers of the stack. Invalidate the Page table entries correpsonding to the two stack pages. Set the SWAP_FLAG field in the process table entry of the process to 1. In the System Status Table , increment the SWAP_COUNT and reset the PAGING_STATUS back to 0. /* The scheduler can now resume normal scheduling */ return; Called by the timer interrupt. Question What is the reasoning behind the order of choosing the process to swap out? Why is a process in WAIT_PROCESS swapped out ahead of a process waiting for the terminal? What about processes waiting for the disk? Swap In \u00b6 Description \u00b6 Invoked when the physical memory is high enough that a process can be swapped in. If a suitable process is found, it is loaded back to the main memory. PID of the currently running process is passed as an argument. Control flow diagram for *Swap In* /* Find if any swapped out process can be made ready to run if brought into memory. */ Loop through the Process Table and find the swapped process in the READY state with the highest TICK. If there is no such process in the READY state, reset the PAGING_STATUS field to 0 and Return. Set the TICK field of the process table entry of the selected process to 0. For each heap page that is swapped out { /* Check the Disk Map Table . */ Call the get_free_page() function in the Memory Manager module to allocate a memory page. Get the disk block number in the Disk Map Table entry of the process corresponding to the heap page. Use the disk_load() function in the Device Manager module to copy the heap page found above to the memory. Free the swap block by calling the release_block() function in the Memory Manager module. Set the Page table entry correpsonding to the page. Reference bit is set to 0, valid bit and write bit are set to 1. Invalidate the Disk Map Table entry corresponding to the heap page. } Get two free memory pages by calling the get_free_page() function in the Memory Manager module. Use the disk_load() function in the Device Manager module to load the two stack pages to the memory allocated above. Set the Page table entries correpsonding to the two stack pages. The pages are valid, unreferenced and writable. Call the release_block() function in the Memory Manager module to deallocate the two swap blocks. Invalidate the Disk Map Table entry of the process corresponding to the pages. Set the SWAP_FLAG field in the process table entry of the process to 0. In the System Status Table , decrement the SWAP_COUNT and reset the PAGING_STATUS back to 0. /* The scheduler can now resume normal scheduling */ return; Called by timer interrupt. Question 1 Is it possible that there are processes waiting for memory, even when MEM_FREE_COUNT > MEM_HIGH? Question 2 Why are code pages not loaded back to memory when the process is swapped in?","title":"Module 6"},{"location":"modules/module-06/#swap-out","text":"","title":"Swap Out"},{"location":"modules/module-06/#description","text":"Invoked when the physical memory is critically low. The function chooses a process to swap out, and free it's memory by moving it to the disk. PID of the currently running process is passed as an argument. Control flow diagram for *Swap Out* Choose a process to swap out. (other than the IDLE, Shell or INIT) Loop through the Process Table and find a non-swapped process that is in the WAIT_PROCESS state. If there are no non-swapped processes in the WAIT_PROCESS state, find a non-swapped process in the WAIT_SEMAPHORE state. If there are no non-swapped processes in the WAIT_PROCESS and WAIT_SEMAPHORE state, find process with the highest TICK which is not running, terminated, allocated or swapped. If no such process exists, set the PAGING_STATUS back to 0 and return. Set the TICK field of the process table entry of the selected process to 0. /* When the process goes to swap, TICK starts again */ Call the release_page() function in the Memory Manager module to deallocate the valid code pages of the process. Invalidate the Page table entry correpsonding to the code pages. For each heap page that is not shared and is valid { /* Shared heap pages are not swapped out. */ Get a free swap block by calling the get_swap_block() function in the Memory Manager module. Store the disk block number in the Disk Map Table entry of the process curresponding to the heap page. Use the disk_store() function in the Device Manager module to write the heap page to the block found above Call the release_page() function in the Memory Manager module to deallocate the page. Invalidate the Page table entry correpsonding to the page. } Get two free swap block by calling the get_swap_block() function in the Memory Manager module. Use the disk_store() function in the Device Manager module to write the two stack pages to the disk blocks found above. Call the release_page() function in the Memory Manager module to deallocate the two pages. Update the Disk Map Table entry of the process to store the disk block numbers of the stack. Invalidate the Page table entries correpsonding to the two stack pages. Set the SWAP_FLAG field in the process table entry of the process to 1. In the System Status Table , increment the SWAP_COUNT and reset the PAGING_STATUS back to 0. /* The scheduler can now resume normal scheduling */ return; Called by the timer interrupt. Question What is the reasoning behind the order of choosing the process to swap out? Why is a process in WAIT_PROCESS swapped out ahead of a process waiting for the terminal? What about processes waiting for the disk?","title":"Description"},{"location":"modules/module-06/#swap-in","text":"","title":"Swap In"},{"location":"modules/module-06/#description_1","text":"Invoked when the physical memory is high enough that a process can be swapped in. If a suitable process is found, it is loaded back to the main memory. PID of the currently running process is passed as an argument. Control flow diagram for *Swap In* /* Find if any swapped out process can be made ready to run if brought into memory. */ Loop through the Process Table and find the swapped process in the READY state with the highest TICK. If there is no such process in the READY state, reset the PAGING_STATUS field to 0 and Return. Set the TICK field of the process table entry of the selected process to 0. For each heap page that is swapped out { /* Check the Disk Map Table . */ Call the get_free_page() function in the Memory Manager module to allocate a memory page. Get the disk block number in the Disk Map Table entry of the process corresponding to the heap page. Use the disk_load() function in the Device Manager module to copy the heap page found above to the memory. Free the swap block by calling the release_block() function in the Memory Manager module. Set the Page table entry correpsonding to the page. Reference bit is set to 0, valid bit and write bit are set to 1. Invalidate the Disk Map Table entry corresponding to the heap page. } Get two free memory pages by calling the get_free_page() function in the Memory Manager module. Use the disk_load() function in the Device Manager module to load the two stack pages to the memory allocated above. Set the Page table entries correpsonding to the two stack pages. The pages are valid, unreferenced and writable. Call the release_block() function in the Memory Manager module to deallocate the two swap blocks. Invalidate the Disk Map Table entry of the process corresponding to the pages. Set the SWAP_FLAG field in the process table entry of the process to 0. In the System Status Table , decrement the SWAP_COUNT and reset the PAGING_STATUS back to 0. /* The scheduler can now resume normal scheduling */ return; Called by timer interrupt. Question 1 Is it possible that there are processes waiting for memory, even when MEM_FREE_COUNT > MEM_HIGH? Question 2 Why are code pages not loaded back to memory when the process is swapped in?","title":"Description"},{"location":"modules/module-07/","text":"This module is responsible for hand creating the INIT and SHELL processes. It loads the modules, interrupt routines and disk data structures which are required by eXpOS from disk to memory. It also initializes different memory data structures which are required to run the OS smoothly. Boot module is invoked only once by the OS Startup code at the time of booting. Algorithm \u00b6 Load the following from the disk to the memory - Exception handler, Timer interrupt handler, Disk interrupt handler, Console (terminal) interrupt handler, Library, Interrupt routines [4 - 17] and Modules [0 - 6]. /* Module 7 (boot module) and IDLE process will be loaded by OS startup code */ Load the following disk data structures to the memory pages of their memory copies - Disk free list, Root file, Inode table and User table. See disk/memory organization . /* Initialize the INIT (Login) process as follows - */ Load only the first code page of INIT process from the disk to the memory. Initialize the Page table for INIT process (PID = 1) Use PAGE_TABLE_BASE + 20 as starting address for the page table of INIT process. Set the memory pages 63 and 64 for library entries in the page table . Set \"0100\" as auxiliary information for library pages. Set the first code page entry to 65 (See memory organization ) and auxiliary information for valid code pages as \"0100\". Set the first stack page entry to 66 and auxiliary information to \"0110\". Set remaining code pages, remaining stack page and heap pages entries to -1 and auxiliary information to \"0000\". Initialize the process table for INIT process. Initialize the fields of process table as - TICK as 0, PID as 1, USERID as 0, STATE as CREATED, USER AREA PAGE NUMBER as 77 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 20 and PTLR as 10. Store the IP value (from the header of the INIT) on top of first user stack page [66*512] = [65*512+1]. /* Initialize the SHELL process */ Load the code pages of SHELL process from the disk to the memory. Initialize the Page table for SHELL process (PID = 2) Use PAGE_TABLE_BASE + 40 as starting address for the page table of SHELL process. Set the memory pages 63 and 64 for library entries in the page table . Set \"0100\" as auxiliary information for library pages. Set the code page entries to 67 and 68 (See memory organization ) and auxiliary information for valid code pages as \"0100\". Allocate two memory pages 78 and 79 for user stack. Set the two stack page entries to allocated memory pages and auxiliary information to \"0110\". Set remaining code pages and heap pages entries to -1 and auxiliary information to \"0000\". Initialize the process table for SHELL process. Initialize the fields of process table as - TICK as 0, PID as 2, USERID as 0, STATE as TERMINATED, USER AREA PAGE NUMBER as 80 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 40 and PTLR as 10. Store the IP value (from the header of the SHELL) on top of first user stack page [78*512] = [67*512 +1]. Initialize Disk Map Table for shell. First two code page entries with 9, 10 and all other entries to -1. /* Initialize all memory data structures */ Set the states of all processes (other than INIT, IDLE, SHELL and Swapper Daemon) in the process table to TERMINATED. Reset the status field in the terminal status table and disk status table to 0. Initialize the memory free list by setting 0 (free) for free entries and 1 for allocated pages. // presently 82 memory pages are allocated Initialize the fields of System Status Table . MEM_FREE_COUNT as 45, WAIT_MEM_COUNT as 0, SWAPPED_COUNT as 0, PAGING_STATUS as 0. Invalidate Per Process Resource Table of INIT and SHELL processes (all entries are set to -1). Store 0 in the PROCESS_COUNT field for all entries in Semaphore Table . Initialize BLOCK NUMBER to -1, DIRTY BIT to 0 and LOCKING PID to -1 for the four buffer pages in the Buffer table . Set FILE OPEN COUNT and LOCKING PID to -1 for all entries in the File Status Table . Set the INODE INDEX to -1 in the Open File Table for all entries.","title":"Module 7"},{"location":"modules/module-07/#algorithm","text":"Load the following from the disk to the memory - Exception handler, Timer interrupt handler, Disk interrupt handler, Console (terminal) interrupt handler, Library, Interrupt routines [4 - 17] and Modules [0 - 6]. /* Module 7 (boot module) and IDLE process will be loaded by OS startup code */ Load the following disk data structures to the memory pages of their memory copies - Disk free list, Root file, Inode table and User table. See disk/memory organization . /* Initialize the INIT (Login) process as follows - */ Load only the first code page of INIT process from the disk to the memory. Initialize the Page table for INIT process (PID = 1) Use PAGE_TABLE_BASE + 20 as starting address for the page table of INIT process. Set the memory pages 63 and 64 for library entries in the page table . Set \"0100\" as auxiliary information for library pages. Set the first code page entry to 65 (See memory organization ) and auxiliary information for valid code pages as \"0100\". Set the first stack page entry to 66 and auxiliary information to \"0110\". Set remaining code pages, remaining stack page and heap pages entries to -1 and auxiliary information to \"0000\". Initialize the process table for INIT process. Initialize the fields of process table as - TICK as 0, PID as 1, USERID as 0, STATE as CREATED, USER AREA PAGE NUMBER as 77 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 20 and PTLR as 10. Store the IP value (from the header of the INIT) on top of first user stack page [66*512] = [65*512+1]. /* Initialize the SHELL process */ Load the code pages of SHELL process from the disk to the memory. Initialize the Page table for SHELL process (PID = 2) Use PAGE_TABLE_BASE + 40 as starting address for the page table of SHELL process. Set the memory pages 63 and 64 for library entries in the page table . Set \"0100\" as auxiliary information for library pages. Set the code page entries to 67 and 68 (See memory organization ) and auxiliary information for valid code pages as \"0100\". Allocate two memory pages 78 and 79 for user stack. Set the two stack page entries to allocated memory pages and auxiliary information to \"0110\". Set remaining code pages and heap pages entries to -1 and auxiliary information to \"0000\". Initialize the process table for SHELL process. Initialize the fields of process table as - TICK as 0, PID as 2, USERID as 0, STATE as TERMINATED, USER AREA PAGE NUMBER as 80 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 40 and PTLR as 10. Store the IP value (from the header of the SHELL) on top of first user stack page [78*512] = [67*512 +1]. Initialize Disk Map Table for shell. First two code page entries with 9, 10 and all other entries to -1. /* Initialize all memory data structures */ Set the states of all processes (other than INIT, IDLE, SHELL and Swapper Daemon) in the process table to TERMINATED. Reset the status field in the terminal status table and disk status table to 0. Initialize the memory free list by setting 0 (free) for free entries and 1 for allocated pages. // presently 82 memory pages are allocated Initialize the fields of System Status Table . MEM_FREE_COUNT as 45, WAIT_MEM_COUNT as 0, SWAPPED_COUNT as 0, PAGING_STATUS as 0. Invalidate Per Process Resource Table of INIT and SHELL processes (all entries are set to -1). Store 0 in the PROCESS_COUNT field for all entries in Semaphore Table . Initialize BLOCK NUMBER to -1, DIRTY BIT to 0 and LOCKING PID to -1 for the four buffer pages in the Buffer table . Set FILE OPEN COUNT and LOCKING PID to -1 for all entries in the File Status Table . Set the INODE INDEX to -1 in the Open File Table for all entries.","title":"Algorithm"},{"location":"modules/module-08/","text":"This module contains the functions that manages access locks. Function Number Function Name Arguments Return Value ACQUIRE_KERN_LOCK = 1 Acquire Kernel Lock NIL NIL ACQUIRE_SCHED_LOCK = 2 Acquire Scheduler Lock NIL NIL ACQUIRE_GLOCK = 3 Acquire Glock (Unused) NIL NIL RELEASE_LOCK = 4 Release Lock LockVarAddress NIL Acquire Kernel Lock \u00b6 Acquires KERN_LOCK which is a common access variable to be set before running any critical kernel code (except the scheduler). Before executing any kernel module/interrupt handler, KERN_LOCK is set (by invoking this function) so that the other core waits till the critical action is completed. After completing the critical kernel code, the ReleaseLock function is used to release KERN_LOCK. if (core is SECONDARY_CORE){ if (PAGING_STATUS or LOGOUT_STATUS is on){ // eXpOS design does not permit a process // to execute critical code on the secondary core when paging or logout is ongoing. Set the state of current process to READY Call the switch_context() function of the Scheduler Module. /* Scheduler Module requires appropriate modifications before running on the NEXSM machine */ } } while ( tsl (KERN_LOCK) == 1 ){ continue; } return; Called by all system calls, exception handler and timer interrupt handler. Acquire Scheduler Lock \u00b6 Acquires SCHED_LOCK which is an access variable to be set before running the scheduler. This ensures that if one core has set SCHED_LOCK, the other core will not enter the Scheduler module until the first core completes the scheduling action. After completing the scheduling action, the ReleaseLock function is used to release SCHED_LOCK. while ( tsl (SCHED_LOCK) == 1 ){ continue; } return; Called by the Scehduler module. Acquire Glock \u00b6 Acquires GLOCK which is a general purpose lock variable that is currently left unused. while ( tsl (GLOCK) == 1 ){ continue; } return; Release Lock \u00b6 Releases the access lock provided as the argument. Store 0 to the address LockVarAddress. return; Called by all system calls, exception handler, timer interrupt handler and scheduler.","title":"Module 8"},{"location":"modules/module-08/#acquire-kernel-lock","text":"Acquires KERN_LOCK which is a common access variable to be set before running any critical kernel code (except the scheduler). Before executing any kernel module/interrupt handler, KERN_LOCK is set (by invoking this function) so that the other core waits till the critical action is completed. After completing the critical kernel code, the ReleaseLock function is used to release KERN_LOCK. if (core is SECONDARY_CORE){ if (PAGING_STATUS or LOGOUT_STATUS is on){ // eXpOS design does not permit a process // to execute critical code on the secondary core when paging or logout is ongoing. Set the state of current process to READY Call the switch_context() function of the Scheduler Module. /* Scheduler Module requires appropriate modifications before running on the NEXSM machine */ } } while ( tsl (KERN_LOCK) == 1 ){ continue; } return; Called by all system calls, exception handler and timer interrupt handler.","title":"Acquire Kernel Lock"},{"location":"modules/module-08/#acquire-scheduler-lock","text":"Acquires SCHED_LOCK which is an access variable to be set before running the scheduler. This ensures that if one core has set SCHED_LOCK, the other core will not enter the Scheduler module until the first core completes the scheduling action. After completing the scheduling action, the ReleaseLock function is used to release SCHED_LOCK. while ( tsl (SCHED_LOCK) == 1 ){ continue; } return; Called by the Scehduler module.","title":"Acquire Scheduler Lock"},{"location":"modules/module-08/#acquire-glock","text":"Acquires GLOCK which is a general purpose lock variable that is currently left unused. while ( tsl (GLOCK) == 1 ){ continue; } return;","title":"Acquire Glock"},{"location":"modules/module-08/#release-lock","text":"Releases the access lock provided as the argument. Store 0 to the address LockVarAddress. return; Called by all system calls, exception handler, timer interrupt handler and scheduler.","title":"Release Lock"},{"location":"os-design/","text":"Introduction \u00b6 This document specifies the high level system design on eXpOS along with the specification of Data Structures and Algorithms used in eXpOS. Data Structures can be classified into - Memory Data Structures (In-core) and Disk Data Structures. The Disk Data Structures are loaded to memory by the OS startup code and stored back when system terminates. Algorithms specified in this document can fall into any of the five categories - File System Calls, Process System Calls, System Calls related to access control and synchronization, Multiuser System Calls and Hardware Interrupts and Exception Handler. High Level Design \u00b6 System Calls \u00b6 Data Structures \u00b6 Process State Transition Diagram in eXpOS \u00b6 eXpOS Design for NEXSM (Two Core) Machine \u00b6 Access Lock Table \u00b6 Access Control Module \u00b6","title":"Design"},{"location":"os-design/#introduction","text":"This document specifies the high level system design on eXpOS along with the specification of Data Structures and Algorithms used in eXpOS. Data Structures can be classified into - Memory Data Structures (In-core) and Disk Data Structures. The Disk Data Structures are loaded to memory by the OS startup code and stored back when system terminates. Algorithms specified in this document can fall into any of the five categories - File System Calls, Process System Calls, System Calls related to access control and synchronization, Multiuser System Calls and Hardware Interrupts and Exception Handler.","title":"Introduction"},{"location":"os-design/#high-level-design","text":"","title":"High Level Design"},{"location":"os-design/#system-calls","text":"","title":"System Calls"},{"location":"os-design/#data-structures","text":"","title":"Data Structures"},{"location":"os-design/#process-state-transition-diagram-in-expos","text":"","title":"Process State Transition Diagram in eXpOS"},{"location":"os-design/#expos-design-for-nexsm-two-core-machine","text":"","title":"eXpOS Design for NEXSM (Two Core) Machine"},{"location":"os-design/#access-lock-table","text":"","title":"Access Lock Table"},{"location":"os-design/#access-control-module","text":"","title":"Access Control Module"},{"location":"os-design/close/","text":"Arguments: File Descriptor (Integer) Return Value: 0 Success -1 File Descriptor given is invalid Description \u00b6 The Close system call closes an open file. The file descriptor ceases to be valid once the close system call is invoked. Control flow diagram for *Close* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 3, indicating that the process is in the close system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If file descriptor is invalid, return -1. /* File descriptor value should be within the range 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE , return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from Per-Process Resource Table entry. Call the close() function in the File Manager module with the Open File Table index as arguement. Invalidate the Per-Process Resource Table entry. Set the MODE_FLAG in the process table entry to 0. Switch back to the user stack. Return from system call with 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question Why did we not check if the file is locked?","title":"Close"},{"location":"os-design/close/#description","text":"The Close system call closes an open file. The file descriptor ceases to be valid once the close system call is invoked. Control flow diagram for *Close* system call","title":"Description"},{"location":"os-design/close/#algorithm","text":"Set the MODE_FLAG in the process table entry to 3, indicating that the process is in the close system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If file descriptor is invalid, return -1. /* File descriptor value should be within the range 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE , return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from Per-Process Resource Table entry. Call the close() function in the File Manager module with the Open File Table index as arguement. Invalidate the Per-Process Resource Table entry. Set the MODE_FLAG in the process table entry to 0. Switch back to the user stack. Return from system call with 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question Why did we not check if the file is locked?","title":"Algorithm"},{"location":"os-design/create/","text":"Arguments: Filename (String), Permission (0 - exclusive/1 - open-access) Return Value: 0 Success/File already exists -1 No free inode table entry Description \u00b6 The Create operation takes as input a filename. If the file already exists, then the system call returns 0 (success). Otherwise, it creates an empty file by that name, sets the file type to DATA , file size to 0, userid to that of the process (from the process table ) and permission as given in the input in the Inode Table . It also creates a root entry for that file. Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 1, indicating that the process is in the create system call. If the file is present in the system, return 0. /* Check the Inode Table */ Find the index of a free entry in the Inode Table. If no free entry found, return -1. /* Maximum number of files reached */ In the Inode Table entry found above, set FILE NAME to the given file name, FILE SIZE to 0 and FILE TYPE to DATA . In the Inode Table entry, set the block numbers to -1. /* No disk blocks are allocated to the file */ Set the USER ID to the USERID of the process /* See the process table for user id */ Set the PERMISSION to the permission supplied as input. In the Root file entry corresponding to the Inode Table index, set the FILE NAME, FILE SIZE, FILE TYPE, USERNAME and PERMISSION fields. Set the MODE_FLAG in the process table entry to 0. Return from the system call with 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG. Question What would happen if we do not initilize the FILE OPEN COUNT in the File Status Table to -1?","title":"Create"},{"location":"os-design/create/#description","text":"The Create operation takes as input a filename. If the file already exists, then the system call returns 0 (success). Otherwise, it creates an empty file by that name, sets the file type to DATA , file size to 0, userid to that of the process (from the process table ) and permission as given in the input in the Inode Table . It also creates a root entry for that file.","title":"Description"},{"location":"os-design/create/#algorithm","text":"Set the MODE_FLAG in the process table entry to 1, indicating that the process is in the create system call. If the file is present in the system, return 0. /* Check the Inode Table */ Find the index of a free entry in the Inode Table. If no free entry found, return -1. /* Maximum number of files reached */ In the Inode Table entry found above, set FILE NAME to the given file name, FILE SIZE to 0 and FILE TYPE to DATA . In the Inode Table entry, set the block numbers to -1. /* No disk blocks are allocated to the file */ Set the USER ID to the USERID of the process /* See the process table for user id */ Set the PERMISSION to the permission supplied as input. In the Root file entry corresponding to the Inode Table index, set the FILE NAME, FILE SIZE, FILE TYPE, USERNAME and PERMISSION fields. Set the MODE_FLAG in the process table entry to 0. Return from the system call with 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG. Question What would happen if we do not initilize the FILE OPEN COUNT in the File Status Table to -1?","title":"Algorithm"},{"location":"os-design/delete/","text":"Arguments: Filename (String) Return Value: 0 Success/File does not exist -1 Permission denied -2 File is open Description \u00b6 The Delete operation takes as input a filename and deletes it. It returns with an error if any instance of the file is open in the system or if the file is not a DATA file. Delete command fails also if the file to be deleted does not belong to the current user and it has exclusive permissions. Otherwise, it deletes the root entry for the file name, invalidates the Inode Table entry for the file, releases the disk blocks allocated to the file and returns 0. Control flow diagram for *Delete* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 4, indicating that the process is in the delete system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Find the index of the file in the Inode Table . If file is not present in the Inode Table , return 0. If the file is not a DATA file, return -1. If the exclusive permission is set if the current user is not root and the current user does not own the file return -1. Acquire a lock on the file by calling the acquire_inode() function in the Resource Manager module. Check if the the file open count is -1 in the File Status Table . If not, release the lock and return -2. /* File is open, cannot be deleted */ For each disk block allocated to the file, do { /* Check Inode Table */ If the disk block is loaded into a buffer, and the DIRTY BIT is set, reset the dirty bit. /* Check the Buffer Table */ Call the release_block() function in the Memory Manager module to free the disk block. } Invalidate (set to -1) the Inode Table of the file. Update the Root file by invalidating the entry for the file. Release the lock on the file by calling the release_inode() function in the Resource Manager module. Switch back to the user stack by reseting USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return from system call with 0. /* indicating success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question 1 Why are we not updating the Open File Table when a file is being deleted? Question 2 Why can't an open file be deleted? Question 3 Why is the dirty bit in the buffer table cleared before the file is deleted? Question 4 Does disk blocks get freed anywhere else other than the delete system call?","title":"Delete"},{"location":"os-design/delete/#description","text":"The Delete operation takes as input a filename and deletes it. It returns with an error if any instance of the file is open in the system or if the file is not a DATA file. Delete command fails also if the file to be deleted does not belong to the current user and it has exclusive permissions. Otherwise, it deletes the root entry for the file name, invalidates the Inode Table entry for the file, releases the disk blocks allocated to the file and returns 0. Control flow diagram for *Delete* system call","title":"Description"},{"location":"os-design/delete/#algorithm","text":"Set the MODE_FLAG in the process table entry to 4, indicating that the process is in the delete system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Find the index of the file in the Inode Table . If file is not present in the Inode Table , return 0. If the file is not a DATA file, return -1. If the exclusive permission is set if the current user is not root and the current user does not own the file return -1. Acquire a lock on the file by calling the acquire_inode() function in the Resource Manager module. Check if the the file open count is -1 in the File Status Table . If not, release the lock and return -2. /* File is open, cannot be deleted */ For each disk block allocated to the file, do { /* Check Inode Table */ If the disk block is loaded into a buffer, and the DIRTY BIT is set, reset the dirty bit. /* Check the Buffer Table */ Call the release_block() function in the Memory Manager module to free the disk block. } Invalidate (set to -1) the Inode Table of the file. Update the Root file by invalidating the entry for the file. Release the lock on the file by calling the release_inode() function in the Resource Manager module. Switch back to the user stack by reseting USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return from system call with 0. /* indicating success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question 1 Why are we not updating the Open File Table when a file is being deleted? Question 2 Why can't an open file be deleted? Question 3 Why is the dirty bit in the buffer table cleared before the file is deleted? Question 4 Does disk blocks get freed anywhere else other than the delete system call?","title":"Algorithm"},{"location":"os-design/disk-ds/","text":"Inode Table \u00b6 The Inode table is stored in the disk and has an entry for each file present in the disk (A copy of the Inode table is maintained in the memory when the OS is running). It consists of MAX_FILE_NUM entries. Thus eXpFS permits a maximum of MAX_FILE_NUM files. This version of eXpOS sets MAX_FILE_NUM = 60. Each Inode table entry stores the name, size, type and data block numbers of a file stored in the disk ( * In Multiuser extension of eXpOS, userid and permission are also included in the inode table entry). The current version of eXpOS limits the maximum number of blocks in an eXpFS file to MAX_FILE_BLOCKS = 4. Each Inode table entry consists of 16 words of which the 7 are unused in the present version of eXpOS. eXpoS reserves the first entry in the Inode table for the root file . The root file is a special file containing details about other files stored in the system. The entry of an Inode table has the following format: FILE TYPE FILE NAME FILE SIZE USER ID PERMISSION Unused (3 words) DATA BLOCK 1 DATA BLOCK 2 DATA BLOCK 3 DATA BLOCK 4 Unused (4 words) FILE TYPE (1 word) - specifies the type of the given file ( DATA , EXEC or ROOT ). More information about file types is given here . FILE NAME (1 word) - Name of the file FILE SIZE (1 word) - Size of the file. Maximum size for File = MAX_FILE_SIZE = 2048 words USER ID (1 word) - User Id of the owner of the file. PERMISSION (1 word) - Permission of the file; it can be OPEN_ACCESS or EXCLUSIVE . Unused (3 words) DATA BLOCK 1 to 4 (4 words) - each DATA BLOCK column stores the block number of a data block of the file. If a file does not use a particular DATA BLOCK , it is set to -1. Unused (4 words) An unused entry is indicated by -1 in the FILE NAME field. Note 1 fdisk command of XFS Interface initilizes the inode table entry of the root file with values FILE TYPE = 1, FILE SIZE = 512, and DATA BLOCK = 5 (Root file is stored in block 5 of disk. See Disk Organisation ). Note 2 A Free inode entry is denoted by -1 in the FILENAME field. Note 3 Memory copy of the Inode Table is present in page 59 of the memory (see Memory Organisation ), and the SPL constant INODE_TABLE points to the starting address of the table. Importanat Note eXpOS requires that the index of the inode table entry of a file and the index of its root file entry must match. For example, suppose the 5th entry of the inode table holds information about a file, then the entry for the same file in the root must be the 5th entry. XFS interface stores files into the disk following this convention. Disk Free List \u00b6 The Disk Free List consists of DISK_SIZE entries. (The value of DISK_SIZE is fixed to 512 in the present version). Each entry is of size one word and thus, the size of the disk free list is DISK_SIZE = 512 words. For each block in the disk there is an entry in the Disk Free List which contains either 0 (free) or 1 (used). When the system starts up, the OS startup code loads the Disk Free List to memory. It is stored back when the system halts or a Shutdown system call is executed. Note Memory copy of the Disk Free List is present in page 61 of the memory (see Memory Organisation ), and the SPL constant DISK_FREE_LIST points to the starting address of the table. Root File \u00b6 The Root File is stored in the disk and has an entry for each file present in the disk (A copy of the Root File is maintained in the memory when the OS is running). It consists of MAX_FILE_NUM entries. Thus eXpFS permits a maximum of MAX_FILE_NUM files. This version of eXpOS sets MAX_FILE_NUM = 60. The root file has the name root and contains meta-data about the files stored in the file system. For each file stored in eXpFS, the root stores five words of information - file-name, file-size, file-type and username, permission in the case of Multiuser extension of eXpOS. This 5-tuple is called the root entry for the file. The first root entry is for the root itself. Each Root File entry consists of 8 words of which the last 3 are unused in the present version of eXpOS. The entry of Root file has the following format: FILE NAME FILE SIZE FILE TYPE USER NAME PERMISSION Unused FILE NAME (1 word) - Name of the file FILE SIZE (1 word) - Size of the file FILE TYPE (1 word) - Specifies the type of the given file (ROOT indicated by 1 , DATA indicated by 2 or EXEC indicated by 3). USER NAME (1 word) - Name of the owner of the file PERMISSION (1 word) - Permission of the file; open-access (1) or exclusive (0) Unused (3 words) An unused entry is indicated by -1 in the FILE NAME field. Note Memory copy of the Root File is present in page 62 of the memory (see Memory Organisation ), and the SPL constant ROOT_FILE points to the starting address of data structure. Important Note eXpOS requires that the index of the inode table entry of a file and the index of its root file entry must match. For example, suppose the 5th entry of the inode table holds information about a file, then the entry for the same file in the root must be the 5th entry. XFS interface stores files into the disk following this convention. User Table \u00b6 The User table is stored in the disk and has an entry for each user. (A copy of the User table is maintained in the memory when the OS is running). It consists of MAX_USER_NUM entries. This version of eXpOS sets MAX_USER_NUM = 16 including entries for the kernel and the root. Each User table entry stores the user name and encrypted password of a user. Each User table entry consists of 2 words. The entry of an User table has the following format: USER NAME ENCRYPTED PASSWORD USER NAME (1 word) - Name of the user ENCRYPTED PASSWORD (1 word) - Password of the user in an encrypted form. All unused entries are set to -1. The User table entry for two special users - the kernel and root are set at the time of disk formatting. The userid assigned to a user is the index of the curresponding entry in the user table. The userid of kernel is 0 and the root is 1. The inode table entry of a file contains the userid of the owner of the file. The password field for kernel is empty because kernel is a non - loginable user. Important note There must be some mechanism to initialize the root password. In the XSM Machine, if you run the xfs-interface FDISK, the default password of root is set to \"root\" (without quotes). When FDISK is run, the encryped password field of the user root is initialized in the user table. The value corresponds to that obtained by running the ENCRYPT function on the string \"root\". Note Memory copy of the User Table is present in page 60 of the memory (see Memory Organisation ), and the SPL constant USER_TABLE points to the starting address of data structure.","title":"Disk Data Structures"},{"location":"os-design/disk-ds/#inode-table","text":"The Inode table is stored in the disk and has an entry for each file present in the disk (A copy of the Inode table is maintained in the memory when the OS is running). It consists of MAX_FILE_NUM entries. Thus eXpFS permits a maximum of MAX_FILE_NUM files. This version of eXpOS sets MAX_FILE_NUM = 60. Each Inode table entry stores the name, size, type and data block numbers of a file stored in the disk ( * In Multiuser extension of eXpOS, userid and permission are also included in the inode table entry). The current version of eXpOS limits the maximum number of blocks in an eXpFS file to MAX_FILE_BLOCKS = 4. Each Inode table entry consists of 16 words of which the 7 are unused in the present version of eXpOS. eXpoS reserves the first entry in the Inode table for the root file . The root file is a special file containing details about other files stored in the system. The entry of an Inode table has the following format: FILE TYPE FILE NAME FILE SIZE USER ID PERMISSION Unused (3 words) DATA BLOCK 1 DATA BLOCK 2 DATA BLOCK 3 DATA BLOCK 4 Unused (4 words) FILE TYPE (1 word) - specifies the type of the given file ( DATA , EXEC or ROOT ). More information about file types is given here . FILE NAME (1 word) - Name of the file FILE SIZE (1 word) - Size of the file. Maximum size for File = MAX_FILE_SIZE = 2048 words USER ID (1 word) - User Id of the owner of the file. PERMISSION (1 word) - Permission of the file; it can be OPEN_ACCESS or EXCLUSIVE . Unused (3 words) DATA BLOCK 1 to 4 (4 words) - each DATA BLOCK column stores the block number of a data block of the file. If a file does not use a particular DATA BLOCK , it is set to -1. Unused (4 words) An unused entry is indicated by -1 in the FILE NAME field. Note 1 fdisk command of XFS Interface initilizes the inode table entry of the root file with values FILE TYPE = 1, FILE SIZE = 512, and DATA BLOCK = 5 (Root file is stored in block 5 of disk. See Disk Organisation ). Note 2 A Free inode entry is denoted by -1 in the FILENAME field. Note 3 Memory copy of the Inode Table is present in page 59 of the memory (see Memory Organisation ), and the SPL constant INODE_TABLE points to the starting address of the table. Importanat Note eXpOS requires that the index of the inode table entry of a file and the index of its root file entry must match. For example, suppose the 5th entry of the inode table holds information about a file, then the entry for the same file in the root must be the 5th entry. XFS interface stores files into the disk following this convention.","title":"Inode Table"},{"location":"os-design/disk-ds/#disk-free-list","text":"The Disk Free List consists of DISK_SIZE entries. (The value of DISK_SIZE is fixed to 512 in the present version). Each entry is of size one word and thus, the size of the disk free list is DISK_SIZE = 512 words. For each block in the disk there is an entry in the Disk Free List which contains either 0 (free) or 1 (used). When the system starts up, the OS startup code loads the Disk Free List to memory. It is stored back when the system halts or a Shutdown system call is executed. Note Memory copy of the Disk Free List is present in page 61 of the memory (see Memory Organisation ), and the SPL constant DISK_FREE_LIST points to the starting address of the table.","title":"Disk Free List"},{"location":"os-design/disk-ds/#root-file","text":"The Root File is stored in the disk and has an entry for each file present in the disk (A copy of the Root File is maintained in the memory when the OS is running). It consists of MAX_FILE_NUM entries. Thus eXpFS permits a maximum of MAX_FILE_NUM files. This version of eXpOS sets MAX_FILE_NUM = 60. The root file has the name root and contains meta-data about the files stored in the file system. For each file stored in eXpFS, the root stores five words of information - file-name, file-size, file-type and username, permission in the case of Multiuser extension of eXpOS. This 5-tuple is called the root entry for the file. The first root entry is for the root itself. Each Root File entry consists of 8 words of which the last 3 are unused in the present version of eXpOS. The entry of Root file has the following format: FILE NAME FILE SIZE FILE TYPE USER NAME PERMISSION Unused FILE NAME (1 word) - Name of the file FILE SIZE (1 word) - Size of the file FILE TYPE (1 word) - Specifies the type of the given file (ROOT indicated by 1 , DATA indicated by 2 or EXEC indicated by 3). USER NAME (1 word) - Name of the owner of the file PERMISSION (1 word) - Permission of the file; open-access (1) or exclusive (0) Unused (3 words) An unused entry is indicated by -1 in the FILE NAME field. Note Memory copy of the Root File is present in page 62 of the memory (see Memory Organisation ), and the SPL constant ROOT_FILE points to the starting address of data structure. Important Note eXpOS requires that the index of the inode table entry of a file and the index of its root file entry must match. For example, suppose the 5th entry of the inode table holds information about a file, then the entry for the same file in the root must be the 5th entry. XFS interface stores files into the disk following this convention.","title":"Root File"},{"location":"os-design/disk-ds/#user-table","text":"The User table is stored in the disk and has an entry for each user. (A copy of the User table is maintained in the memory when the OS is running). It consists of MAX_USER_NUM entries. This version of eXpOS sets MAX_USER_NUM = 16 including entries for the kernel and the root. Each User table entry stores the user name and encrypted password of a user. Each User table entry consists of 2 words. The entry of an User table has the following format: USER NAME ENCRYPTED PASSWORD USER NAME (1 word) - Name of the user ENCRYPTED PASSWORD (1 word) - Password of the user in an encrypted form. All unused entries are set to -1. The User table entry for two special users - the kernel and root are set at the time of disk formatting. The userid assigned to a user is the index of the curresponding entry in the user table. The userid of kernel is 0 and the root is 1. The inode table entry of a file contains the userid of the owner of the file. The password field for kernel is empty because kernel is a non - loginable user. Important note There must be some mechanism to initialize the root password. In the XSM Machine, if you run the xfs-interface FDISK, the default password of root is set to \"root\" (without quotes). When FDISK is run, the encryped password field of the user root is initialized in the user table. The value corresponds to that obtained by running the ENCRYPT function on the string \"root\". Note Memory copy of the User Table is present in page 60 of the memory (see Memory Organisation ), and the SPL constant USER_TABLE points to the starting address of data structure.","title":"User Table"},{"location":"os-design/disk-interrupt/","text":"Description \u00b6 Hardware sends an interrupt on completion of a load/store operation . This interrupt is handled by the Disk Interrupt Handler. The data structure updated is the Disk Status Table . Algorithm \u00b6 Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction. In the Disk Status Table, set the STATUS field to 0, indicating that the disk is no longer busy. Wake up all processes waiting for the disk. 1. Search the Process table for processes in ( WAIT_DISK , _ ) state. 2. Change the state of the processes to ( READY , _ ). Restore the register context of the process using RESTORE instruction. Restore SP to the value stored in USER SP field of the process table. ireturn;","title":"Disk Interrupt Handler"},{"location":"os-design/disk-interrupt/#description","text":"Hardware sends an interrupt on completion of a load/store operation . This interrupt is handled by the Disk Interrupt Handler. The data structure updated is the Disk Status Table .","title":"Description"},{"location":"os-design/disk-interrupt/#algorithm","text":"Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction. In the Disk Status Table, set the STATUS field to 0, indicating that the disk is no longer busy. Wake up all processes waiting for the disk. 1. Search the Process table for processes in ( WAIT_DISK , _ ) state. 2. Change the state of the processes to ( READY , _ ). Restore the register context of the process using RESTORE instruction. Restore SP to the value stored in USER SP field of the process table. ireturn;","title":"Algorithm"},{"location":"os-design/exe-handler/","text":"Arguments \u00b6 None Return value \u00b6 None Description \u00b6 If a process 1) generates an illegal instruction or an invalid address (outside its virtual address space) 2) do a division by zero 3) tries to write to a page which is read-only, 4) causes other faulty conditions which are machine dependent, the machine will generate an exception. See Exception Handling (Tutorial) . The exception handler must terminate the process and invoke the context switch module to to schedule other processes. The exception handler is also invoked when a page required by a process is not present in the memory. This condition is known as a page fault . The eXpOS scheduler will never schedule a process if its stack page is not present in the memory. Hence, a page fault can occur only when either a) one of the code pages of the process (logical pages 4 to 7) has to be loaded from the disk or b) one of the heap pages has not been allocated (logical page 2 or 3). When a page fault exception occurs, the exception handler routine checks if the page resides in the disk. If it does, it is loaded to the memory and the page table is updated. Otherwise, a new page is allocated to the process by the exception handler. The data structures updated are Disk Status Table , System Status Table , Memory Free List and Page Table . The MODE FLAG must be set upon entering the system call and reset before returning. Control flow diagram for *Exception handler* Algorithm \u00b6 Set the MODE_FLAG in the process table entry to -1 indicate that the process is in the execption handler. Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction and push EIP onto the kernel stack. If (the exception is not caused by a page fault or user stack is full) /* Check the Exception Cause registers */ Display the cause of the exception. Terminate the process using exit_process() module function in the Process Manager module. Invoke the scheduler by calling the switch_context() function in the Scheduler Module . /* Exception is due to page fault */ Using the Exception registers, find the page number of the page causing the exception. If (page corresponds to a code page) Get the disk block number to load from the Disk Map Table entry of the process. Load the page to memory by calling the get_code_page() function in the Memory Manager Module. In the page table entry, set the Page Number field to the page number returned by get_code_page() Set the referenced and valid bits to 1. Also set the write bit to 0. /* Code pages are not writable */ else if (page corresponds to a heap page) Allocate 2 new memory pages by calling the get_free_page() function in the Memory Manager module. In the page table entry, set the Page Number field to the pages allocated above and auxiliary information to referenced and valid. Also set the write bit to 1. /* Heap is writable */ Pop EIP from the kernel stack and restore the register context of the process using RESTORE instruction. Reset the MODE_FLAG back to 0. Restore SP to the USER SP stored in the process table. Increment SP and store EIP onto the location pointed to by SP. ireturn.","title":"Exception Handler"},{"location":"os-design/exe-handler/#arguments","text":"None","title":"Arguments"},{"location":"os-design/exe-handler/#return-value","text":"None","title":"Return value"},{"location":"os-design/exe-handler/#description","text":"If a process 1) generates an illegal instruction or an invalid address (outside its virtual address space) 2) do a division by zero 3) tries to write to a page which is read-only, 4) causes other faulty conditions which are machine dependent, the machine will generate an exception. See Exception Handling (Tutorial) . The exception handler must terminate the process and invoke the context switch module to to schedule other processes. The exception handler is also invoked when a page required by a process is not present in the memory. This condition is known as a page fault . The eXpOS scheduler will never schedule a process if its stack page is not present in the memory. Hence, a page fault can occur only when either a) one of the code pages of the process (logical pages 4 to 7) has to be loaded from the disk or b) one of the heap pages has not been allocated (logical page 2 or 3). When a page fault exception occurs, the exception handler routine checks if the page resides in the disk. If it does, it is loaded to the memory and the page table is updated. Otherwise, a new page is allocated to the process by the exception handler. The data structures updated are Disk Status Table , System Status Table , Memory Free List and Page Table . The MODE FLAG must be set upon entering the system call and reset before returning. Control flow diagram for *Exception handler*","title":"Description"},{"location":"os-design/exe-handler/#algorithm","text":"Set the MODE_FLAG in the process table entry to -1 indicate that the process is in the execption handler. Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction and push EIP onto the kernel stack. If (the exception is not caused by a page fault or user stack is full) /* Check the Exception Cause registers */ Display the cause of the exception. Terminate the process using exit_process() module function in the Process Manager module. Invoke the scheduler by calling the switch_context() function in the Scheduler Module . /* Exception is due to page fault */ Using the Exception registers, find the page number of the page causing the exception. If (page corresponds to a code page) Get the disk block number to load from the Disk Map Table entry of the process. Load the page to memory by calling the get_code_page() function in the Memory Manager Module. In the page table entry, set the Page Number field to the page number returned by get_code_page() Set the referenced and valid bits to 1. Also set the write bit to 0. /* Code pages are not writable */ else if (page corresponds to a heap page) Allocate 2 new memory pages by calling the get_free_page() function in the Memory Manager module. In the page table entry, set the Page Number field to the pages allocated above and auxiliary information to referenced and valid. Also set the write bit to 1. /* Heap is writable */ Pop EIP from the kernel stack and restore the register context of the process using RESTORE instruction. Reset the MODE_FLAG back to 0. Restore SP to the USER SP stored in the process table. Increment SP and store EIP onto the location pointed to by SP. ireturn.","title":"Algorithm"},{"location":"os-design/exec/","text":"Arguments \u00b6 File Name (String) of the executable file (which must be of XEXE format ) Return Value \u00b6 -1 File not found or file is of invalid type Description \u00b6 Exec destroys the present process and loads the executable file given as input into a new memory address space. A successful Exec operation results in the extinction of the invoking process and hence never returns to it. All open instances of file and semaphores of the parent process are closed. However, the newly created process will inherit the PID of the calling process. The data structures that are modified in this system call are Process Table , Memory Free List , Disk Free List , Open File Table , Semaphore Table , System Status Table , Resource Table and the Disk Map Table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Control flow diagram for *Exec* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 9 indicate that the process is in exec system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. /* Check for the file entry in Inode Table . */ If filename is invalid, return -1. If file not found in system or file type is not EXEC, return -1 Call the exit_process() function in the Process Manager Module to deallocate resources of the current process. Reacquire the same User Area Page of the old process manually by incrementing the Mem Free List and decrementing MEM_FREE_COUNT in the System Status Table . /* exit_process() in the previous step deallocated the user area page, and hence we immediately reclaim the page for loading the new program. Since the page storing the kernel context has been de-allocated, it is unsafe to invoke the memory manager module for allocating a fresh user area page (why?) */ Set SP to User Area Page Number * 512 - 1 /* Start fresh in the new kernel stack */ Initilize the Per-process Resource Table by setting all entries to -1. In the Process Table entry of the current process, set the Inode Index field to the index of Inode Table entry for the file and set the state as RUNNING. Acquire two memory pages for user stack by invoking the get_free_page() function in the memory manager module. Obtain the disk block number of the first code page from the inode entry of the file passed as argument. Load the first code page into memory by invoking the get_code_page() function in the Memory Manager module . Set the Page Table and Disk Map Table entries of the process. Set the Page Table entries for library. Set the valid bit to 1 and write bit to 0. /* Since the ExpL compler uses the library for even basic operations like read/write, the library flag is ignored, and we link the library to all loaded programs */ Invalidate the page table entries for heap. /* Memory will be allocated when page fault occurs */ Set the page table entry for the first code page to the page loaded eariler. Set it's valid bit to 1 and write bit to 0. Other code pages are set to invalid and unreferenced. Set the page table entry for the stack page to the pages found earlier. Set the valid bit and write bit to 1. Set the code pages in the Disk Map Table to the Block numbers by refering to the Inode Table . Other fields are set to -1. Obtain the entry point IP value from the header of the new process and set it to the beginning of user stack(logical address 4096). Set SP to the logical address of the user stack. Set the MODE_FLAG in the process table entry to back to 0. ireturn from system call to newly loaded process. Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Exec"},{"location":"os-design/exec/#arguments","text":"File Name (String) of the executable file (which must be of XEXE format )","title":"Arguments"},{"location":"os-design/exec/#return-value","text":"-1 File not found or file is of invalid type","title":"Return Value"},{"location":"os-design/exec/#description","text":"Exec destroys the present process and loads the executable file given as input into a new memory address space. A successful Exec operation results in the extinction of the invoking process and hence never returns to it. All open instances of file and semaphores of the parent process are closed. However, the newly created process will inherit the PID of the calling process. The data structures that are modified in this system call are Process Table , Memory Free List , Disk Free List , Open File Table , Semaphore Table , System Status Table , Resource Table and the Disk Map Table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Control flow diagram for *Exec* system call","title":"Description"},{"location":"os-design/exec/#algorithm","text":"Set the MODE_FLAG in the process table entry to 9 indicate that the process is in exec system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. /* Check for the file entry in Inode Table . */ If filename is invalid, return -1. If file not found in system or file type is not EXEC, return -1 Call the exit_process() function in the Process Manager Module to deallocate resources of the current process. Reacquire the same User Area Page of the old process manually by incrementing the Mem Free List and decrementing MEM_FREE_COUNT in the System Status Table . /* exit_process() in the previous step deallocated the user area page, and hence we immediately reclaim the page for loading the new program. Since the page storing the kernel context has been de-allocated, it is unsafe to invoke the memory manager module for allocating a fresh user area page (why?) */ Set SP to User Area Page Number * 512 - 1 /* Start fresh in the new kernel stack */ Initilize the Per-process Resource Table by setting all entries to -1. In the Process Table entry of the current process, set the Inode Index field to the index of Inode Table entry for the file and set the state as RUNNING. Acquire two memory pages for user stack by invoking the get_free_page() function in the memory manager module. Obtain the disk block number of the first code page from the inode entry of the file passed as argument. Load the first code page into memory by invoking the get_code_page() function in the Memory Manager module . Set the Page Table and Disk Map Table entries of the process. Set the Page Table entries for library. Set the valid bit to 1 and write bit to 0. /* Since the ExpL compler uses the library for even basic operations like read/write, the library flag is ignored, and we link the library to all loaded programs */ Invalidate the page table entries for heap. /* Memory will be allocated when page fault occurs */ Set the page table entry for the first code page to the page loaded eariler. Set it's valid bit to 1 and write bit to 0. Other code pages are set to invalid and unreferenced. Set the page table entry for the stack page to the pages found earlier. Set the valid bit and write bit to 1. Set the code pages in the Disk Map Table to the Block numbers by refering to the Inode Table . Other fields are set to -1. Obtain the entry point IP value from the header of the new process and set it to the beginning of user stack(logical address 4096). Set SP to the logical address of the user stack. Set the MODE_FLAG in the process table entry to back to 0. ireturn from system call to newly loaded process. Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/exit/","text":"Arguments \u00b6 None Return Value \u00b6 None Description \u00b6 Exit system call terminates the execution of the process which invoked it and destroys its memory address space. The calling application ceases to exist after the system call and hence the system call never returns. Data structures modified are Memory Free List , Disk Free List , Open File Table , Semaphore Table , System Status Table , Resource Table and the Disk Map Table . Control flow diagram for Exit system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 10. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Invoke the exit_process() function from the Process Manager module. /* exit_process() releases all the memory pages of the process including the page holding kernel stack. Still, as exit_process is non-blocking, the kernel stack page will not be allocated to another process. This makes it possible to make a final call from the process to the scheduler. There is no return to the process after the following scheduler invocation. */ Invoke the context_switch() function in the Scheduler Module .","title":"Exit"},{"location":"os-design/exit/#arguments","text":"None","title":"Arguments"},{"location":"os-design/exit/#return-value","text":"None","title":"Return Value"},{"location":"os-design/exit/#description","text":"Exit system call terminates the execution of the process which invoked it and destroys its memory address space. The calling application ceases to exist after the system call and hence the system call never returns. Data structures modified are Memory Free List , Disk Free List , Open File Table , Semaphore Table , System Status Table , Resource Table and the Disk Map Table . Control flow diagram for Exit system call","title":"Description"},{"location":"os-design/exit/#algorithm","text":"Set the MODE_FLAG in the process table entry to 10. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Invoke the exit_process() function from the Process Manager module. /* exit_process() releases all the memory pages of the process including the page holding kernel stack. Still, as exit_process is non-blocking, the kernel stack page will not be allocated to another process. This makes it possible to make a final call from the process to the scheduler. There is no return to the process after the following scheduler invocation. */ Invoke the context_switch() function in the Scheduler Module .","title":"Algorithm"},{"location":"os-design/fork/","text":"Arguments \u00b6 None Return Values \u00b6 Value Explanation PID (Integer) Success, the return value to the parent is the process descriptor(PID) of the child process. 0 Success, the return value to the child . -1 Failure, Number of processes has reached the maximum limit. Returns to the parent Description \u00b6 Replicates the process invoking the system call. The heap, code and library regions of the parent are shared by the child. A new stack is allocated to the child and the parent's stack is copied into the child's stack. When a process executes the Fork system call, the child process shares with the parent all the file and semaphore descriptors previously acquired by the parent. Semaphore/file descriptors acquired subsequent to the fork operation by either the child or the parent will be exclusive to the respective process and will not be shared. Data Structures modified are Process Table , System Status Table , Open File Table , Semaphore Table , Memory Free List , Disk Free List (in case of swapped pages), Resource Table and the Disk Map Table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Control flow diagram for *Fork* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 8, indicating that the process is in the fork system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. //Allocate memory and set the Process Table Find a free Process Table entry by invoking the get_pcb_entry() function in Process Manager module. If no free entry is found, return -1. /* The parent and the child must share the heap. Hence, if heap pages were not allocated for the parent so far, allocate it now. */ If heap pages are not allocated for the parent process, then allocate 2 heap pages for the parent using the get_free_page() function in Memory Manager module and set the page table entries for the heap pages of the parent. Invoke the get_free_page() function in Memory Manager module to obtain 3 memory pages: 2 for user stack and 1 for User Area Page of the child process. Copy the parent's Process Table Entry except TICK, PID, PPID, USER AREA PAGE NUMBER, KERNEL STACK POINTER, INPUT BUFFER, PTBR and PTLR to the child. Set the PPID field of child process to the current PID. Also set User Area Page Number to the new UA Page, MODE, TICK and Kernel Stack Pointer to 0. /* Kernel Context of the child process is empty */ /* PID, PTBR, PTLR fields of the child's process table is initilized by the get_pcb_entry function.*/ Copy the per-process resource table and per-process disk map table . For every open file of the parent, increment the Open Instance Count in the Open File Table . For every semaphore acquired by the parent, increment Process Count in the Semaphore Table . /* The child shares open files and acquired semaphores with the parent */ //Set Page Tables Copy the page table entries (code, heap and library) from the parent's page table to the child /* Shared between parent and child */ /* Code and Library Pages must be shared read only */ For each page shared, increment its value in the Memory Free List Set the page table entries for stack to the pages acquired earlier. Copy word by word the contents of the parent user stack to that of the child. Store the current BP value to the begining of the kernel stack. /* According to the ExpL calling convention, the BP register is not saved in the user stack. This value is saved here so that the context switch module can restore it when the child is run. */ Set the return value to 0 for the child process The PID of the child process is set as the return value for the parent process Set state of child process to (CREATED, _ ). Set the MODE_FLAG in the process table entry of the parent process to 0. Restore SP to User SP and return to the parent process. Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Fork"},{"location":"os-design/fork/#arguments","text":"None","title":"Arguments"},{"location":"os-design/fork/#return-values","text":"Value Explanation PID (Integer) Success, the return value to the parent is the process descriptor(PID) of the child process. 0 Success, the return value to the child . -1 Failure, Number of processes has reached the maximum limit. Returns to the parent","title":"Return Values"},{"location":"os-design/fork/#description","text":"Replicates the process invoking the system call. The heap, code and library regions of the parent are shared by the child. A new stack is allocated to the child and the parent's stack is copied into the child's stack. When a process executes the Fork system call, the child process shares with the parent all the file and semaphore descriptors previously acquired by the parent. Semaphore/file descriptors acquired subsequent to the fork operation by either the child or the parent will be exclusive to the respective process and will not be shared. Data Structures modified are Process Table , System Status Table , Open File Table , Semaphore Table , Memory Free List , Disk Free List (in case of swapped pages), Resource Table and the Disk Map Table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Control flow diagram for *Fork* system call","title":"Description"},{"location":"os-design/fork/#algorithm","text":"Set the MODE_FLAG in the process table entry to 8, indicating that the process is in the fork system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. //Allocate memory and set the Process Table Find a free Process Table entry by invoking the get_pcb_entry() function in Process Manager module. If no free entry is found, return -1. /* The parent and the child must share the heap. Hence, if heap pages were not allocated for the parent so far, allocate it now. */ If heap pages are not allocated for the parent process, then allocate 2 heap pages for the parent using the get_free_page() function in Memory Manager module and set the page table entries for the heap pages of the parent. Invoke the get_free_page() function in Memory Manager module to obtain 3 memory pages: 2 for user stack and 1 for User Area Page of the child process. Copy the parent's Process Table Entry except TICK, PID, PPID, USER AREA PAGE NUMBER, KERNEL STACK POINTER, INPUT BUFFER, PTBR and PTLR to the child. Set the PPID field of child process to the current PID. Also set User Area Page Number to the new UA Page, MODE, TICK and Kernel Stack Pointer to 0. /* Kernel Context of the child process is empty */ /* PID, PTBR, PTLR fields of the child's process table is initilized by the get_pcb_entry function.*/ Copy the per-process resource table and per-process disk map table . For every open file of the parent, increment the Open Instance Count in the Open File Table . For every semaphore acquired by the parent, increment Process Count in the Semaphore Table . /* The child shares open files and acquired semaphores with the parent */ //Set Page Tables Copy the page table entries (code, heap and library) from the parent's page table to the child /* Shared between parent and child */ /* Code and Library Pages must be shared read only */ For each page shared, increment its value in the Memory Free List Set the page table entries for stack to the pages acquired earlier. Copy word by word the contents of the parent user stack to that of the child. Store the current BP value to the begining of the kernel stack. /* According to the ExpL calling convention, the BP register is not saved in the user stack. This value is saved here so that the context switch module can restore it when the child is run. */ Set the return value to 0 for the child process The PID of the child process is set as the return value for the parent process Set state of child process to (CREATED, _ ). Set the MODE_FLAG in the process table entry of the parent process to 0. Restore SP to User SP and return to the parent process. Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/mem-ds/","text":"Open File Table \u00b6 The Open File Table stores the information about all the files that are open while the OS is running. It consists of MAX_OPENFILE_NUM (= 32 in the present eXpOS version) entries. Thus, there can be at most MAX_OPENFILE_NUM = 32 open files in the system at any time. The Open system call creates an entry in the Open file table when a process opens a file. If the file is opened again by some other process (or the same process), the Open system call a new entry is created in the open file table. The first field (Inode Index) of the Open file table entry for a file is set to the index of the Inode Table entry for the file. Each entry is of size 4 words of which last word is left unused. Every entry of the Open File Table has the following format : INODE INDEX OPEN INSTANCE COUNT LSEEK Unused INODE INDEX (1 word) - specifies the index of the entry for the file in the Inode table. The special constant INODE_ROOT is stored in the case of the \"root\" file. OPEN INSTANCE COUNT (1 word) - specifies the number of processes sharing the open instance of the file represented by this open file table entry. LSEEK (1 word) - specifies the position from which the next word is read from or written into in the file. Unused (1 word) All invalid entries are set to -1. An Unused entry is indicated by value of -1 in the INODE INDEX field. Note The Open File Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant OPEN_FILE_TABLE points to the starting address of the table. File (Inode) Status Table \u00b6 The File Status Table contains details about lock status and file open count of each file in the inode table. It consists of MAX_FILE_NUM (= 60 in the present eXpOS version) entries. For each file, the index of its entry in the inode table must match with the index of its entry in the file status table . Each file lock status table entry is of size 4 words of which two are unused. LOCKING PID FILE OPEN COUNT Unused LOCK (1 word)- If the file is locked by a process inside a system call, this field specifies the PID of the process, otherwise, it is set to -1. FILE OPEN COUNT (1 word) - specifies the number of open instances of the file. This field is set to -1 if there are no open instances of the file in the system. Unused (2 words) All invalid entries are set to -1 Note The File Status Table is present in page 57 of the memory (see Memory Organisation ), and the SPL constant FILE_STATUS_TABLE points to the starting address of the table. Semaphore Table \u00b6 The Semaphore Table contains details about the semaphores used by all the processes. It consists of MAX_SEM_COUNT (= 32 in the present eXpOS version) entries. Thus, there can be at most MAX_SEM_COUNT = 32 semaphores used in the system at any time. For every semaphore entry in the per-process resource table, there is a corresponding entry in the semaphore table. A process can acquire a semaphore using the Semget system call, which returns a unique semid for the semaphore. Semid is basically the index of the semaphore table entry for the semaphore. The Process count field specifies the number of processes which are sharing the semaphore. Semget sets the Process Count to 1. When a process forks, all semaphores acquired by the parent is shared with the child and hence, Process Count is incremented. Semrelease system call decrements the Process Count. Process Count is also decremented when a process exits. SemLock system call sets the Locking PID field to the PID of the process invoking it. When the semaphore is not locked, Locking PID is -1. Each semaphore table entry is of size 4 words of which the last two are unused. LOCKING PID PROCESS COUNT Unused LOCKING PID (1 word)- specifies the PID of the process which has locked the semaphore. The entry is set to -1 if the semaphore is not locked by any processes. PROCESS COUNT (1 word) - specifies the number of processes which are sharing the semaphore. A value of 0 indicates that the semaphore has not been acquired by any process. Unused (2 words) An unused entry is indicated by 0 in the PROCESS COUNT field. Note The Semaphore Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant SEMAPHORE_TABLE points to the starting address of the table. Disk Status Table \u00b6 It is assumed that the machine provides a load instruction to transfer a disk block to a memory page and a store instruction to transfer a memory page to a disk block. The Disk Status Table keeps track of these disk-memory transfers. Every time a disk operation is invoked, the information regarding the operation like the disk block and the memory page involved, the process that invoked the operation and type of disk operation are stored in Disk Status Table by the OS. In the present version of eXpOS, it is assumed that, the disk does not support multiple disk-memory transfers at the same time and is considered busy while a transfer is going on. The state of the disk (busy or free) is also stored in the Disk Status Table. The size of the table is 8 words of which the last 2 are unused. STATUS LOAD/STORE BIT PAGE NUMBER BLOCK NUMBER PID Unused STATUS (1 word) - specifies whether the disk is free (indicated by 0) or busy (indicated by 1) handling a memory-disk transfer. LOAD/STORE BIT (1 word) - specifies whether the operation being done on the device is a load (indicated by 0) or store (indicated by 1). PAGE NUMBER (1 word) - specifies the memory page number involved in the disk transfer. BLOCK NUMBER (1 word) - specifies the disk block number involved in the disk transfer. PID (1 word) - specifies the PID of the process which invoked the disk transfer. If the disk transfer was initiated by the OS during paging/swapping, the field is set to PID of idle process , which is 0. Unused (2 words) Note The Disk Staus Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant DISK_STATUS_TABLE points to the starting address of the table. Buffer Table \u00b6 When a process reads/writes into a file, the relevant disk block is first brought into a memory buffer by the OS and the read/write operation is performed on the buffer. The OS reserves MAX_BUFFER number of memory pages as buffers. The buffer table is a data structure that stores the information regarding the disk block stored in each buffer. The present version of eXpOS sets MAX_BUFFER = 4. Each buffer is identified by its index in the buffer table. Since all the 4 buffer pages are shared by all the files in the file system, a buffer page may be required to be replaced by another disk block. In this case, write-back is performed only if the page is modified. The dirty bit indicates whether the page has been modified. When a disk block is required to be brought into the buffer, the buffer to which it must be loaded is identifed by the formula : Buffer_number = Disk_block_number % MAX_BUFFER Each entry of the Buffer Table has the following format: BLOCK NUMBER DIRTY BIT LOCKING PID Unused BLOCK NUMBER (1 word) - specifies block number of the disk block which is currently stored in the buffer. It is set to -1 if the buffer does not contain any valid disk block. DIRTY BIT (1 word) - specifies whether the block stored in the buffer has been modified. It is set to 0 when a disk block is loaded into the buffer and is set to 1 when modified by the Write System Call. LOCKING PID (1 word) - specifies the PID of the process which has currently locked the buffer table while executing a file system call. Unused (1 word) Free entries are represented by -1 in all the fields. Note The Buffer Table is present in page 58 of the memory (see Memory Organisation ), and the SPL constant BUFFER_TABLE points to the starting address of the table. System Status Table \u00b6 It keeps the information about the number of free pages in memory, the number of processes blocked because memory is unavailable, the number of processes in swapped state and, the pid of the process to be scheduled next. The size of the table is 8 words out of which 2 words are unused. The System Status Table has the following format: CURRENT_USER_ID CURRENT_PID MEM_FREE_COUNT WAIT_MEM_COUNT SWAPPED_COUNT PAGING_STATUS CURRENT_PID2 LOGOUT_STATUS CURRENT_USER_ID (1 word) - specifies the userid of the currently logged in user. CURRENT_PID (1 word) - specifies the pid of the currently running process. MEM_FREE_COUNT (1 word) - specifies the number of free pages available in memory. WAIT_MEM_COUNT (1 word) - specifies the number of processes waiting (blocked) for memory. SWAPPED_COUNT (1 word) - specifies the number of processes which are swapped. A process is said to be swapped if any of its user stack pages or its kernel stack page is swapped out. PAGING_STATUS (1 word) - specifies whether swapping is initiated. Swap Out/Swap In are indicated by 0 and 1, respectively. Set to 0 if paging is not in progress. CURRENT_PID2 (1 word) - specifies the pid of the currently running process on the secondary core. This field is used only when eXpOS is running on NEXSM (a two-core extension of XSM) machine. *LOGOUT_STATUS (1 word) - specifies whether logout is initiated on the primary core. Set to 0 if logout is not initiated. This field is used only when eXpOS is running on NEXSM (a two-core extension of XSM) machine. Initially, when the table is set up by the OS startup code, the MEM_FREE_COUNT is initialized to the number of free pages available in the system, WAIT_MEM_COUNT to 0, SWAPPED_COUNT to 0 and PAGING_STATUS to 0. Note The System Status Table is present in page 57 of the memory (see Memory Organisation ), and the SPL constant SYSTEM_STATUS_TABLE points to the starting address of the table. Terminal Status Table \u00b6 The Terminal Status Table keeps track of the Read/Write operations done on the terminal. Every time a Read or Write system call is invoked on the terminal, the PID of the process that invoked the system call is stored in Terminal Status Table. The table also contains information on the status of the terminal (whether free or busy). The size of the table is 4 words of which the last 2 are unused. Every entry of the Terminal Status Table has the following format: STATUS PID Unused STATUS (1 word) - specifies whether the terminal is free or is being used by a process to read or write. This field is initially set to 0. It is changed to 1 whenever terminal is busy. The Terminal Interrupt Handler sets back the status to 0 upon completion of Terminal Read. The Write system call sets back the status to 0 upon completion of Terminal Write. PID (1 word) - specifies the PID of the process which is currently using the terminal. This field is invalid when STATUS is 0. Unused (2 words) Note The Terminal Table is present in page 57 of the memory (see Memory Organisation ), and the SPL constant TERMINAL_STATUS_TABLE points to the starting address of the table. Memory Free List \u00b6 The Memory free list is a data structure used for keeping track of used and unused pages in the memory. It consists of MAX_MEM_PAGE entries and each entry is of size one word. Thus, the total size of the free list is MAX_MEM_PAGE words. The number of memory pages available to the OS is architecture dependent. For the version of XSM discussed here, MAX_MEM_PAGE = 128. Each entry of the free list contains either the value 0 indicating that the corresponding page in the memory is free (not allocated to any process) or contains the number of processes that are sharing the page. Memory free list entries for the pages allocated to the kernel are also set to 1. Note Memory copy of the Mem Free List is present in page 57 of the memory (see Memory Organisation ), and the SPL constant MEMORY_FREE_LIST points to the starting address of the data structure. Access Lock Table \u00b6 When eXpOS runs on a two-core machine like NEXSM , the OS kernel code executes parallelly on the cores. Hence, to ensure atomicity of the resource acquire functions (of the resource manager module), as well as access/updates of OS data structures, an additional layer of access locking is introduced. The OS maintains an Access Lock Table in memory with the following fields to hold the additional locks. The Access Lock Table has the following format: KERN_LOCK SCHED_LOCK GLOCK Unused KERN_LOCK (1 word) - Common access lock to be set before running any critical kernel code other than scheduling. Before performing any kernel function, this lock must be set by the kernel module/interrupt handler so that the other core waits till the critical action is completed. SCHED_LOCK (1 word) - Access lock to run the Scheduler Module. if one core has set the SCHEDULE_LOCK, then upon entering the Scheduler Module, the other core executes a busy loop until execution of the Scheduler Module on the first core is completed. GLOCK (1 word) - A general purpose lock variable that is left unused for future use. Unused (5 words) Note This data structure is used only when eXpOS is running on NEXSM (a two-core extension of XSM) machine.","title":"Memory Data Structures"},{"location":"os-design/mem-ds/#open-file-table","text":"The Open File Table stores the information about all the files that are open while the OS is running. It consists of MAX_OPENFILE_NUM (= 32 in the present eXpOS version) entries. Thus, there can be at most MAX_OPENFILE_NUM = 32 open files in the system at any time. The Open system call creates an entry in the Open file table when a process opens a file. If the file is opened again by some other process (or the same process), the Open system call a new entry is created in the open file table. The first field (Inode Index) of the Open file table entry for a file is set to the index of the Inode Table entry for the file. Each entry is of size 4 words of which last word is left unused. Every entry of the Open File Table has the following format : INODE INDEX OPEN INSTANCE COUNT LSEEK Unused INODE INDEX (1 word) - specifies the index of the entry for the file in the Inode table. The special constant INODE_ROOT is stored in the case of the \"root\" file. OPEN INSTANCE COUNT (1 word) - specifies the number of processes sharing the open instance of the file represented by this open file table entry. LSEEK (1 word) - specifies the position from which the next word is read from or written into in the file. Unused (1 word) All invalid entries are set to -1. An Unused entry is indicated by value of -1 in the INODE INDEX field. Note The Open File Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant OPEN_FILE_TABLE points to the starting address of the table.","title":"Open File Table"},{"location":"os-design/mem-ds/#file-inode-status-table","text":"The File Status Table contains details about lock status and file open count of each file in the inode table. It consists of MAX_FILE_NUM (= 60 in the present eXpOS version) entries. For each file, the index of its entry in the inode table must match with the index of its entry in the file status table . Each file lock status table entry is of size 4 words of which two are unused. LOCKING PID FILE OPEN COUNT Unused LOCK (1 word)- If the file is locked by a process inside a system call, this field specifies the PID of the process, otherwise, it is set to -1. FILE OPEN COUNT (1 word) - specifies the number of open instances of the file. This field is set to -1 if there are no open instances of the file in the system. Unused (2 words) All invalid entries are set to -1 Note The File Status Table is present in page 57 of the memory (see Memory Organisation ), and the SPL constant FILE_STATUS_TABLE points to the starting address of the table.","title":"File (Inode) Status Table"},{"location":"os-design/mem-ds/#semaphore-table","text":"The Semaphore Table contains details about the semaphores used by all the processes. It consists of MAX_SEM_COUNT (= 32 in the present eXpOS version) entries. Thus, there can be at most MAX_SEM_COUNT = 32 semaphores used in the system at any time. For every semaphore entry in the per-process resource table, there is a corresponding entry in the semaphore table. A process can acquire a semaphore using the Semget system call, which returns a unique semid for the semaphore. Semid is basically the index of the semaphore table entry for the semaphore. The Process count field specifies the number of processes which are sharing the semaphore. Semget sets the Process Count to 1. When a process forks, all semaphores acquired by the parent is shared with the child and hence, Process Count is incremented. Semrelease system call decrements the Process Count. Process Count is also decremented when a process exits. SemLock system call sets the Locking PID field to the PID of the process invoking it. When the semaphore is not locked, Locking PID is -1. Each semaphore table entry is of size 4 words of which the last two are unused. LOCKING PID PROCESS COUNT Unused LOCKING PID (1 word)- specifies the PID of the process which has locked the semaphore. The entry is set to -1 if the semaphore is not locked by any processes. PROCESS COUNT (1 word) - specifies the number of processes which are sharing the semaphore. A value of 0 indicates that the semaphore has not been acquired by any process. Unused (2 words) An unused entry is indicated by 0 in the PROCESS COUNT field. Note The Semaphore Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant SEMAPHORE_TABLE points to the starting address of the table.","title":"Semaphore Table"},{"location":"os-design/mem-ds/#disk-status-table","text":"It is assumed that the machine provides a load instruction to transfer a disk block to a memory page and a store instruction to transfer a memory page to a disk block. The Disk Status Table keeps track of these disk-memory transfers. Every time a disk operation is invoked, the information regarding the operation like the disk block and the memory page involved, the process that invoked the operation and type of disk operation are stored in Disk Status Table by the OS. In the present version of eXpOS, it is assumed that, the disk does not support multiple disk-memory transfers at the same time and is considered busy while a transfer is going on. The state of the disk (busy or free) is also stored in the Disk Status Table. The size of the table is 8 words of which the last 2 are unused. STATUS LOAD/STORE BIT PAGE NUMBER BLOCK NUMBER PID Unused STATUS (1 word) - specifies whether the disk is free (indicated by 0) or busy (indicated by 1) handling a memory-disk transfer. LOAD/STORE BIT (1 word) - specifies whether the operation being done on the device is a load (indicated by 0) or store (indicated by 1). PAGE NUMBER (1 word) - specifies the memory page number involved in the disk transfer. BLOCK NUMBER (1 word) - specifies the disk block number involved in the disk transfer. PID (1 word) - specifies the PID of the process which invoked the disk transfer. If the disk transfer was initiated by the OS during paging/swapping, the field is set to PID of idle process , which is 0. Unused (2 words) Note The Disk Staus Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant DISK_STATUS_TABLE points to the starting address of the table.","title":"Disk Status Table"},{"location":"os-design/mem-ds/#buffer-table","text":"When a process reads/writes into a file, the relevant disk block is first brought into a memory buffer by the OS and the read/write operation is performed on the buffer. The OS reserves MAX_BUFFER number of memory pages as buffers. The buffer table is a data structure that stores the information regarding the disk block stored in each buffer. The present version of eXpOS sets MAX_BUFFER = 4. Each buffer is identified by its index in the buffer table. Since all the 4 buffer pages are shared by all the files in the file system, a buffer page may be required to be replaced by another disk block. In this case, write-back is performed only if the page is modified. The dirty bit indicates whether the page has been modified. When a disk block is required to be brought into the buffer, the buffer to which it must be loaded is identifed by the formula : Buffer_number = Disk_block_number % MAX_BUFFER Each entry of the Buffer Table has the following format: BLOCK NUMBER DIRTY BIT LOCKING PID Unused BLOCK NUMBER (1 word) - specifies block number of the disk block which is currently stored in the buffer. It is set to -1 if the buffer does not contain any valid disk block. DIRTY BIT (1 word) - specifies whether the block stored in the buffer has been modified. It is set to 0 when a disk block is loaded into the buffer and is set to 1 when modified by the Write System Call. LOCKING PID (1 word) - specifies the PID of the process which has currently locked the buffer table while executing a file system call. Unused (1 word) Free entries are represented by -1 in all the fields. Note The Buffer Table is present in page 58 of the memory (see Memory Organisation ), and the SPL constant BUFFER_TABLE points to the starting address of the table.","title":"Buffer Table"},{"location":"os-design/mem-ds/#system-status-table","text":"It keeps the information about the number of free pages in memory, the number of processes blocked because memory is unavailable, the number of processes in swapped state and, the pid of the process to be scheduled next. The size of the table is 8 words out of which 2 words are unused. The System Status Table has the following format: CURRENT_USER_ID CURRENT_PID MEM_FREE_COUNT WAIT_MEM_COUNT SWAPPED_COUNT PAGING_STATUS CURRENT_PID2 LOGOUT_STATUS CURRENT_USER_ID (1 word) - specifies the userid of the currently logged in user. CURRENT_PID (1 word) - specifies the pid of the currently running process. MEM_FREE_COUNT (1 word) - specifies the number of free pages available in memory. WAIT_MEM_COUNT (1 word) - specifies the number of processes waiting (blocked) for memory. SWAPPED_COUNT (1 word) - specifies the number of processes which are swapped. A process is said to be swapped if any of its user stack pages or its kernel stack page is swapped out. PAGING_STATUS (1 word) - specifies whether swapping is initiated. Swap Out/Swap In are indicated by 0 and 1, respectively. Set to 0 if paging is not in progress. CURRENT_PID2 (1 word) - specifies the pid of the currently running process on the secondary core. This field is used only when eXpOS is running on NEXSM (a two-core extension of XSM) machine. *LOGOUT_STATUS (1 word) - specifies whether logout is initiated on the primary core. Set to 0 if logout is not initiated. This field is used only when eXpOS is running on NEXSM (a two-core extension of XSM) machine. Initially, when the table is set up by the OS startup code, the MEM_FREE_COUNT is initialized to the number of free pages available in the system, WAIT_MEM_COUNT to 0, SWAPPED_COUNT to 0 and PAGING_STATUS to 0. Note The System Status Table is present in page 57 of the memory (see Memory Organisation ), and the SPL constant SYSTEM_STATUS_TABLE points to the starting address of the table.","title":"System Status Table"},{"location":"os-design/mem-ds/#terminal-status-table","text":"The Terminal Status Table keeps track of the Read/Write operations done on the terminal. Every time a Read or Write system call is invoked on the terminal, the PID of the process that invoked the system call is stored in Terminal Status Table. The table also contains information on the status of the terminal (whether free or busy). The size of the table is 4 words of which the last 2 are unused. Every entry of the Terminal Status Table has the following format: STATUS PID Unused STATUS (1 word) - specifies whether the terminal is free or is being used by a process to read or write. This field is initially set to 0. It is changed to 1 whenever terminal is busy. The Terminal Interrupt Handler sets back the status to 0 upon completion of Terminal Read. The Write system call sets back the status to 0 upon completion of Terminal Write. PID (1 word) - specifies the PID of the process which is currently using the terminal. This field is invalid when STATUS is 0. Unused (2 words) Note The Terminal Table is present in page 57 of the memory (see Memory Organisation ), and the SPL constant TERMINAL_STATUS_TABLE points to the starting address of the table.","title":"Terminal Status Table"},{"location":"os-design/mem-ds/#memory-free-list","text":"The Memory free list is a data structure used for keeping track of used and unused pages in the memory. It consists of MAX_MEM_PAGE entries and each entry is of size one word. Thus, the total size of the free list is MAX_MEM_PAGE words. The number of memory pages available to the OS is architecture dependent. For the version of XSM discussed here, MAX_MEM_PAGE = 128. Each entry of the free list contains either the value 0 indicating that the corresponding page in the memory is free (not allocated to any process) or contains the number of processes that are sharing the page. Memory free list entries for the pages allocated to the kernel are also set to 1. Note Memory copy of the Mem Free List is present in page 57 of the memory (see Memory Organisation ), and the SPL constant MEMORY_FREE_LIST points to the starting address of the data structure.","title":"Memory Free List"},{"location":"os-design/mem-ds/#access-lock-table","text":"When eXpOS runs on a two-core machine like NEXSM , the OS kernel code executes parallelly on the cores. Hence, to ensure atomicity of the resource acquire functions (of the resource manager module), as well as access/updates of OS data structures, an additional layer of access locking is introduced. The OS maintains an Access Lock Table in memory with the following fields to hold the additional locks. The Access Lock Table has the following format: KERN_LOCK SCHED_LOCK GLOCK Unused KERN_LOCK (1 word) - Common access lock to be set before running any critical kernel code other than scheduling. Before performing any kernel function, this lock must be set by the kernel module/interrupt handler so that the other core waits till the critical action is completed. SCHED_LOCK (1 word) - Access lock to run the Scheduler Module. if one core has set the SCHEDULE_LOCK, then upon entering the Scheduler Module, the other core executes a busy loop until execution of the Scheduler Module on the first core is completed. GLOCK (1 word) - A general purpose lock variable that is left unused for future use. Unused (5 words) Note This data structure is used only when eXpOS is running on NEXSM (a two-core extension of XSM) machine.","title":"Access Lock Table"},{"location":"os-design/misc/","text":"OS Startup Code \u00b6 OS Startup Code is loaded from disk to memory by the ROM Code on machine startup. Its main function is to prepare the machine for executing the processes. It initializes data structures, loads root file, disk free list, etc into the memory. OS startup code invokes Boot Module to help the booting. Algorithm \u00b6 Load IDLE process and boot module from disk to memory. See disk/memory organization . Set SP to (user area page number of idle) * 512 + 1 and invoke module 7. //running the boot module in the context of idle. // after returning from the boot module /* Initialize the IDLE process.*/ Initialize the Page table for IDLE process (PID = 0) Initialize the Page table base register (PTBR) to PAGE_TABLE_BASE and PTLR to 10. Set the page table entries for library and heap to -1. Set auxiliary information for these pages to \"0000\". // idle doesn't invoke any library function. Set the first code page entry to 69 (See memory organization ). Set auxiliary information for valid code pages to \"0100\". Set remaining code page entries to -1 and auxiliary information to \"0000\". Set the first stack page entry to 70 and auxiliary information for this page to \"0110\". Set second stack page entry to -1 and auxiliary information to \"0000\". Initialize the process table for IDLE process. Initialize the fields of process table as - TICK, PID and USERID as 0, STATE as RUNNING, USER AREA PAGE NUMBER as 76 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE and PTLR as 10. Store the IP value (from the header of the IDLE) on top of first user stack page [70*512] = [69*512 +1]. /* Initialize the Swapper Daemon (not relevant before Stage 27) */ Initialize the Page table for Swapper Daemon (PID = 15) /* Swapper Daemon is identical to Idle and shares the code for Idle */ Initialize the Page table base register (PTBR) to PAGE_TABLE_BASE + 20*15 and PTLR to 10. Set the page table entries for library and heap to -1. Set auxiliary information for these pages to \"0000\". // swapper doesn't invoke any library function. Set the first code page entry to that of Idle (See memory organization ). Set auxiliary information for valid code pages to \"0100\". Set remaining code page entries to -1 and auxiliary information to \"0000\". Set the first stack page entry to 81 and auxiliary information for this page to \"0110\". Set second stack page entry to -1 and auxiliary information to \"0000\". Initialize the process table for Swapper Daemon. Initialize the fields of process table as - TICK, USERID as 0, PID as 15, STATE as CREATED, USER AREA PAGE NUMBER as 82 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 20*15 and PTLR as 10. Store the IP value (from the header of the IDLE whose code is shared by Swapper) on top of first user stack page [81*512] = [69*512 +1]. /* Initialize the IDLE2 (not relevant before Stage 28) */ Initialize the Page table for IDLE2 (PID = 14) /* IDLE2 is identical to Idle and shares the code for Idle */ Initialize the Page table base register (PTBR) to PAGE_TABLE_BASE + 20*14 and PTLR to 10. Set the page table entries for library and heap to -1. Set auxiliary information for these pages to \"0000\". // swapper doesn't invoke any library function. Set the first code page entry to that of Idle (See memory organization ). Set auxiliary information for valid code pages to \"0100\". Set remaining code page entries to -1 and auxiliary information to \"0000\". Set the first stack page entry to 83 and auxiliary information for this page to \"0110\". Set second stack page entry to -1 and auxiliary information to \"0000\". Initialize the process table for IDLE2. Initialize the fields of process table as - TICK, USERID as 0, PID as 14, STATE as RUNNING, USER AREA PAGE NUMBER as 84 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 20*14 and PTLR as 10. Set the Page table base register (PTBR) to PAGE_TABLE_BASE and PTLR to 10. Schedule IDLE process for excecution. (Return to user mode.) Question Why is the disk transfer (loading all the routines and data structures) done synchronously? Shell Process \u00b6 It is created by the init process to act like a console. It accepts a command from the console. If the commnad is halt, shell shutdown the system using Shutdown system call. If the given command is built in shell command, corresponding system call will be executed with after reading suitable arguments from the console. If the command is a executable file, shell forks itself and Exec the file given as command. These steps are repeated to accept and execute other files from the console. Typically in eXpOS, the shell process acts as the init process. In Multiuser implemention of eXpOS, the login process acts as the init process, which then executes the shell process with PID = 2. Complete ExpL code for Shell program is provided here . Algorithm \u00b6 while TRUE do command = read from console command to be executed. if command == halt invoke shutdown system call. endif if command is built in shell command //eg- Logout, Remusr, Newusr etc Read the required arguments from the console according to the built in shell command Invoke the corresponding system call with arguments. else childPID = fork(); if (childPID == 0) /*Only child process will do the exec */ Execute given command using Exec system call. else Wait for child to finish execution. /* Using Wait system Call*/ endif endif endwhile Idle Process \u00b6 It is a user program which is created and executed by the bootstrap loader. It is stored in the disk and will be loaded to memory by the bootstrap loader. The main purpose of the idle process is to run as a background process in an infinite loop. This is demanded by the OS so that the scheduler will always have a process to schedule. The page table and process table for the idle process will be set up by the bootstrap loader. The PID of the idle process is fixed to be 0. Algorithm \u00b6 while TRUE do //infinite loop endwhile INIT/Login Process \u00b6 The login process is the first process scheduled for execution. It is used to login a user.The login process waits invoking the (terminal) read system call for a username and password to be input from the console. The login process executes the Login system call with the username and the password as the arguments. The login system call verifies the user and creates a new shell process .The original login process waits inside the login system call for the shell to exit. Upon exit of the shell, the login process proceeds to log in the next user. The login process is the init process in Multiuser extension to eXpOS. Algorithm \u00b6 while TRUE do username = read from console password = read from console Retval = Login (username, password) if Retval = -1 Write to console \"Invalid credentials\" else if Retval = -2 Write to console \"Permission denied\" endif endwhile Swapper Daemon \u00b6 It is a user program which is created by the bootstrap loader. This process uses the same code of the Idle process and hence has no file in the disk associated with it. The main purpose of the swapper daemon is to serve as a user program such that the OS performs swap-in and swap-out operations in the kernel context of this process. The PID of the swapper daemon is fixed to be 15. Algorithm \u00b6 Identical to the Idle Process and runs with the code of the Idle Process. OS Startup Code for Secondary Core \u00b6 This is only relevant for Stage 28. OS Startup Code for the secondary core is loaded from disk to memory by the Boot Module . Its main function is to prepare the secondary core of the machine for executing the processes. Algorithm \u00b6 Store the IP value (from the header of the IDLE whose code is shared by Swapper) on top of first user stack page [83*512] = [69*512 + 1] Set SP to 8*512 Set the Page table base register (PTBR) to PAGE\\_TABLE\\_BASE + 14*20 and PTLR to 10. Schedule IDLE2 process for excecution. (Return to user mode) IDLE Process for Secondary Core \u00b6 This is only relevant for Stage 28. It is a user program which is created by the bootstrap loader. This process uses the same code of the Idle process and hence has no file in the disk associated with it. The main purpose of the idle process is to run as a background process in an infinite loop in the secondary core. This is demanded by the OS so that the scheduler will always have a process to schedule in the secondary core, even if it schedules the IDLE in the primary core. The page table and process table for the init process will be set up by the bootstrap loader. The PID of the idle process is fixed to be 14. Algorithm \u00b6 Identical to the Idle Process and runs with the code of the Idle Process.","title":"Micellaneous"},{"location":"os-design/misc/#os-startup-code","text":"OS Startup Code is loaded from disk to memory by the ROM Code on machine startup. Its main function is to prepare the machine for executing the processes. It initializes data structures, loads root file, disk free list, etc into the memory. OS startup code invokes Boot Module to help the booting.","title":"OS Startup Code"},{"location":"os-design/misc/#algorithm","text":"Load IDLE process and boot module from disk to memory. See disk/memory organization . Set SP to (user area page number of idle) * 512 + 1 and invoke module 7. //running the boot module in the context of idle. // after returning from the boot module /* Initialize the IDLE process.*/ Initialize the Page table for IDLE process (PID = 0) Initialize the Page table base register (PTBR) to PAGE_TABLE_BASE and PTLR to 10. Set the page table entries for library and heap to -1. Set auxiliary information for these pages to \"0000\". // idle doesn't invoke any library function. Set the first code page entry to 69 (See memory organization ). Set auxiliary information for valid code pages to \"0100\". Set remaining code page entries to -1 and auxiliary information to \"0000\". Set the first stack page entry to 70 and auxiliary information for this page to \"0110\". Set second stack page entry to -1 and auxiliary information to \"0000\". Initialize the process table for IDLE process. Initialize the fields of process table as - TICK, PID and USERID as 0, STATE as RUNNING, USER AREA PAGE NUMBER as 76 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE and PTLR as 10. Store the IP value (from the header of the IDLE) on top of first user stack page [70*512] = [69*512 +1]. /* Initialize the Swapper Daemon (not relevant before Stage 27) */ Initialize the Page table for Swapper Daemon (PID = 15) /* Swapper Daemon is identical to Idle and shares the code for Idle */ Initialize the Page table base register (PTBR) to PAGE_TABLE_BASE + 20*15 and PTLR to 10. Set the page table entries for library and heap to -1. Set auxiliary information for these pages to \"0000\". // swapper doesn't invoke any library function. Set the first code page entry to that of Idle (See memory organization ). Set auxiliary information for valid code pages to \"0100\". Set remaining code page entries to -1 and auxiliary information to \"0000\". Set the first stack page entry to 81 and auxiliary information for this page to \"0110\". Set second stack page entry to -1 and auxiliary information to \"0000\". Initialize the process table for Swapper Daemon. Initialize the fields of process table as - TICK, USERID as 0, PID as 15, STATE as CREATED, USER AREA PAGE NUMBER as 82 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 20*15 and PTLR as 10. Store the IP value (from the header of the IDLE whose code is shared by Swapper) on top of first user stack page [81*512] = [69*512 +1]. /* Initialize the IDLE2 (not relevant before Stage 28) */ Initialize the Page table for IDLE2 (PID = 14) /* IDLE2 is identical to Idle and shares the code for Idle */ Initialize the Page table base register (PTBR) to PAGE_TABLE_BASE + 20*14 and PTLR to 10. Set the page table entries for library and heap to -1. Set auxiliary information for these pages to \"0000\". // swapper doesn't invoke any library function. Set the first code page entry to that of Idle (See memory organization ). Set auxiliary information for valid code pages to \"0100\". Set remaining code page entries to -1 and auxiliary information to \"0000\". Set the first stack page entry to 83 and auxiliary information for this page to \"0110\". Set second stack page entry to -1 and auxiliary information to \"0000\". Initialize the process table for IDLE2. Initialize the fields of process table as - TICK, USERID as 0, PID as 14, STATE as RUNNING, USER AREA PAGE NUMBER as 84 (allocated from free user space), KPTR to 0, UPTR to 4096 (starting of first user stack page), PTBR to PAGE_TABLE_BASE + 20*14 and PTLR as 10. Set the Page table base register (PTBR) to PAGE_TABLE_BASE and PTLR to 10. Schedule IDLE process for excecution. (Return to user mode.) Question Why is the disk transfer (loading all the routines and data structures) done synchronously?","title":"Algorithm"},{"location":"os-design/misc/#shell-process","text":"It is created by the init process to act like a console. It accepts a command from the console. If the commnad is halt, shell shutdown the system using Shutdown system call. If the given command is built in shell command, corresponding system call will be executed with after reading suitable arguments from the console. If the command is a executable file, shell forks itself and Exec the file given as command. These steps are repeated to accept and execute other files from the console. Typically in eXpOS, the shell process acts as the init process. In Multiuser implemention of eXpOS, the login process acts as the init process, which then executes the shell process with PID = 2. Complete ExpL code for Shell program is provided here .","title":"Shell Process"},{"location":"os-design/misc/#algorithm_1","text":"while TRUE do command = read from console command to be executed. if command == halt invoke shutdown system call. endif if command is built in shell command //eg- Logout, Remusr, Newusr etc Read the required arguments from the console according to the built in shell command Invoke the corresponding system call with arguments. else childPID = fork(); if (childPID == 0) /*Only child process will do the exec */ Execute given command using Exec system call. else Wait for child to finish execution. /* Using Wait system Call*/ endif endif endwhile","title":"Algorithm"},{"location":"os-design/misc/#idle-process","text":"It is a user program which is created and executed by the bootstrap loader. It is stored in the disk and will be loaded to memory by the bootstrap loader. The main purpose of the idle process is to run as a background process in an infinite loop. This is demanded by the OS so that the scheduler will always have a process to schedule. The page table and process table for the idle process will be set up by the bootstrap loader. The PID of the idle process is fixed to be 0.","title":"Idle Process"},{"location":"os-design/misc/#algorithm_2","text":"while TRUE do //infinite loop endwhile","title":"Algorithm"},{"location":"os-design/misc/#initlogin-process","text":"The login process is the first process scheduled for execution. It is used to login a user.The login process waits invoking the (terminal) read system call for a username and password to be input from the console. The login process executes the Login system call with the username and the password as the arguments. The login system call verifies the user and creates a new shell process .The original login process waits inside the login system call for the shell to exit. Upon exit of the shell, the login process proceeds to log in the next user. The login process is the init process in Multiuser extension to eXpOS.","title":"INIT/Login Process"},{"location":"os-design/misc/#algorithm_3","text":"while TRUE do username = read from console password = read from console Retval = Login (username, password) if Retval = -1 Write to console \"Invalid credentials\" else if Retval = -2 Write to console \"Permission denied\" endif endwhile","title":"Algorithm"},{"location":"os-design/misc/#swapper-daemon","text":"It is a user program which is created by the bootstrap loader. This process uses the same code of the Idle process and hence has no file in the disk associated with it. The main purpose of the swapper daemon is to serve as a user program such that the OS performs swap-in and swap-out operations in the kernel context of this process. The PID of the swapper daemon is fixed to be 15.","title":"Swapper Daemon"},{"location":"os-design/misc/#algorithm_4","text":"Identical to the Idle Process and runs with the code of the Idle Process.","title":"Algorithm"},{"location":"os-design/misc/#os-startup-code-for-secondary-core","text":"This is only relevant for Stage 28. OS Startup Code for the secondary core is loaded from disk to memory by the Boot Module . Its main function is to prepare the secondary core of the machine for executing the processes.","title":"OS Startup Code for Secondary Core"},{"location":"os-design/misc/#algorithm_5","text":"Store the IP value (from the header of the IDLE whose code is shared by Swapper) on top of first user stack page [83*512] = [69*512 + 1] Set SP to 8*512 Set the Page table base register (PTBR) to PAGE\\_TABLE\\_BASE + 14*20 and PTLR to 10. Schedule IDLE2 process for excecution. (Return to user mode)","title":"Algorithm"},{"location":"os-design/misc/#idle-process-for-secondary-core","text":"This is only relevant for Stage 28. It is a user program which is created by the bootstrap loader. This process uses the same code of the Idle process and hence has no file in the disk associated with it. The main purpose of the idle process is to run as a background process in an infinite loop in the secondary core. This is demanded by the OS so that the scheduler will always have a process to schedule in the secondary core, even if it schedules the IDLE in the primary core. The page table and process table for the init process will be set up by the bootstrap loader. The PID of the idle process is fixed to be 14.","title":"IDLE Process for Secondary Core"},{"location":"os-design/misc/#algorithm_6","text":"Identical to the Idle Process and runs with the code of the Idle Process.","title":"Algorithm"},{"location":"os-design/multiusersyscalls/","text":"Newusr \u00b6 Arguments \u00b6 User name, Password Return Value: \u00b6 0 Success -1 User already exists -2 Permission denied -3 Number of users has reached the system limit. Description \u00b6 This system call is used to create a new user. It checks whether the user already exists. If not, it creates a new user with the username and password specified. This system call can be executed only by the shell process of root user. Algorithm: \u00b6 Set the MODE_FLAG in the process table entry to 22, indicating that the process is in the newusr system call. If the current user is not root, or if the current process is not the shell, return -2. Loop through the User Table and exit returning -1 if an entry for the user already exists. Find a free entry in the User Table. If no free entry is found, return -3. Find the encrypted password by applying the ENCRYPT instruction on the input password. Set the USERNAME and ENCRYPTED PASSWORD fields of the User Table entry. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0 Note At each point of return from the system call, remember to reset the MODE FLAG. Remusr \u00b6 Arguments \u00b6 User name Return Value \u00b6 0 Success -1 User does not exist -2 Permission denied -3 Undeleted files exist for the user Description \u00b6 This system call is used to remove an existing user. This system call can be executed from the shell proces of the root user. The root user and kernel cannot be removed. Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 23, indicating that the process is in the remuser system call. If the current user is not root, or if the current process is not the shell, return -2. If the user to be removed is the \"root\" or \"kernel\" return -2. Loop through the User Table and find the entry curresponding to the user. If the entry is not found, return -1. Loop through the Root File and exit returning -3 if there are files of the user present on disk. Invalidate the entry by setting the USERNAME and ENCRYPTED PASSWORD fields to -1. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. Note At each point of return from the system call, remember to reset the MODE FLAG. Setpwd \u00b6 Arguments \u00b6 User name, Password Return Value: \u00b6 0 Success -1 Unauthorised attempt to change password -2 The user does not exist Description \u00b6 This system call is used to change the password of an existing user. This system call can be exected only from the shell process. A user can set only his/her password. Root user can set any user's password. Algorithm: \u00b6 Set the MODE_FLAG in the process table entry to 24, indicating that the process is in the setpwd system call. If the current process is not the shell, return -1. Loop through the User Table and finds the entry curresponding to the user name. If entry is not found, return -2. If (userid of the process is not equal to the userid of the user) { If (the current user is not root)) { Return -1 } } Find the encrypted password by applying the ENCRYPT instruction on the input password. Set the ENCRYPTED PASSWORD field in the user table entry. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. Note At each point of return from the system call, remember to reset the MODE FLAG. Getuid \u00b6 Arguments \u00b6 User name Return Value: \u00b6 -1 Invalid Username User Identifier Success Description \u00b6 If the username is valid, this system call returns the userid corresponding to the username. Otherwise, it returns -1. The userid of a user is the index of the user table entry of the user. Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 26, indicating that the process is in the getuid system call. Loop through the User Table : If username is equal to USERNAME field of the entry return index of the entry Return -1 Note At each point of return from the system call, remember to reset the MODE FLAG. Getuname \u00b6 Arguments \u00b6 User ID Return Value \u00b6 -1 Invalid UserID User Name Success Description \u00b6 If the userid is valid, this system call returns the username corresponding to the userid. Otherwise, it returns -1. Algorithm: \u00b6 Set the MODE_FLAG in the process table entry to 25, indicating that the process is in the getuname system call. If (UserID < 0 or UserID > 15) Return -1 If the user table entry curresponding to the userid is invalid, return -1. Fetch the user name from the User Table . Set the MODE_FLAG in the process table entry of the parent process to 0. Return the username. Note At each point of return from the system call, remember to reset the MODE FLAG. Login \u00b6 Arguments \u00b6 User name, Password Return Value \u00b6 0 Success -1 Invalid username or password -2 Permission denied Description \u00b6 This system call is used to login a new user. It can be executed only from the login process. It verifies the user. Upon successful login, a new user process (shell) with the userid of the user specified is created. The calling process goes to sleep till the exit of the newly created shell process. Algorithm: \u00b6 Set the MODE_FLAG in the process table entry to 27, indicating that the process is in the login system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If PID of the current process is not 1, return -2. /* Login process has PID = 1 */ Get the User Table entry curresponding to the username. If an entry does not exist, return -1. Use the ecrypt statement to encrypt the password supplied as input. If the encypted input password does not match the ENCRYPTED PASSWORD field in the user table entry, return -1. In the process table entry for the shell process, set STATE as CREATED and USERID as that of the user who is logging in. Set the state of the current process in it's process table entry as (WAIT_PROCESS, 2) /* Login waits for shell to exit */ In system status table , set the CURRENT_USER_ID as that of the user who is logging in. Invoke the context_switch() function in the Scheduler Module . Reset the MODE_FLAG and restore SP to user stack. ireturn; Note At each point of return from the system call, remember to reset the MODE FLAG. Question Login process does not load the shell process, but sets it's state to CREATED. Can it happen that the shell is not present in memory? Logout \u00b6 Arguments \u00b6 None Return Value \u00b6 -1 on error, otherwise does not return Description \u00b6 This system call is used to logout the current user. It can be invoked only from the shell process (PID = 2). When the logout system call is invoked, all running processes of the current user are terminated and all resources released. Idle and init/Login will be the only processes running after the execution of Logout. Login process is woken up at the end of logout. Control flow diagram for Logout system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 28, indicating that the process is in the logout system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If the current process is not the shell, return -1. /* Shell process has the PID 2 */ Kill all user processes except the shell by calling the kill_all() function in the Process Manager module. Set the STATE of the current process(shell) in the process table to TERMINATED. /* Shell should be set ready to run when the next user logs in. */ Obtain the entry point IP value from the header of the shell program. Place it in the beginning (logical addesss 4096) of the stack of the shell(current process). Reset the USERSP field of the shell to 4096. Wake up the Login process by changing STATE in it's process table entry to READY. In system status table , reset the CURRENT_USER_ID field back to 0 (kernel). Invoke the context_switch() function in the Scheduler Module . Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question Why don't we kill the current process (shell) by using the exit_process() module function?","title":"Multi-User System Calls"},{"location":"os-design/multiusersyscalls/#newusr","text":"","title":"Newusr"},{"location":"os-design/multiusersyscalls/#arguments","text":"User name, Password","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value","text":"0 Success -1 User already exists -2 Permission denied -3 Number of users has reached the system limit.","title":"Return Value:"},{"location":"os-design/multiusersyscalls/#description","text":"This system call is used to create a new user. It checks whether the user already exists. If not, it creates a new user with the username and password specified. This system call can be executed only by the shell process of root user.","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm","text":"Set the MODE_FLAG in the process table entry to 22, indicating that the process is in the newusr system call. If the current user is not root, or if the current process is not the shell, return -2. Loop through the User Table and exit returning -1 if an entry for the user already exists. Find a free entry in the User Table. If no free entry is found, return -3. Find the encrypted password by applying the ENCRYPT instruction on the input password. Set the USERNAME and ENCRYPTED PASSWORD fields of the User Table entry. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0 Note At each point of return from the system call, remember to reset the MODE FLAG.","title":"Algorithm:"},{"location":"os-design/multiusersyscalls/#remusr","text":"","title":"Remusr"},{"location":"os-design/multiusersyscalls/#arguments_1","text":"User name","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value_1","text":"0 Success -1 User does not exist -2 Permission denied -3 Undeleted files exist for the user","title":"Return Value"},{"location":"os-design/multiusersyscalls/#description_1","text":"This system call is used to remove an existing user. This system call can be executed from the shell proces of the root user. The root user and kernel cannot be removed.","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm_1","text":"Set the MODE_FLAG in the process table entry to 23, indicating that the process is in the remuser system call. If the current user is not root, or if the current process is not the shell, return -2. If the user to be removed is the \"root\" or \"kernel\" return -2. Loop through the User Table and find the entry curresponding to the user. If the entry is not found, return -1. Loop through the Root File and exit returning -3 if there are files of the user present on disk. Invalidate the entry by setting the USERNAME and ENCRYPTED PASSWORD fields to -1. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. Note At each point of return from the system call, remember to reset the MODE FLAG.","title":"Algorithm"},{"location":"os-design/multiusersyscalls/#setpwd","text":"","title":"Setpwd"},{"location":"os-design/multiusersyscalls/#arguments_2","text":"User name, Password","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value_2","text":"0 Success -1 Unauthorised attempt to change password -2 The user does not exist","title":"Return Value:"},{"location":"os-design/multiusersyscalls/#description_2","text":"This system call is used to change the password of an existing user. This system call can be exected only from the shell process. A user can set only his/her password. Root user can set any user's password.","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm_2","text":"Set the MODE_FLAG in the process table entry to 24, indicating that the process is in the setpwd system call. If the current process is not the shell, return -1. Loop through the User Table and finds the entry curresponding to the user name. If entry is not found, return -2. If (userid of the process is not equal to the userid of the user) { If (the current user is not root)) { Return -1 } } Find the encrypted password by applying the ENCRYPT instruction on the input password. Set the ENCRYPTED PASSWORD field in the user table entry. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. Note At each point of return from the system call, remember to reset the MODE FLAG.","title":"Algorithm:"},{"location":"os-design/multiusersyscalls/#getuid","text":"","title":"Getuid"},{"location":"os-design/multiusersyscalls/#arguments_3","text":"User name","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value_3","text":"-1 Invalid Username User Identifier Success","title":"Return Value:"},{"location":"os-design/multiusersyscalls/#description_3","text":"If the username is valid, this system call returns the userid corresponding to the username. Otherwise, it returns -1. The userid of a user is the index of the user table entry of the user.","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm_3","text":"Set the MODE_FLAG in the process table entry to 26, indicating that the process is in the getuid system call. Loop through the User Table : If username is equal to USERNAME field of the entry return index of the entry Return -1 Note At each point of return from the system call, remember to reset the MODE FLAG.","title":"Algorithm"},{"location":"os-design/multiusersyscalls/#getuname","text":"","title":"Getuname"},{"location":"os-design/multiusersyscalls/#arguments_4","text":"User ID","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value_4","text":"-1 Invalid UserID User Name Success","title":"Return Value"},{"location":"os-design/multiusersyscalls/#description_4","text":"If the userid is valid, this system call returns the username corresponding to the userid. Otherwise, it returns -1.","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm_4","text":"Set the MODE_FLAG in the process table entry to 25, indicating that the process is in the getuname system call. If (UserID < 0 or UserID > 15) Return -1 If the user table entry curresponding to the userid is invalid, return -1. Fetch the user name from the User Table . Set the MODE_FLAG in the process table entry of the parent process to 0. Return the username. Note At each point of return from the system call, remember to reset the MODE FLAG.","title":"Algorithm:"},{"location":"os-design/multiusersyscalls/#login","text":"","title":"Login"},{"location":"os-design/multiusersyscalls/#arguments_5","text":"User name, Password","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value_5","text":"0 Success -1 Invalid username or password -2 Permission denied","title":"Return Value"},{"location":"os-design/multiusersyscalls/#description_5","text":"This system call is used to login a new user. It can be executed only from the login process. It verifies the user. Upon successful login, a new user process (shell) with the userid of the user specified is created. The calling process goes to sleep till the exit of the newly created shell process.","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm_5","text":"Set the MODE_FLAG in the process table entry to 27, indicating that the process is in the login system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If PID of the current process is not 1, return -2. /* Login process has PID = 1 */ Get the User Table entry curresponding to the username. If an entry does not exist, return -1. Use the ecrypt statement to encrypt the password supplied as input. If the encypted input password does not match the ENCRYPTED PASSWORD field in the user table entry, return -1. In the process table entry for the shell process, set STATE as CREATED and USERID as that of the user who is logging in. Set the state of the current process in it's process table entry as (WAIT_PROCESS, 2) /* Login waits for shell to exit */ In system status table , set the CURRENT_USER_ID as that of the user who is logging in. Invoke the context_switch() function in the Scheduler Module . Reset the MODE_FLAG and restore SP to user stack. ireturn; Note At each point of return from the system call, remember to reset the MODE FLAG. Question Login process does not load the shell process, but sets it's state to CREATED. Can it happen that the shell is not present in memory?","title":"Algorithm:"},{"location":"os-design/multiusersyscalls/#logout","text":"","title":"Logout"},{"location":"os-design/multiusersyscalls/#arguments_6","text":"None","title":"Arguments"},{"location":"os-design/multiusersyscalls/#return-value_6","text":"-1 on error, otherwise does not return","title":"Return Value"},{"location":"os-design/multiusersyscalls/#description_6","text":"This system call is used to logout the current user. It can be invoked only from the shell process (PID = 2). When the logout system call is invoked, all running processes of the current user are terminated and all resources released. Idle and init/Login will be the only processes running after the execution of Logout. Login process is woken up at the end of logout. Control flow diagram for Logout system call","title":"Description"},{"location":"os-design/multiusersyscalls/#algorithm_6","text":"Set the MODE_FLAG in the process table entry to 28, indicating that the process is in the logout system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If the current process is not the shell, return -1. /* Shell process has the PID 2 */ Kill all user processes except the shell by calling the kill_all() function in the Process Manager module. Set the STATE of the current process(shell) in the process table to TERMINATED. /* Shell should be set ready to run when the next user logs in. */ Obtain the entry point IP value from the header of the shell program. Place it in the beginning (logical addesss 4096) of the stack of the shell(current process). Reset the USERSP field of the shell to 4096. Wake up the Login process by changing STATE in it's process table entry to READY. In system status table , reset the CURRENT_USER_ID field back to 0 (kernel). Invoke the context_switch() function in the Scheduler Module . Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question Why don't we kill the current process (shell) by using the exit_process() module function?","title":"Algorithm"},{"location":"os-design/nexpos/","text":"NEXSM is an extension of the XSM architecture with a dual-core feature. The machine has two identical cores with the same set of internal registers sharing a common memory. All registers in XSM are present in both the cores. Additionally, NEXSM cores contain an extra register called the core flag . A few additional privileged instructions provide primitives for synchronization between the two cores. One of the processors is called the primary core and the other called the secondary core . The machine can operate in two modes \u2013 active mode and reset mode . In the reset mode, the secondary is non-functional. The mode in which the machine operates can be controlled by the primary using a pair of special privileged instructions \u2013 START and RESET. Modifications to User Interface \u00b6 The user interface is eXpOS undergoes no change. Modifications to Application Interface \u00b6 The application interface specification of the eXpOS undergoes minor modification when moving to NEXSM. The version of eXpOS running on NEXSM supports an additional software interrupt INT 19. There are four system calls that gets mapped to INT 19 routine. These are: System Call Name System Call Number Test4 100 Test5 101 Test6 102 Test7 103 The high level library interface to these new system calls is specified here . The low level system call interface to these new system calls is specified here . Currently, these system calls are unused. They could be used for testing future enhancements to the system. Modifications to OS Design \u00b6 The design of eXpOS undergoes changes when ported to the two-core machine. Disk Organization \u00b6 NEXSM disk has 16 additional disk blocks (block numbers 512 to 527). The OS uses these blocks for loading the following handlers: Block Number Contents 512-513 Secondary Bootstrap Loader 514-515 INT 19 handler 516-517 Module 8 518-519 Module 9 520-521 Module 10 522-523 Module 11 524-527 Unused Disk organization is given here . Memory Organization \u00b6 NEXSM has 16 additional pages of memory (pages 128 to 144). The first four new pages are reserved by the machine. These are: Page Number Contents 128-129 Secondary bootstrap loader (bootstrap loader for secondary core) 130-131 Software interrupt, INT 19 (currently INT19 is unused) Four new system calls, Test4, Test5, Test6 and Test7 are added to eXpOS and all these calls are directed to INT19 (see details here ). Currently the functionality of these system calls are unspecified. These are left so for testing future enhancements and conducting experiments on the system. From among the remaining 12 available pages, eXpOS reserves the next eight pages for storing OS code as follows: Page Number Contents 132-133 Module 8 ( Access Control Module ) 134-135 Module 9 (TestA Module) 136-137 Module 10 (TestB Module) 138-139 Module 11 (TestC Module) 140-143 Reserved for future use The present design does not use Module 9, Module 10 and Module 11. Module 8 is called Access Control Module . This module contains code for synchronization between the two cores. Module 9, Module 10 and Module 11 are called TestA Module, TestB Module and TestC Module, respectively. These modules are left free to provide space for testing enhancements and conducting experiments on the system. The remaining four pages (140-143) are also not used. Design Policies \u00b6 The fundamental issue to be resolved while extending the OS to a two core machine is to ensure that concurrent updates of OS data structures from the two cores do not leave the OS in an inconsistent state . Here we impose a few simple to implement design level restrictions on the level of parallelism permitted so that a simple and comprehensible design is possible. The constraints imposed are the following: Policy 1: Atomicity constraints: A single process will never be scheduled simultaneously on both the cores. The scheduler will be designed to ensure this policy. Only one core will run scheduler code that involves updates to kernel data structures at a given time. This makes implementation of the first policy straight-forward. Only one core will be executing critical kernel code at a time. Upon entry into a system call the kernel checks whether the other core is running critical kernel code. If that is the case, then the kernel waits for the other core to finish the critical code before proceeding. Atomicity is ensured using access locks . The kernel maintains a few access locks which will be set before executing critical code. Before executing any critical code, the kernel checks whether the other core has acquired the access lock and waits for the release of the lock before proceeding. When the access lock is available, the kernel sets the access lock when available and proceeds to the critical code. This procedure ensures that only one core executes critical code. Policy 2: Hold and Wait constraints: A process, after acquiring an access lock will quickly perform the required action (like updating a kernel data structure) and release the lock immediately, before being scheduled out. Moreover, a second access lock will be acquired only after releasing the first. These constraints ensure that there will be no hold and wait or circular wait for access locks. It is not very difficult to see that adherence to the above policies is sufficient to ensure the consistency of the OS. Implementation of Access Locking \u00b6 Atomicity of access locking is implemented using the hardware mechanism provided by the NEXSM machine ( TSL instruction ). The details follow. OS Data Structures \u00b6 The OS uses essentially the same data structures in the single processor eXpOS system. However, to ensure atomicity of the resource acquire functions (of the resource manager module), as well as access/updates of OS data structures, an additional layer of access locking, is introduced as explained above. The OS maintains an Access Lock Table in memory with the following fields to hold the additional locks. Access Lock Table \u00b6 Field Function KERN_LOCK Common access lock to be set before running any critical kernel code other than scheduling. Before performing any kernel function, this lock must be set by the kernel module/interrupt handler so that the other core waits till the critical action is completed. SCHED_LOCK Access lock to run the Scheduler Module. If one core has set the SCHED_LOCK in the Scheduler Module, the other core runs in a busy loop until execution of the Scheduler Module is completed. GLOCK A general purpose lock variable that is left unused for future use. The design ensures that before running the scheduler, a process releases KERN_LOCK. The scheduler must set SCHED_LOCK before starting the scheduling process and reset the lock after scheduling actions are completed. The Access Lock table is allocated eight words of memory and is stored in memory locations 29576-29583, of which the last five words are unused. (see memory organization ). Access Control Module \u00b6 The access control module contains functions that implement atomic set and reset operations on the kernel lock variables. The following are functions present in the access control module: AcquireKernLock() AcquireSchedLock() AcquireGLock() ReleaseLock(LockVarAddress) The AccessLock functions can be implemented using the TSL instruction to ensure that locking is atomic . The general locking logic in SPL would be the following: Acquire****Lock() { .... .... while (tsl (LockVariableAddress) == 1) continue; endwhile; } The SPL extension of NEXSM provides constants for identifying the access control variables in the Access Lock Table. Constants for invoking the new modules \u2013 TestA, TestB, TestC and the Access Control Module, etc., are also provided. Other Design Modifications \u00b6 In two core operation, it might be required that both the cores schedule the IDLE process simultaneously. However, this goes against our previously stated design principle of not allowing the same process to be scheduled simultaneously on both the cores. To handle this contingency, a new process called IDLE2 with (PID=14) is created. The scheduler will be modified to run IDLE2 on the secondary core whenever it finds that no other process can be scheduled. The standard IDLE (PID=0) will be scheduled under similar circumstances in the primary core. The primary will never execute IDLE2 and the secondary will never run IDLE (PID=0). IDLE2 is run on the secondary when: No other process is ready, OR The OS is running the pager module or if logout system call is being executed in the primary. In the present design, the scheduler will run LOGIN , SHELL and the Swapper Daemon processes only from the primary. The pager module also will be run only from the primary. These constraints simplify implementation of the kernel, but are neither necessary nor very efficient. Boot Procedure \u00b6 NEXSM specification stipulates that the secondary code bootstraps from the physical address 65536 (page 128) upon execution of the START instruction from the primary. Hence, the bootstrap routine of the primary core must transfer the bootstrap code of the secondary from disk block (see disk organization ) to memory page 128 before issuing the START instruction . The START instruction is issued at the end of normal bootstrap by the primary (see OS Startup code ). The secondary bootstrap code will schedule the IDLE2 process for execution (setting its state appropriately) and from there normal two core execution starts. Implementation \u00b6 The major changes to be made to the single core eXpOS kernel are the following: Upon entry into a system call or exception handler, either from an application or from the scheduler, AcquireKernLock() must be invoked. The lock must be released before invoking the scheduler or switch back to user mode using ReleaseLock(KERN_LOCK) . The scheduler module must be modified to set AcquireSchedLock() before initiating scheduling actions. Upon completion of scheduling actions, the scheduler must release the lock invoking ReleaseLock(SCHED_LOCK) before setting any process into execution. Swapper daemon will be invoked only from the primary core by the timer interrupt handler (as done in eXpOS). When the scheduler running on the second core finds that pager daemon was initiated from the primary (check PAGING_STATUS in system status table ), it will simply schedule IDLE2. The Logout system call will be invoked only from primary core as the shell process will be scheduled to run only on the primary. When the scheduler running on the second core finds that logout/shutdown system call is initiated, from the primary (check LOGOUT_STATUS in system status table ), it will simply schedule IDLE2. A detailed description of the changes required to the eXpOS kernel are outlined in the Stage 28 page of the Roadmap .","title":"NeXpOS Design"},{"location":"os-design/nexpos/#modifications-to-user-interface","text":"The user interface is eXpOS undergoes no change.","title":"Modifications to User Interface"},{"location":"os-design/nexpos/#modifications-to-application-interface","text":"The application interface specification of the eXpOS undergoes minor modification when moving to NEXSM. The version of eXpOS running on NEXSM supports an additional software interrupt INT 19. There are four system calls that gets mapped to INT 19 routine. These are: System Call Name System Call Number Test4 100 Test5 101 Test6 102 Test7 103 The high level library interface to these new system calls is specified here . The low level system call interface to these new system calls is specified here . Currently, these system calls are unused. They could be used for testing future enhancements to the system.","title":"Modifications to Application Interface"},{"location":"os-design/nexpos/#modifications-to-os-design","text":"The design of eXpOS undergoes changes when ported to the two-core machine.","title":"Modifications to OS Design"},{"location":"os-design/nexpos/#disk-organization","text":"NEXSM disk has 16 additional disk blocks (block numbers 512 to 527). The OS uses these blocks for loading the following handlers: Block Number Contents 512-513 Secondary Bootstrap Loader 514-515 INT 19 handler 516-517 Module 8 518-519 Module 9 520-521 Module 10 522-523 Module 11 524-527 Unused Disk organization is given here .","title":"Disk Organization"},{"location":"os-design/nexpos/#memory-organization","text":"NEXSM has 16 additional pages of memory (pages 128 to 144). The first four new pages are reserved by the machine. These are: Page Number Contents 128-129 Secondary bootstrap loader (bootstrap loader for secondary core) 130-131 Software interrupt, INT 19 (currently INT19 is unused) Four new system calls, Test4, Test5, Test6 and Test7 are added to eXpOS and all these calls are directed to INT19 (see details here ). Currently the functionality of these system calls are unspecified. These are left so for testing future enhancements and conducting experiments on the system. From among the remaining 12 available pages, eXpOS reserves the next eight pages for storing OS code as follows: Page Number Contents 132-133 Module 8 ( Access Control Module ) 134-135 Module 9 (TestA Module) 136-137 Module 10 (TestB Module) 138-139 Module 11 (TestC Module) 140-143 Reserved for future use The present design does not use Module 9, Module 10 and Module 11. Module 8 is called Access Control Module . This module contains code for synchronization between the two cores. Module 9, Module 10 and Module 11 are called TestA Module, TestB Module and TestC Module, respectively. These modules are left free to provide space for testing enhancements and conducting experiments on the system. The remaining four pages (140-143) are also not used.","title":"Memory Organization"},{"location":"os-design/nexpos/#design-policies","text":"The fundamental issue to be resolved while extending the OS to a two core machine is to ensure that concurrent updates of OS data structures from the two cores do not leave the OS in an inconsistent state . Here we impose a few simple to implement design level restrictions on the level of parallelism permitted so that a simple and comprehensible design is possible. The constraints imposed are the following: Policy 1: Atomicity constraints: A single process will never be scheduled simultaneously on both the cores. The scheduler will be designed to ensure this policy. Only one core will run scheduler code that involves updates to kernel data structures at a given time. This makes implementation of the first policy straight-forward. Only one core will be executing critical kernel code at a time. Upon entry into a system call the kernel checks whether the other core is running critical kernel code. If that is the case, then the kernel waits for the other core to finish the critical code before proceeding. Atomicity is ensured using access locks . The kernel maintains a few access locks which will be set before executing critical code. Before executing any critical code, the kernel checks whether the other core has acquired the access lock and waits for the release of the lock before proceeding. When the access lock is available, the kernel sets the access lock when available and proceeds to the critical code. This procedure ensures that only one core executes critical code. Policy 2: Hold and Wait constraints: A process, after acquiring an access lock will quickly perform the required action (like updating a kernel data structure) and release the lock immediately, before being scheduled out. Moreover, a second access lock will be acquired only after releasing the first. These constraints ensure that there will be no hold and wait or circular wait for access locks. It is not very difficult to see that adherence to the above policies is sufficient to ensure the consistency of the OS.","title":"Design Policies"},{"location":"os-design/nexpos/#implementation-of-access-locking","text":"Atomicity of access locking is implemented using the hardware mechanism provided by the NEXSM machine ( TSL instruction ). The details follow.","title":"Implementation of Access Locking"},{"location":"os-design/nexpos/#os-data-structures","text":"The OS uses essentially the same data structures in the single processor eXpOS system. However, to ensure atomicity of the resource acquire functions (of the resource manager module), as well as access/updates of OS data structures, an additional layer of access locking, is introduced as explained above. The OS maintains an Access Lock Table in memory with the following fields to hold the additional locks.","title":"OS Data Structures"},{"location":"os-design/nexpos/#access-lock-table","text":"Field Function KERN_LOCK Common access lock to be set before running any critical kernel code other than scheduling. Before performing any kernel function, this lock must be set by the kernel module/interrupt handler so that the other core waits till the critical action is completed. SCHED_LOCK Access lock to run the Scheduler Module. If one core has set the SCHED_LOCK in the Scheduler Module, the other core runs in a busy loop until execution of the Scheduler Module is completed. GLOCK A general purpose lock variable that is left unused for future use. The design ensures that before running the scheduler, a process releases KERN_LOCK. The scheduler must set SCHED_LOCK before starting the scheduling process and reset the lock after scheduling actions are completed. The Access Lock table is allocated eight words of memory and is stored in memory locations 29576-29583, of which the last five words are unused. (see memory organization ).","title":"Access Lock Table"},{"location":"os-design/nexpos/#access-control-module","text":"The access control module contains functions that implement atomic set and reset operations on the kernel lock variables. The following are functions present in the access control module: AcquireKernLock() AcquireSchedLock() AcquireGLock() ReleaseLock(LockVarAddress) The AccessLock functions can be implemented using the TSL instruction to ensure that locking is atomic . The general locking logic in SPL would be the following: Acquire****Lock() { .... .... while (tsl (LockVariableAddress) == 1) continue; endwhile; } The SPL extension of NEXSM provides constants for identifying the access control variables in the Access Lock Table. Constants for invoking the new modules \u2013 TestA, TestB, TestC and the Access Control Module, etc., are also provided.","title":"Access Control Module"},{"location":"os-design/nexpos/#other-design-modifications","text":"In two core operation, it might be required that both the cores schedule the IDLE process simultaneously. However, this goes against our previously stated design principle of not allowing the same process to be scheduled simultaneously on both the cores. To handle this contingency, a new process called IDLE2 with (PID=14) is created. The scheduler will be modified to run IDLE2 on the secondary core whenever it finds that no other process can be scheduled. The standard IDLE (PID=0) will be scheduled under similar circumstances in the primary core. The primary will never execute IDLE2 and the secondary will never run IDLE (PID=0). IDLE2 is run on the secondary when: No other process is ready, OR The OS is running the pager module or if logout system call is being executed in the primary. In the present design, the scheduler will run LOGIN , SHELL and the Swapper Daemon processes only from the primary. The pager module also will be run only from the primary. These constraints simplify implementation of the kernel, but are neither necessary nor very efficient.","title":"Other Design Modifications"},{"location":"os-design/nexpos/#boot-procedure","text":"NEXSM specification stipulates that the secondary code bootstraps from the physical address 65536 (page 128) upon execution of the START instruction from the primary. Hence, the bootstrap routine of the primary core must transfer the bootstrap code of the secondary from disk block (see disk organization ) to memory page 128 before issuing the START instruction . The START instruction is issued at the end of normal bootstrap by the primary (see OS Startup code ). The secondary bootstrap code will schedule the IDLE2 process for execution (setting its state appropriately) and from there normal two core execution starts.","title":"Boot Procedure"},{"location":"os-design/nexpos/#implementation","text":"The major changes to be made to the single core eXpOS kernel are the following: Upon entry into a system call or exception handler, either from an application or from the scheduler, AcquireKernLock() must be invoked. The lock must be released before invoking the scheduler or switch back to user mode using ReleaseLock(KERN_LOCK) . The scheduler module must be modified to set AcquireSchedLock() before initiating scheduling actions. Upon completion of scheduling actions, the scheduler must release the lock invoking ReleaseLock(SCHED_LOCK) before setting any process into execution. Swapper daemon will be invoked only from the primary core by the timer interrupt handler (as done in eXpOS). When the scheduler running on the second core finds that pager daemon was initiated from the primary (check PAGING_STATUS in system status table ), it will simply schedule IDLE2. The Logout system call will be invoked only from primary core as the shell process will be scheduled to run only on the primary. When the scheduler running on the second core finds that logout/shutdown system call is initiated, from the primary (check LOGOUT_STATUS in system status table ), it will simply schedule IDLE2. A detailed description of the changes required to the eXpOS kernel are outlined in the Stage 28 page of the Roadmap .","title":"Implementation"},{"location":"os-design/open/","text":"Arguments \u00b6 Filename (String) Return Value \u00b6 File Descriptor (Integer) Success, the return value is the file descriptor for the opened file. -1 File not found or file is not a data or root file -2 System has reached its limit of open files -3 Process has reached its limit of resources Description \u00b6 For a process to read/write a file, it must first open the file. Only data and root files can be opened. The Open operation returns a file descriptor which identifies the open instance of the file. An application can open the same file several times and each time, a different descriptor will be returned by the Open operation. The OS associates a seek position with every open instance of a file. The seek position indicates the current location of file access (read/write). The Open system call initilizes the seek position to 0 (beginning of the file). The seek position can be modified using the Seek system call . The root file can be opened for Reading by specifying the filename as \"root\" . Note that the Root file is different from the other files - It has a reserved memory page copy. So this will be treated as a special case in all related system calls. Control flow diagram for *Open* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 2, indicating that the process is in the open system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Find a free Per-Process Resource Table entry. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . Find a free Resource Table entry. If there is no free entry, return -3. Call the open() function from the File Manager module to get the Open File table entry. If Open fails, return the error code. Set the Per-Process Resource Table entry Set the Resource Identifier field to FILE . Set the Open File Table index field to the free Open File Table entry found. Set the MODE_FLAG in the process table entry to 0. Restore SP to User SP. Return the index of the Per-Process Resource Table entry. /* success */ /* The index of this entry is the File Descriptor of the file. */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question Why must a free Per Process Resource Table entry be found before calling the open() module function? Question Why should the \"root\" file be treated seperately? Where is this change implimented for the open system call? Question Why do we maintain OPEN INSTANCE COUNT in Open File table and FILE OPEN COUNT in File Status table? Why do we need two tables?","title":"Open"},{"location":"os-design/open/#arguments","text":"Filename (String)","title":"Arguments"},{"location":"os-design/open/#return-value","text":"File Descriptor (Integer) Success, the return value is the file descriptor for the opened file. -1 File not found or file is not a data or root file -2 System has reached its limit of open files -3 Process has reached its limit of resources","title":"Return Value"},{"location":"os-design/open/#description","text":"For a process to read/write a file, it must first open the file. Only data and root files can be opened. The Open operation returns a file descriptor which identifies the open instance of the file. An application can open the same file several times and each time, a different descriptor will be returned by the Open operation. The OS associates a seek position with every open instance of a file. The seek position indicates the current location of file access (read/write). The Open system call initilizes the seek position to 0 (beginning of the file). The seek position can be modified using the Seek system call . The root file can be opened for Reading by specifying the filename as \"root\" . Note that the Root file is different from the other files - It has a reserved memory page copy. So this will be treated as a special case in all related system calls. Control flow diagram for *Open* system call","title":"Description"},{"location":"os-design/open/#algorithm","text":"Set the MODE_FLAG in the process table entry to 2, indicating that the process is in the open system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Find a free Per-Process Resource Table entry. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . Find a free Resource Table entry. If there is no free entry, return -3. Call the open() function from the File Manager module to get the Open File table entry. If Open fails, return the error code. Set the Per-Process Resource Table entry Set the Resource Identifier field to FILE . Set the Open File Table index field to the free Open File Table entry found. Set the MODE_FLAG in the process table entry to 0. Restore SP to User SP. Return the index of the Per-Process Resource Table entry. /* success */ /* The index of this entry is the File Descriptor of the file. */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question Why must a free Per Process Resource Table entry be found before calling the open() module function? Question Why should the \"root\" file be treated seperately? Where is this change implimented for the open system call? Question Why do we maintain OPEN INSTANCE COUNT in Open File table and FILE OPEN COUNT in File Status table? Why do we need two tables?","title":"Algorithm"},{"location":"os-design/proc-misc/","text":"Getpid system call \u00b6 Arguments \u00b6 None Return Value \u00b6 PID Success Description \u00b6 Returns the process identifier of the invoking process. The system call does not fail. Algorithm: \u00b6 Find the PID of the current process from the Process Table . Return the PID of current process. Getppid system call \u00b6 Arguments \u00b6 None Return Value \u00b6 PPID Success Description \u00b6 Returns to the calling process the value of the process identifier of its parent. The system call does not fail. Algorithm \u00b6 Find the PPID of the current process from the Process Table . Return the PPID.","title":"Process Micellaneous"},{"location":"os-design/proc-misc/#getpid-system-call","text":"","title":"Getpid system call"},{"location":"os-design/proc-misc/#arguments","text":"None","title":"Arguments"},{"location":"os-design/proc-misc/#return-value","text":"PID Success","title":"Return Value"},{"location":"os-design/proc-misc/#description","text":"Returns the process identifier of the invoking process. The system call does not fail.","title":"Description"},{"location":"os-design/proc-misc/#algorithm","text":"Find the PID of the current process from the Process Table . Return the PID of current process.","title":"Algorithm:"},{"location":"os-design/proc-misc/#getppid-system-call","text":"","title":"Getppid system call"},{"location":"os-design/proc-misc/#arguments_1","text":"None","title":"Arguments"},{"location":"os-design/proc-misc/#return-value_1","text":"PPID Success","title":"Return Value"},{"location":"os-design/proc-misc/#description_1","text":"Returns to the calling process the value of the process identifier of its parent. The system call does not fail.","title":"Description"},{"location":"os-design/proc-misc/#algorithm_1","text":"Find the PPID of the current process from the Process Table . Return the PPID.","title":"Algorithm"},{"location":"os-design/process-table/","text":"The Process Table (PT) contains an entry for each process present in the system. The entry is created when the process is created by a Fork system call. Each entry contains several fields that stores all the information pertaining to a single process. The maximum number of entries in PT (which is maximum number of processes allowed to exist at a single point of time in eXpOS) is MAX_PROC_NUM. In the current version of eXpOS, MAX_PROC_NUM = 16. Each entry in the Process Table has a constant size, defined by the PT_ENTRY_SIZE. In this version of eXpOS, PT_ENTRY_SIZE is set to 16 words. Any entry of PT has the following fields: Offset 0 1 2 3 4 6 7 8 9 10 11 12 13 14 15 Field Name TICK PID PPID USERID STATE SWAP FLAG INODE INDEX INPUT BUFFER MODE FLAG USER AREA SWAP STATUS USER AREA PAGE NUMBER KERNEL STACK POINTER (KPTR) USER STACK POINTER (UPTR) PTBR PTLR TICK (1 word)- keeps track of how long the process was in memory/ swapped state. It has an initial value of 0 and is updated whenever the scheduler is called. TICK is reset to 0 when a process is swapped out or in. PID (1 word) - process descriptor, a number that is unique to each process. This field is set by Fork System Call. In the present version of eXpOS, the pid is set to the index of the entry in the process table. PPID (1 word) - process descriptor of the parent process. This field is set by Fork System Call. PPID of a process is set to -1 when it's parent process exits. A process whose parent has exited is called an Orphan Process. USERID (1 word) - Userid of the currently logged in user. This field is set by Fork System Call. STATE (2 words) - a two tuple that describes the current state of the process. The details of the states are explained below. SWAP FLAG (1 word) - Indicates if the process is swapped (1) or not (0). The process is said to be swapped if any of its user stack pages or its kernel stack page is swapped out. INODE INDEX (1 word)- Pointer to the Inode entry of the executable file, which was loaded into the process's address space. INPUT BUFFER (1 word) - Buffer used to store the input read from the terminal. Whenever a word is read from the terminal, Terminal Interrupt Handler will store the word into this buffer. MODE FLAG (1 word) - Used to store the system call number if the process is executing inside a system call. It is set to -1 when the process is executing the exception handler. The value is set to 0 otherwise. USER AREA SWAP STATUS (1 word) - Indicates whether the user area of the process has been swapped (1) or not (0). USER AREA PAGE NUMBER (1 word) - Page number allocated for the user area of the process. KERNEL STACK POINTER (1 word) - Pointer to the top of the kernel stack of the process. The offset of this address within the user area is stored in this field. USER STACK POINTER (1 word) - Logical address of the top of the user stack of the process. This is used when the process is running in kernel mode and the machine's stack pointer is pointing to the top of the kernel stack. PTBR (1 word) - pointer to PER-PROCESS PAGE TABLE . PTLR (1 word) - PAGE TABLE LENGTH REGISTER of the process. Invalid entries are represented by -1. Note1: In this version of eXpOS, the Per-Process Resource Table is stored in the user area of each process. Generally, the Per-Process Resource Table is stored somewhere in memory and a pointer to the table is kept in the Process Table entry. Note2: The Process Table is present in page 56 of the memory (see Memory Organisation ), and the SPL constant PROCESS_TABLE points to the starting address of the table. PROCESS_TABLE + PID*16 gives the begining address of process table entry corresponding to the process with identifier PID. STATE \u00b6 The tuple can take the following values (ALLOCATED,___) - The PCB Entry for the process has been allocated, but the process has not been created yet, because the Fork system call has not completed the creation of the new process. (CREATED,___) \u2013 The process has been created in memory and data structures set up, but has never been scheduled. The fork system call creates the child process in CREATED state. (RUNNING,___) \u2013 The process is in execution. This field is set by the scheduler when a process is scheduled. (READY,___) \u2013 The process is ready to be scheduled. (WAIT_PROCESS, WAIT_PID) \u2013 The process is waiting for a signal from another process whose PID is WAIT_PID. This field is set by WAIT system call. (WAIT_FILE, INODEINDEX) - The process is blocked for a file whose index in the inode table is INODEINDEX. (WAIT_DISK,___) - The process is blocked because of one of the following reasons: a) It is waiting for disk to complete a disk-memory transfer operation it had initiated OR b) It wants to execute a disk transfer, but the disk is busy, handling a disk-memory transfer request issued by some other process. The disk interrupt handler changes the state from (WAIT_DISK,___) to (READY,___), after it has completed the disk transfer. (WAIT_SEMAPHORE,SEMTABLEINDEX) - The process is waiting for a semaphore that was locked by some other process. (WAIT_MEM, ___) \u2013 The process is blocked due to unavailability of memory pages. (WAIT_BUFFER, BUFFERID) \u2013 The process is waiting for disk buffer of index BUFFERID to be unlocked. (WAIT_TERMINAL,___) \u2013 The process is waiting for one of the following: a) a Read from Terminal, which it has issued OR b)to be completed or if the terminal is blocked by some other process. The terminal interrupt handler changes the state from (WAIT_TERMINAL,___) to (READY,___), after it has completed the terminal read/write. Process states and transitions can be viewed here . Note When a process terminates, the STATE field in it's process table entry is marked TERMINATED to indicate that the process table entry is free for allocation to new processes. PER-PROCESS PAGE TABLE \u00b6 The Per-Process Page Table contains information regarding the physical location of the pages of a process. Each valid entry of a page table stores the physical page number corresponding to each logical (virtual) page associated with the process. The logical page number can vary from 0 to MAX_PROC_PAGES- 1 for each process. Therefore, each process has MAX_NUM_PAGES entries in the page table. The address of Page Table of the currently executing process is stored in PTBR of the machine and length of the page table is stored in PTLR. In this version of eXpOS, MAX_NUM_PAGES is set to 10, hence PTLR is always set to 10. Associated with each page table entry, typically auxiliary information is also stored. This is to store information like whether the process has write permission to the page, whether the page is dirty, referenced, valid etc. The exact details are architecture dependent. The eXpOS specification expects that the hardware provides support for reference, valid and write bits. (See page table structure of XSM here ). PHYSICAL PAGE NUMBER REFERENCE BIT VALID BIT WRITE BIT Reference bit - The reference bit for a page table entry is set to 0 by the OS when the page is loaded to memory and the page table initialized. When a page is accessed by a running process, the corresponding reference bit is set to 1 by the machine hardware. This bit is used by the page replacement algorithm of the OS. Valid bit - This bit is set to 1 by the OS when the physical page number field of a page table entry is valid (i.e, the page is loaded in memory). It is set to 0 if the entry is invalid. The OS expects the architecture to generate a page fault if any process attempts to access an invalid page. Write bit - This bit is set to 1 by the OS if the page can be written and is set to 0 otherwise. The OS expects the architecture to generate an exception if any process, while running in the user mode, attempts to modify a page whose write bit is not set. If the Page Table entry is invalid, the Physical Page number is set to -1. Note In the XSM machine, the first three bits of the second word stores the reference bit, valid bit and the write permission bit. The fourth bit is the dirty bit which is not used by eXpOS. For more information, see XSM. Note In the eXpOS implementation on the XSM architecture, if a page is not loaded to the memory, but is stored in a disk block, the disk block number corresponding to the physical page number is stored in the disk map table of the process. If memory access is made to a page whose page table entry is invalid, a page fault occurs and the machine transfers control to the Exception Handler routine, which is responsible for loading the correct physical page. Note The Page Table is present in page 58 of the memory (see Memory Organisation ), and the SPL constant PAGE_TABLE_BASE points to the starting address of the table. PAGE_TABLE_BASE + PID*20 gives the begining address of page table entry corresponding to the process with identifier PID. PER-PROCESS DISK MAP TABLE \u00b6 The per-process Disk Map Table stores the disk block number corresponding to the pages of each process. The Disk Map Table has 10 entries for a single process. When the memory pages of a process are swapped out into the disk, the corresponding disk block numbers of those pages are stored in this table. It also stores block numbers of the code pages of the process. The entry in the disk map table entry has the following format: Unused Unused Heap 1 in disk Heap 2 in disk Code 1 in disk Code 2 in disk Code 3 in disk Code 4 in disk Stack Page 1 in disk Stack Page 2 in disk If a memory page is not stored in a disk block, the corresponding entry must be set to -1. Note The Disk Map Table is present in page 58 of the memory (see Memory Organisation ), and the SPL constant DISK_MAP_TABLE points to the starting address of the table. DISK_MAP_TABLE + PID*10 gives the begining address of disk map table entry corresponding to the process with identifier PID. USER AREA \u00b6 Corresponding to each user process, the kernel maintains a seperate memory region (called the user area) for its own purposes. The present version of eXpOS allocates one memory page per process as the user area. A part of this space is used to store the per process resource table of the process. The rest of the memory is alloted for the kernel stack of the process. Hence in eXpOS, each process has a kernel stack in addition to user stack. We maintain a seperate stack for the kernel operations to prevent user-level \"hacks\" into kernel. PER-PROCESS RESOURCE TABLE \u00b6 The Per-Process Resource Table has 8 entries and each entry is of 2 words. The last 16 words of the User Area Page are reserved for this . For every instance of a file opened (or a semaphore acquired) by the process, it stores the index of the Open File Table (or Semaphore Table) entry for the file (or semaphore) is stored in this table. One word is used to store the resource identifier which indicates whether the resource opened by the process is a FILE or a SEMAPHORE . Open system call sets the values of entries in this table for a file. The per-process resource table entry has the following format. Resource Identifier (1 word) Index of Open File Table/ Semaphore Table entry (1 word) File descriptor, returned by Open system call, is the index of the per-process resource table entry for that open instance of the file. A free entry is denoted by -1 in the Resource Identifier field. PER-PROCESS KERNEL STACK \u00b6 Control is tranferred from a user program to a kernel module on the occurence of one of the following events : The user program executes a system call When an interrupt/exception occurs. In either case, the kernel allocates a separate stack for each process (called the kernel stack of the process) which is different from the stack used by the process while executing in the user mode (called the user stack). Kernel modules use the space in the kernel stack for storing local data and do not use the user stack. This is to avoid user \"hacks\" into the kernel using the application's stack. In the case of a system call, the application will store the parameters for the system call in its user stack. Upon entering the kernel module (system call), the kernel will extract these parameters from the application's stack and then change the stack pointer to its own stack before further execution. Since the application invokes the kernel module voluntarily, it is the responsibility of the application to save the contents of its registers (except the stack pointer and base pointer registers in the case of the XSM machine) before invoking the system call. In the case of an interrupt/exception, the user process does not have control over the transfer to the kernel module (interrupt/exception handler). Hence the execution context of the user process (that is, values of the registers) must be saved by the kernel module, before the kernel module uses the machine registers for other purposes, so that the machine state can be restored after completion of the interrupt/exception handler. The kernel stack is used to store the execution context of the user process. This context is restored before the return from the kernel module. (For the implementation of eXpOS on the XSM architecture, the backup and restore instructions facilitate this). In addition to the above, if a kernel module invokes another kernel module while executing a system call/interrupt, the parameters to the called module and the return values from the module are passed through the same kernel stack. Here is a detailed tutorial on kernel stack management in system calls, interrupts and exceptions . A separate tutorial is provided for kernel stack managament during context switch .","title":"Process Table"},{"location":"os-design/process-table/#state","text":"The tuple can take the following values (ALLOCATED,___) - The PCB Entry for the process has been allocated, but the process has not been created yet, because the Fork system call has not completed the creation of the new process. (CREATED,___) \u2013 The process has been created in memory and data structures set up, but has never been scheduled. The fork system call creates the child process in CREATED state. (RUNNING,___) \u2013 The process is in execution. This field is set by the scheduler when a process is scheduled. (READY,___) \u2013 The process is ready to be scheduled. (WAIT_PROCESS, WAIT_PID) \u2013 The process is waiting for a signal from another process whose PID is WAIT_PID. This field is set by WAIT system call. (WAIT_FILE, INODEINDEX) - The process is blocked for a file whose index in the inode table is INODEINDEX. (WAIT_DISK,___) - The process is blocked because of one of the following reasons: a) It is waiting for disk to complete a disk-memory transfer operation it had initiated OR b) It wants to execute a disk transfer, but the disk is busy, handling a disk-memory transfer request issued by some other process. The disk interrupt handler changes the state from (WAIT_DISK,___) to (READY,___), after it has completed the disk transfer. (WAIT_SEMAPHORE,SEMTABLEINDEX) - The process is waiting for a semaphore that was locked by some other process. (WAIT_MEM, ___) \u2013 The process is blocked due to unavailability of memory pages. (WAIT_BUFFER, BUFFERID) \u2013 The process is waiting for disk buffer of index BUFFERID to be unlocked. (WAIT_TERMINAL,___) \u2013 The process is waiting for one of the following: a) a Read from Terminal, which it has issued OR b)to be completed or if the terminal is blocked by some other process. The terminal interrupt handler changes the state from (WAIT_TERMINAL,___) to (READY,___), after it has completed the terminal read/write. Process states and transitions can be viewed here . Note When a process terminates, the STATE field in it's process table entry is marked TERMINATED to indicate that the process table entry is free for allocation to new processes.","title":"STATE"},{"location":"os-design/process-table/#per-process-page-table","text":"The Per-Process Page Table contains information regarding the physical location of the pages of a process. Each valid entry of a page table stores the physical page number corresponding to each logical (virtual) page associated with the process. The logical page number can vary from 0 to MAX_PROC_PAGES- 1 for each process. Therefore, each process has MAX_NUM_PAGES entries in the page table. The address of Page Table of the currently executing process is stored in PTBR of the machine and length of the page table is stored in PTLR. In this version of eXpOS, MAX_NUM_PAGES is set to 10, hence PTLR is always set to 10. Associated with each page table entry, typically auxiliary information is also stored. This is to store information like whether the process has write permission to the page, whether the page is dirty, referenced, valid etc. The exact details are architecture dependent. The eXpOS specification expects that the hardware provides support for reference, valid and write bits. (See page table structure of XSM here ). PHYSICAL PAGE NUMBER REFERENCE BIT VALID BIT WRITE BIT Reference bit - The reference bit for a page table entry is set to 0 by the OS when the page is loaded to memory and the page table initialized. When a page is accessed by a running process, the corresponding reference bit is set to 1 by the machine hardware. This bit is used by the page replacement algorithm of the OS. Valid bit - This bit is set to 1 by the OS when the physical page number field of a page table entry is valid (i.e, the page is loaded in memory). It is set to 0 if the entry is invalid. The OS expects the architecture to generate a page fault if any process attempts to access an invalid page. Write bit - This bit is set to 1 by the OS if the page can be written and is set to 0 otherwise. The OS expects the architecture to generate an exception if any process, while running in the user mode, attempts to modify a page whose write bit is not set. If the Page Table entry is invalid, the Physical Page number is set to -1. Note In the XSM machine, the first three bits of the second word stores the reference bit, valid bit and the write permission bit. The fourth bit is the dirty bit which is not used by eXpOS. For more information, see XSM. Note In the eXpOS implementation on the XSM architecture, if a page is not loaded to the memory, but is stored in a disk block, the disk block number corresponding to the physical page number is stored in the disk map table of the process. If memory access is made to a page whose page table entry is invalid, a page fault occurs and the machine transfers control to the Exception Handler routine, which is responsible for loading the correct physical page. Note The Page Table is present in page 58 of the memory (see Memory Organisation ), and the SPL constant PAGE_TABLE_BASE points to the starting address of the table. PAGE_TABLE_BASE + PID*20 gives the begining address of page table entry corresponding to the process with identifier PID.","title":"PER-PROCESS PAGE TABLE"},{"location":"os-design/process-table/#per-process-disk-map-table","text":"The per-process Disk Map Table stores the disk block number corresponding to the pages of each process. The Disk Map Table has 10 entries for a single process. When the memory pages of a process are swapped out into the disk, the corresponding disk block numbers of those pages are stored in this table. It also stores block numbers of the code pages of the process. The entry in the disk map table entry has the following format: Unused Unused Heap 1 in disk Heap 2 in disk Code 1 in disk Code 2 in disk Code 3 in disk Code 4 in disk Stack Page 1 in disk Stack Page 2 in disk If a memory page is not stored in a disk block, the corresponding entry must be set to -1. Note The Disk Map Table is present in page 58 of the memory (see Memory Organisation ), and the SPL constant DISK_MAP_TABLE points to the starting address of the table. DISK_MAP_TABLE + PID*10 gives the begining address of disk map table entry corresponding to the process with identifier PID.","title":"PER-PROCESS DISK MAP TABLE"},{"location":"os-design/process-table/#user-area","text":"Corresponding to each user process, the kernel maintains a seperate memory region (called the user area) for its own purposes. The present version of eXpOS allocates one memory page per process as the user area. A part of this space is used to store the per process resource table of the process. The rest of the memory is alloted for the kernel stack of the process. Hence in eXpOS, each process has a kernel stack in addition to user stack. We maintain a seperate stack for the kernel operations to prevent user-level \"hacks\" into kernel.","title":"USER AREA"},{"location":"os-design/process-table/#per-process-resource-table","text":"The Per-Process Resource Table has 8 entries and each entry is of 2 words. The last 16 words of the User Area Page are reserved for this . For every instance of a file opened (or a semaphore acquired) by the process, it stores the index of the Open File Table (or Semaphore Table) entry for the file (or semaphore) is stored in this table. One word is used to store the resource identifier which indicates whether the resource opened by the process is a FILE or a SEMAPHORE . Open system call sets the values of entries in this table for a file. The per-process resource table entry has the following format. Resource Identifier (1 word) Index of Open File Table/ Semaphore Table entry (1 word) File descriptor, returned by Open system call, is the index of the per-process resource table entry for that open instance of the file. A free entry is denoted by -1 in the Resource Identifier field.","title":"PER-PROCESS RESOURCE TABLE"},{"location":"os-design/process-table/#per-process-kernel-stack","text":"Control is tranferred from a user program to a kernel module on the occurence of one of the following events : The user program executes a system call When an interrupt/exception occurs. In either case, the kernel allocates a separate stack for each process (called the kernel stack of the process) which is different from the stack used by the process while executing in the user mode (called the user stack). Kernel modules use the space in the kernel stack for storing local data and do not use the user stack. This is to avoid user \"hacks\" into the kernel using the application's stack. In the case of a system call, the application will store the parameters for the system call in its user stack. Upon entering the kernel module (system call), the kernel will extract these parameters from the application's stack and then change the stack pointer to its own stack before further execution. Since the application invokes the kernel module voluntarily, it is the responsibility of the application to save the contents of its registers (except the stack pointer and base pointer registers in the case of the XSM machine) before invoking the system call. In the case of an interrupt/exception, the user process does not have control over the transfer to the kernel module (interrupt/exception handler). Hence the execution context of the user process (that is, values of the registers) must be saved by the kernel module, before the kernel module uses the machine registers for other purposes, so that the machine state can be restored after completion of the interrupt/exception handler. The kernel stack is used to store the execution context of the user process. This context is restored before the return from the kernel module. (For the implementation of eXpOS on the XSM architecture, the backup and restore instructions facilitate this). In addition to the above, if a kernel module invokes another kernel module while executing a system call/interrupt, the parameters to the called module and the return values from the module are passed through the same kernel stack. Here is a detailed tutorial on kernel stack management in system calls, interrupts and exceptions . A separate tutorial is provided for kernel stack managament during context switch .","title":"PER-PROCESS KERNEL STACK"},{"location":"os-design/read/","text":"Arguments \u00b6 File Descriptor(Integer) and a Buffer (a String/Integer variable) into which a word is to be read from the file Return Value \u00b6 0 Success -1 File Descriptor given is invalid -2 File pointer has reached the end of file Description \u00b6 The Read operation reads one word from the position pointed by the file pointer and stores it into the buffer. After each read operation, the file pointer advances to the next word in the file. Control flow diagram for *Read* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 7, indicating that the process is in the read system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If input is to be read from terminal /* indicated by a file descriptor value of -1 */ Call the terminal_read() function in the Device manager Module . /* If not terminal, read from file. */ else If file descriptor is invalid, return -1. /* File descriptor value should be within the range 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE , return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from the Per Process Resource Table entry. Get the index of the Inode Table entry from the Open File Table entry. Acquire the Lock on the File by calling the acquire_inode() function in the Resource Manager module. If acquiring the inode fails, return -1. Get the Lseek position from the Open File Table entry. Get the physical address curresponding to the logical address of Memory Buffer address given as input. If the File corresponds to Root file ( indicated by Inode index as INODE_ROOT) If the lseek value is equal to the root file size(480), release_inode() return -2. Read from the word at lseek position in memory copy of root file to the translated memory address. /* Use SPL Constant ROOT_FILE */ Increment the Lseek position in the Open File Table. else If lseek position is same as the file size, release_inode() and return -2. /* End of file reached */ Find the disk block number and the position in the block from which input is read. Get the block index from lseek position. /* lseek/512 gives the index of the block */ Get the disk block number corresponding to the block index from the Inode Table . Get the offset value from lseek position. /* lseek%512 gives the position to be read from.*/ Read the data from the File Buffer by calling the buffered_read() function in the File Manager module. Increment the Lseek position in the Open File Table. Release the Lock on the File by calling the release_inode() function in the Resource Manager module. Switch back to the user stack by resoting USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Read"},{"location":"os-design/read/#arguments","text":"File Descriptor(Integer) and a Buffer (a String/Integer variable) into which a word is to be read from the file","title":"Arguments"},{"location":"os-design/read/#return-value","text":"0 Success -1 File Descriptor given is invalid -2 File pointer has reached the end of file","title":"Return Value"},{"location":"os-design/read/#description","text":"The Read operation reads one word from the position pointed by the file pointer and stores it into the buffer. After each read operation, the file pointer advances to the next word in the file. Control flow diagram for *Read* system call","title":"Description"},{"location":"os-design/read/#algorithm","text":"Set the MODE_FLAG in the process table entry to 7, indicating that the process is in the read system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If input is to be read from terminal /* indicated by a file descriptor value of -1 */ Call the terminal_read() function in the Device manager Module . /* If not terminal, read from file. */ else If file descriptor is invalid, return -1. /* File descriptor value should be within the range 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE , return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from the Per Process Resource Table entry. Get the index of the Inode Table entry from the Open File Table entry. Acquire the Lock on the File by calling the acquire_inode() function in the Resource Manager module. If acquiring the inode fails, return -1. Get the Lseek position from the Open File Table entry. Get the physical address curresponding to the logical address of Memory Buffer address given as input. If the File corresponds to Root file ( indicated by Inode index as INODE_ROOT) If the lseek value is equal to the root file size(480), release_inode() return -2. Read from the word at lseek position in memory copy of root file to the translated memory address. /* Use SPL Constant ROOT_FILE */ Increment the Lseek position in the Open File Table. else If lseek position is same as the file size, release_inode() and return -2. /* End of file reached */ Find the disk block number and the position in the block from which input is read. Get the block index from lseek position. /* lseek/512 gives the index of the block */ Get the disk block number corresponding to the block index from the Inode Table . Get the offset value from lseek position. /* lseek%512 gives the position to be read from.*/ Read the data from the File Buffer by calling the buffered_read() function in the File Manager module. Increment the Lseek position in the Open File Table. Release the Lock on the File by calling the release_inode() function in the Resource Manager module. Switch back to the user stack by resoting USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/seek/","text":"Arguments \u00b6 File Descriptor(Integer) , Offset (Integer) Return Value \u00b6 0 Success -1 File Descriptor given is invalid -2 Offset value moves the file pointer to a position outside the file Description \u00b6 The Seek operation allows the application program to change the value of the file pointer so that subsequent Read/Write is performed from a new position in the file. The new value of the file pointer is determined by adding the offset to the current value. (A negative Offset will move the pointer backwards). An Offset of 0 will reset the pointer to the beginning of the file. If a positive offset goes beyond the size of the file, the seek position will be set to the file size (in the inode table entry). A negative offset leading to LSeek value below 0 will give an error. Control flow diagram for *Seek* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 6, indicating that the process is in the seek system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If file descriptor is invalid, return -1. /* File descriptor value must lie within the range from 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . If entry in the Per Process Resource Table corresponding to the file descriptor is invalid, return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from the Per Process Resource Table entry. Get the index of the Inode Table entry from the Open File Table entry. Call the acquire_inode() function in the Resource Manager module. /* Lock the inode */ If the locking fails, return -1. Get the current Lseek position from the Open File Table entry. Check the validity of the given offset 1. Get the file size of the file from the Inode Table (Use 480 if inode index is \"INODE_ROOT\"). 2. If (lseek + the given offset) is less than 0, release_inode() and return -2. If the given offset is 0, Set lseek value in the Open File Table entry to 0. else if lseek+offset is greater than the file size, Set the lseek value to file size. /* Check inode table for file size */ else Change the lseek value in the Per-Process Resource Table entry to lseek+offset. Call the release_inode() function in the Resource Manager module. /* Free the inode */ Set the MODE_FLAG in the process table entry of the parent process to 0. Switch back to the user stack by resoting USER SP from the process table. Return with 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question 1 What concurrency issue can occur if the inode is not locked before reading the lseek position? Question 2 What goes wrong if the LSEEK is stored in the File Status Table instead of the Open File table? Question 3 What goes wrong if the LSEEK is stored in the per-process resource table instead of the Open File table? Question 4 Which all file system calls set the FILE_SIZE field in the inode status table? Question 5 If your OS code has no bugs, acquire_inode() in the above code will never fail. Why?","title":"Seek"},{"location":"os-design/seek/#arguments","text":"File Descriptor(Integer) , Offset (Integer)","title":"Arguments"},{"location":"os-design/seek/#return-value","text":"0 Success -1 File Descriptor given is invalid -2 Offset value moves the file pointer to a position outside the file","title":"Return Value"},{"location":"os-design/seek/#description","text":"The Seek operation allows the application program to change the value of the file pointer so that subsequent Read/Write is performed from a new position in the file. The new value of the file pointer is determined by adding the offset to the current value. (A negative Offset will move the pointer backwards). An Offset of 0 will reset the pointer to the beginning of the file. If a positive offset goes beyond the size of the file, the seek position will be set to the file size (in the inode table entry). A negative offset leading to LSeek value below 0 will give an error. Control flow diagram for *Seek* system call","title":"Description"},{"location":"os-design/seek/#algorithm","text":"Set the MODE_FLAG in the process table entry to 6, indicating that the process is in the seek system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If file descriptor is invalid, return -1. /* File descriptor value must lie within the range from 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . If entry in the Per Process Resource Table corresponding to the file descriptor is invalid, return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from the Per Process Resource Table entry. Get the index of the Inode Table entry from the Open File Table entry. Call the acquire_inode() function in the Resource Manager module. /* Lock the inode */ If the locking fails, return -1. Get the current Lseek position from the Open File Table entry. Check the validity of the given offset 1. Get the file size of the file from the Inode Table (Use 480 if inode index is \"INODE_ROOT\"). 2. If (lseek + the given offset) is less than 0, release_inode() and return -2. If the given offset is 0, Set lseek value in the Open File Table entry to 0. else if lseek+offset is greater than the file size, Set the lseek value to file size. /* Check inode table for file size */ else Change the lseek value in the Per-Process Resource Table entry to lseek+offset. Call the release_inode() function in the Resource Manager module. /* Free the inode */ Set the MODE_FLAG in the process table entry of the parent process to 0. Switch back to the user stack by resoting USER SP from the process table. Return with 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question 1 What concurrency issue can occur if the inode is not locked before reading the lseek position? Question 2 What goes wrong if the LSEEK is stored in the File Status Table instead of the Open File table? Question 3 What goes wrong if the LSEEK is stored in the per-process resource table instead of the Open File table? Question 4 Which all file system calls set the FILE_SIZE field in the inode status table? Question 5 If your OS code has no bugs, acquire_inode() in the above code will never fail. Why?","title":"Algorithm"},{"location":"os-design/semaphore-algos/","text":"Semget system call \u00b6 Argument \u00b6 None Return Value \u00b6 Value Description SEMID (Integer) Success, returns a semaphore descriptor(SEMID) -1 Process has reached its limit of resources -2 Number of semaphores has reached its maximum Description \u00b6 This system call is used to obtain a binary semaphore . eXpOS has a fixed number of semaphores. The semaphores of a process are shared with it's child processes. Data Structures updated are Per Process Resource Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and must be reset before exiting from the system call. Control flow diagram for *Semget* system call Algorithm \u00b6 Set the MODE_FLAG in the Process Table to 17 and switch to kernel stack. Find the index of a free entry in the Per Process Resource Table . /* This will be our semaphore descriptor */ If no free entry, then return -1. Resource Identifier field of the per-process resource table entry is set to 1 to indicate that the resource is a semaphore. Acquire a semaphore by calling the acquire_semaphore() function in the Resource Manager Module. /* acquire_semaphore() module function acquires a semaphore by making an entry in the Semaphore Table and returns the index of the entry. If there are no free semaphores, it returns -1 */ If there are no free semaphores, return -2. Store the index of the Semaphore table entry in the Per Process Resource Table entry. /*Attach the semaphore to the process.*/ Switch back to the user stack by resoring the USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return the Per-process Resource Table entry index. /* Semaphore Descriptor */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Semrelease system call \u00b6 Arguments \u00b6 Semaphore Descriptor (Integer) Return Value \u00b6 0 Success -1 Semaphore Descriptor is invalid Description \u00b6 This system call is used to release a semaphore descriptor held by the process. Data Structures updated are Per Process Resource Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Control flow diagram for *Semrelease* system call Algorithm \u00b6 Set the MODE_FLAG in the Process Table to 18 and switch to kernel stack. If Semaphore descriptor is not valid or the entry in the Per Process Resource Table is not valid, return -1. /* The descriptor is invalid if not in the range 0 - 7, or if the resource identifier field of the table entry is not 1 */ Invoke the release_semaphore() function in the Resource Manager Module. Invalidate the Per-Process resource table entry. /* Set to -1 */ Switch back to the user stack by restoring the USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. SemLock system call \u00b6 Arguments \u00b6 Semaphore Descriptor (Integer) Return Value \u00b6 0 Success or the semaphore is already locked by the current process -1 Semaphore Descriptor is invalid Description \u00b6 This system call is used to lock the semaphore. If the semaphore is already locked by some other process, then the calling process goes to sleep and wakes up only when the semaphore is unlocked. Otherwise, it locks the semaphore and continues execution. Data Structures updated are Process Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Algorithm \u00b6 Set the MODE_FLAG in the Process Table to 19 and switch to kernel stack. If Semaphore descriptor is not valid or the entry in the Per Process Resource Table is not valid, return -1. /* The descriptor is invalid if not in the range 0 - 7, or if the resource identifier field of the table entry is not 1 */ while the semaphore is locked by a process other than the current process do /* Check the Locking PID field in the Semaphore table */ Change the state of the current process to ( WAIT_SEMAPHORE , Semaphore table index of the locked semaphore). Invoke the switch_context() function in the Scheduler Module . endwhile /* Reaches here when the semaphore becomes free for locking */ Change the Locking PID to PID of the current process in the Semaphore Table . Reset the mode flag in the Process Table to 0 and switch back to the user stack. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. SemUnLock system call \u00b6 Arguments \u00b6 Semaphore Descriptor (Integer) Return Value \u00b6 0 Success -1 Semaphore Descriptor is invalid -2 Semaphore was not locked by the calling process Description \u00b6 This system call is used to unlock a semaphore that was previously locked by the calling process. It wakes up all the processes which went to sleep trying to lock the semaphore while the semaphore was locked by the calling process. Data Structures updated are Process Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Algorithm \u00b6 Set the MODE_FLAG in the Process Table to 20 and switch to kernel stack. If Semaphore descriptor is not valid or the entry in the Per Process Resource Table is not valid, return -1. /* The descriptor is invalid if not in the range 0 - 7, or if the resource identifier field of the table entry is not 1 */ If semaphore is locked. /* Check the Locking PID in the Semaphore table */ If current process has not locked the semaphore, return -2. /* The semaphore is locked by some other process.*/ Set the Locking PID to -1. /* Unlock the semaphore. */ Loop through the process table and change the state to (READY, _ ) for all the processes in the state ( WAIT_SEMAPHORE , Semaphore table index of the locked semaphore). Reset the MODE_FLAG in the Process Table to 0 and switch back to the user stack. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Semaphore Algorithms"},{"location":"os-design/semaphore-algos/#semget-system-call","text":"","title":"Semget system call"},{"location":"os-design/semaphore-algos/#argument","text":"None","title":"Argument"},{"location":"os-design/semaphore-algos/#return-value","text":"Value Description SEMID (Integer) Success, returns a semaphore descriptor(SEMID) -1 Process has reached its limit of resources -2 Number of semaphores has reached its maximum","title":"Return Value"},{"location":"os-design/semaphore-algos/#description","text":"This system call is used to obtain a binary semaphore . eXpOS has a fixed number of semaphores. The semaphores of a process are shared with it's child processes. Data Structures updated are Per Process Resource Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and must be reset before exiting from the system call. Control flow diagram for *Semget* system call","title":"Description"},{"location":"os-design/semaphore-algos/#algorithm","text":"Set the MODE_FLAG in the Process Table to 17 and switch to kernel stack. Find the index of a free entry in the Per Process Resource Table . /* This will be our semaphore descriptor */ If no free entry, then return -1. Resource Identifier field of the per-process resource table entry is set to 1 to indicate that the resource is a semaphore. Acquire a semaphore by calling the acquire_semaphore() function in the Resource Manager Module. /* acquire_semaphore() module function acquires a semaphore by making an entry in the Semaphore Table and returns the index of the entry. If there are no free semaphores, it returns -1 */ If there are no free semaphores, return -2. Store the index of the Semaphore table entry in the Per Process Resource Table entry. /*Attach the semaphore to the process.*/ Switch back to the user stack by resoring the USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return the Per-process Resource Table entry index. /* Semaphore Descriptor */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/semaphore-algos/#semrelease-system-call","text":"","title":"Semrelease system call"},{"location":"os-design/semaphore-algos/#arguments","text":"Semaphore Descriptor (Integer)","title":"Arguments"},{"location":"os-design/semaphore-algos/#return-value_1","text":"0 Success -1 Semaphore Descriptor is invalid","title":"Return Value"},{"location":"os-design/semaphore-algos/#description_1","text":"This system call is used to release a semaphore descriptor held by the process. Data Structures updated are Per Process Resource Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Control flow diagram for *Semrelease* system call","title":"Description"},{"location":"os-design/semaphore-algos/#algorithm_1","text":"Set the MODE_FLAG in the Process Table to 18 and switch to kernel stack. If Semaphore descriptor is not valid or the entry in the Per Process Resource Table is not valid, return -1. /* The descriptor is invalid if not in the range 0 - 7, or if the resource identifier field of the table entry is not 1 */ Invoke the release_semaphore() function in the Resource Manager Module. Invalidate the Per-Process resource table entry. /* Set to -1 */ Switch back to the user stack by restoring the USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/semaphore-algos/#semlock-system-call","text":"","title":"SemLock system call"},{"location":"os-design/semaphore-algos/#arguments_1","text":"Semaphore Descriptor (Integer)","title":"Arguments"},{"location":"os-design/semaphore-algos/#return-value_2","text":"0 Success or the semaphore is already locked by the current process -1 Semaphore Descriptor is invalid","title":"Return Value"},{"location":"os-design/semaphore-algos/#description_2","text":"This system call is used to lock the semaphore. If the semaphore is already locked by some other process, then the calling process goes to sleep and wakes up only when the semaphore is unlocked. Otherwise, it locks the semaphore and continues execution. Data Structures updated are Process Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call.","title":"Description"},{"location":"os-design/semaphore-algos/#algorithm_2","text":"Set the MODE_FLAG in the Process Table to 19 and switch to kernel stack. If Semaphore descriptor is not valid or the entry in the Per Process Resource Table is not valid, return -1. /* The descriptor is invalid if not in the range 0 - 7, or if the resource identifier field of the table entry is not 1 */ while the semaphore is locked by a process other than the current process do /* Check the Locking PID field in the Semaphore table */ Change the state of the current process to ( WAIT_SEMAPHORE , Semaphore table index of the locked semaphore). Invoke the switch_context() function in the Scheduler Module . endwhile /* Reaches here when the semaphore becomes free for locking */ Change the Locking PID to PID of the current process in the Semaphore Table . Reset the mode flag in the Process Table to 0 and switch back to the user stack. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/semaphore-algos/#semunlock-system-call","text":"","title":"SemUnLock system call"},{"location":"os-design/semaphore-algos/#arguments_2","text":"Semaphore Descriptor (Integer)","title":"Arguments"},{"location":"os-design/semaphore-algos/#return-value_3","text":"0 Success -1 Semaphore Descriptor is invalid -2 Semaphore was not locked by the calling process","title":"Return Value"},{"location":"os-design/semaphore-algos/#description_3","text":"This system call is used to unlock a semaphore that was previously locked by the calling process. It wakes up all the processes which went to sleep trying to lock the semaphore while the semaphore was locked by the calling process. Data Structures updated are Process Table and Semaphore table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call.","title":"Description"},{"location":"os-design/semaphore-algos/#algorithm_3","text":"Set the MODE_FLAG in the Process Table to 20 and switch to kernel stack. If Semaphore descriptor is not valid or the entry in the Per Process Resource Table is not valid, return -1. /* The descriptor is invalid if not in the range 0 - 7, or if the resource identifier field of the table entry is not 1 */ If semaphore is locked. /* Check the Locking PID in the Semaphore table */ If current process has not locked the semaphore, return -2. /* The semaphore is locked by some other process.*/ Set the Locking PID to -1. /* Unlock the semaphore. */ Loop through the process table and change the state to (READY, _ ) for all the processes in the state ( WAIT_SEMAPHORE , Semaphore table index of the locked semaphore). Reset the MODE_FLAG in the Process Table to 0 and switch back to the user stack. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/shutdown/","text":"Arguments \u00b6 None Return Value \u00b6 -1 on error or NIL Description \u00b6 The shut down system call is used to halt the system. It can be invoked only from shell of the root user. It terminates all the running processes, commits back the disk data (inode table, disk free list, root file, user table and dirty disk buffers) and halts the system. Control flow diagram for Shutdown system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 21, indicating that the process is in the shutdown system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If the current process is not the shell, return -1. /* Shell process has the PID 2 */ If the current user is not the root, return -1. Kill all user processes except the idle, login and the current process(shell) by calling the kill_all() function in the Process Manager module. Loop through the Buffer Table If the buffer is dirty Commit changes to the disk by calling the disk_store() function in the Device Manager module. Commit the inode table, root file, user table and disk free list to the disk by calling the disk_store() function in the Device Manager Module. Halt the system.","title":"Shutdown"},{"location":"os-design/shutdown/#arguments","text":"None","title":"Arguments"},{"location":"os-design/shutdown/#return-value","text":"-1 on error or NIL","title":"Return Value"},{"location":"os-design/shutdown/#description","text":"The shut down system call is used to halt the system. It can be invoked only from shell of the root user. It terminates all the running processes, commits back the disk data (inode table, disk free list, root file, user table and dirty disk buffers) and halts the system. Control flow diagram for Shutdown system call","title":"Description"},{"location":"os-design/shutdown/#algorithm","text":"Set the MODE_FLAG in the process table entry to 21, indicating that the process is in the shutdown system call. //Switch to the Kernel Stack. see kernel stack management during system calls Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If the current process is not the shell, return -1. /* Shell process has the PID 2 */ If the current user is not the root, return -1. Kill all user processes except the idle, login and the current process(shell) by calling the kill_all() function in the Process Manager module. Loop through the Buffer Table If the buffer is dirty Commit changes to the disk by calling the disk_store() function in the Device Manager module. Commit the inode table, root file, user table and disk free list to the disk by calling the disk_store() function in the Device Manager Module. Halt the system.","title":"Algorithm"},{"location":"os-design/stack-interrupt/","text":"This document is a tutorial explaining how the eXpOS kernel must manage the kernel stack during events such as a hardware interrupt or an exception. The document is specific to the implementation of eXpOS on the XSM machine. A hardware interrupt/exception can occur while an application program is executing.Since the application does not have control over the transfer to the interrupt module, it would not have saved its context. Thus in this case the Interrupt Service Routine must save the register context of the application in the kernel stack of the current process, perform the required operations and must restore the context before returning to the application. The kernel stack is used to store the execution context of the user process. (The backup and restore instructions of the XSM machine facilitate this). Actions done by the XSM machine on receiving an interrupt/ exception \u00b6 On Receiving an interrupt or exception, the XSM machine does 3 things: Pushes the return address (IP+2 value) to the user stack. Switches mode of execution from user to kernel. Transfers the control to the Interrut Service Routine or Exception Handler Execution context just after interrupt/exception: Note 1.The page number of the user area page is stored in the UArea Page Number field in the process table. 2.The offset of SP register within the user area page will be stored (and not the physical address of the kernel stack pointer) in the field of the process table. The purpose of storing the offset (instead of the physical address) in the KPTR field is to allow the OS to relocate the user area page to another physical memory page. On entering a kernel module from the user process, the kernel stack will be empty and hence KTPR will be 0. 3.When executing in user mode, the kernel stack is empty and hence the KPTR value is assumed to be zero. 1. Actions done by the kernel upon entering the interrupt service routine \u00b6 Switch from the user stack to the kernel stack. This involves storing the value of SP to UPTR field of the Process Table entry and setting the value of SP to User Area Page Number * 512 -1 as kernel stack is assumed to be empty on entering a kernel module from user process. Save the values of the machine registers in the kernel stack using BACKUP machine instruction. Continue execution of the interrupt routine code Pseudo code .... MOV UPTR, SP // Save the current SP register to User stack pointer field of the process table. MOV SP, User Area Page Number*512 - 1 // Set kernel stack (Note: Registers should not be used explicitly here for calculations as they are not backed up yet.) Fig.1.a. - Switch from the user stack to the kernel stack Pseudo code .... BACKUP // machine instruction to save the register context .... Fig.1.b - Use the BACKUP machine instruction to save the values of the machine registers in the kernel stack. 2. Actions done by the kernel before returning from the interrupt routine \u00b6 Restore the values of the machine registers using RESTORE machine instruction Set the value of SP to the top of the user stack Transfer control back to the user process Pseudo code .... RESTORE // machine instruction to restore the register context .... Fig.2.a - Use the RESTORE machine instruction to restore the values of the machine registers Pseudo code .... MOV SP, UPTR // point SP to the user stack IRET // return to the user process .... (Note: Again, registers should not be used explicitly in the calculations as it will overwrite the restored register context) Fig.3. - Switch the stack and transfer the control back to the user process Note If an exception is caused by error conditions ( such as stack overflow, invalid stack pointer value, arithmetic exceptions etc.), the user program will be terminated. This is not dealt with in this tutorial. However the procedure described above should be followed while handling page fault exception (since this does not result in termination of the user program).","title":"During Hardware interrupts or exceptions"},{"location":"os-design/stack-interrupt/#actions-done-by-the-xsm-machine-on-receiving-an-interrupt-exception","text":"On Receiving an interrupt or exception, the XSM machine does 3 things: Pushes the return address (IP+2 value) to the user stack. Switches mode of execution from user to kernel. Transfers the control to the Interrut Service Routine or Exception Handler Execution context just after interrupt/exception: Note 1.The page number of the user area page is stored in the UArea Page Number field in the process table. 2.The offset of SP register within the user area page will be stored (and not the physical address of the kernel stack pointer) in the field of the process table. The purpose of storing the offset (instead of the physical address) in the KPTR field is to allow the OS to relocate the user area page to another physical memory page. On entering a kernel module from the user process, the kernel stack will be empty and hence KTPR will be 0. 3.When executing in user mode, the kernel stack is empty and hence the KPTR value is assumed to be zero.","title":"Actions done by the XSM machine on receiving an interrupt/ exception"},{"location":"os-design/stack-interrupt/#1-actions-done-by-the-kernel-upon-entering-the-interrupt-service-routine","text":"Switch from the user stack to the kernel stack. This involves storing the value of SP to UPTR field of the Process Table entry and setting the value of SP to User Area Page Number * 512 -1 as kernel stack is assumed to be empty on entering a kernel module from user process. Save the values of the machine registers in the kernel stack using BACKUP machine instruction. Continue execution of the interrupt routine code Pseudo code .... MOV UPTR, SP // Save the current SP register to User stack pointer field of the process table. MOV SP, User Area Page Number*512 - 1 // Set kernel stack (Note: Registers should not be used explicitly here for calculations as they are not backed up yet.) Fig.1.a. - Switch from the user stack to the kernel stack Pseudo code .... BACKUP // machine instruction to save the register context .... Fig.1.b - Use the BACKUP machine instruction to save the values of the machine registers in the kernel stack.","title":"1. Actions done by the kernel upon entering the interrupt service routine"},{"location":"os-design/stack-interrupt/#2-actions-done-by-the-kernel-before-returning-from-the-interrupt-routine","text":"Restore the values of the machine registers using RESTORE machine instruction Set the value of SP to the top of the user stack Transfer control back to the user process Pseudo code .... RESTORE // machine instruction to restore the register context .... Fig.2.a - Use the RESTORE machine instruction to restore the values of the machine registers Pseudo code .... MOV SP, UPTR // point SP to the user stack IRET // return to the user process .... (Note: Again, registers should not be used explicitly in the calculations as it will overwrite the restored register context) Fig.3. - Switch the stack and transfer the control back to the user process Note If an exception is caused by error conditions ( such as stack overflow, invalid stack pointer value, arithmetic exceptions etc.), the user program will be terminated. This is not dealt with in this tutorial. However the procedure described above should be followed while handling page fault exception (since this does not result in termination of the user program).","title":"2. Actions done by the kernel before returning from the interrupt routine"},{"location":"os-design/stack-module/","text":"Parts of the eXpOS kernel that implements code for certain standard repetitive tasks like scheduling, managing resources, buffer etc. are implemented as separate subroutines called modules. A module may take several arguments and has a single return value. A module is always invoked from some kernel routine like an interrupt/exception handler or some other module. Modules cannot be invoked by a program executing in the user mode. When a kernel routine invokes a module, the return address from the module gets pushed into the currently active kernel stack. The functional and interface design of eXpOS modules are presented here . SPL lays down programming conventions regarding the invocation and programming of kernel modules. The SPL module programming conventions (see Case c) documentation describes these conventions. A kernel module or an interrupt service routine can invoke another kernel module while it is executing. The invoked kernel module also uses the same kernel stack. Since the invocation is voluntary, execution context of the caller should be saved in its kernel stack before transferring control to the invoked kernel module. The arguments to the kernel module are passed through the registers R1, R2 , etc. The return value will be stored in register R0. Before returning control to the caller, the invoked module pops off the space used during its execution, from the stack. The caller restores the register context upon return before resuming its execution. Note RET instruction is used instead of IRET to return back to the kernel module. 1. Actions done by caller before a call to the kernel module \u00b6 Save the registers in use to the kernel stack Store the arguments argument_1, argument_2, argument_3,... to R1, R2, ... respectively. Transfer control to the kernel module to be executed Pseudo code .... // save the registers in use MOV R0, argument\\_1 MOV R1, argument\\_2 MOV R2, argument\\_3 ... // store the arguments CALL MODULE\\_N // invoke the kernel module .... Fig.1. - Save the registers in use to the kernel stack, store the values of arguments to registers R0, R1, R2,.. in that order and transfer control to the kernel module to be executed 2. Actions done by the kernel module before return \u00b6 Store the return value to R0. Pop off the space used during its execution from the kernel stack Use RET instruction to transfer control back to the kernel module which invoked it Pseudo code .... // pop off the space used during its execution // Move the return value to R0 RET // return control to the module which invoked it Fig.2. - Actions done by the kernel module before returning. 3. Actions done by the caller after returning from the kernel module \u00b6 Save the return value (present in R0) to a desired location, if necessary Restore the values of the registers in use from the kernel stack","title":"During Module calls"},{"location":"os-design/stack-module/#1-actions-done-by-caller-before-a-call-to-the-kernel-module","text":"Save the registers in use to the kernel stack Store the arguments argument_1, argument_2, argument_3,... to R1, R2, ... respectively. Transfer control to the kernel module to be executed Pseudo code .... // save the registers in use MOV R0, argument\\_1 MOV R1, argument\\_2 MOV R2, argument\\_3 ... // store the arguments CALL MODULE\\_N // invoke the kernel module .... Fig.1. - Save the registers in use to the kernel stack, store the values of arguments to registers R0, R1, R2,.. in that order and transfer control to the kernel module to be executed","title":"1. Actions done by caller before a call to the kernel module"},{"location":"os-design/stack-module/#2-actions-done-by-the-kernel-module-before-return","text":"Store the return value to R0. Pop off the space used during its execution from the kernel stack Use RET instruction to transfer control back to the kernel module which invoked it Pseudo code .... // pop off the space used during its execution // Move the return value to R0 RET // return control to the module which invoked it Fig.2. - Actions done by the kernel module before returning.","title":"2. Actions done by the kernel module before return"},{"location":"os-design/stack-module/#3-actions-done-by-the-caller-after-returning-from-the-kernel-module","text":"Save the return value (present in R0) to a desired location, if necessary Restore the values of the registers in use from the kernel stack","title":"3. Actions done by the caller after returning from the kernel module"},{"location":"os-design/stack-smcall/","text":"This document is a tutorial explaining how the eXpOS kernel must manage the kernel stack during system calls. The document is specific to the implementation of eXpOS on the XSM machine. Since the user program has control over the transfer to the system call module, it is expected to save its register context (in the user stack) before the system call and restore the context after returing from the system call. The application program must also pass the parameters to the system call through the user stack. The return value of the system call is also passed back to the application through the user stack. For the calling conventions followed in eXpOS, see ABI . If the application program is written in ExpL, then the ExpL compiler will generate code for saving and restoring the context and pushing arguments into the user stack (if you are writing directly in assembly language, then your code must explicitly contain the code to do these). The system call module must be designed so as to access these arguments from the user stack of the process, do the processing required and store the return value into the appropriate location in the user stack before returning to the user mode. The system call module must also change the stack to its kernel stack upon entry and switch back to the user stack at the time of return. Note The algorithms described in the design page stipulates that each system call sets the MODE flag to the appropriate system call number and switches to the kernel stack. However, if the same (software) interrupt contains multiple system calls, code duplication can be avoided by setting the MODE flag and switching to kernel stack immediately upon entry into the interrupt handler, before control is transferred to the appropriate system call function. The interrupt handler can reset the MODE flag and switch back to the user stack after return from the system call function, before returning to user mode. 1. Actions done by the user process before executing an INT instruction \u00b6 Push the registers in use to the stack Push the system call number into the stack Push the arguments Push an empty space for the return value Invoke the INT machine instruction corresponding to the system call Pseudo code .... // Code to push registers PUSH System\\_Call\\_Number // Push system call number PUSH Argument\\_1 // Push the arguments to the stack PUSH Argument\\_2 PUSH Argument\\_3 PUSH R0 // Push an empty space for return value INT number // Invoke the corresponding INT instruction Note The XSM Machine, on execution of INT instruction, pushes the return adress (IP + 2 value) on to the user stack.* 2. Actions done by the System call service routine upon entry \u00b6 Extract the system call number and the arguments from the user stack. Set the MODE field in process table entry of the process to the system call number. Switch from the user stack to the kernel stack. Identify the system call using the system call number and transfer control to the system call code Pseudo code ... syscallNumber < - address\\_translate(UserSP - 5); Argument\\_1 < - address\\_translate(UserSP - 4); Argument\\_2 < - address\\_translate(UserSP - 3); Argument\\_3 < - address\\_translate(UserSP - 2); // Switching the stack UPTR < - UserSP SP < - User Area Page Number * 512 - 1 ... 3. Actions done by the System call service routine before returning from the system call \u00b6 Store the return value in the user stack Set the stack pointer (SP) to top of the user stack Set the MODE field in process table entry of the current process to 0. Return to the user program using the IRET machine instruction Pseudo code .... // store the return value in the space alloted in the user stack Address\\_RetVal < - address\\_translate(UPTR - 1); [Address\\_RetVal] < - return value // move the value of User Stack Pointer TO SP MOV SP, UPTR // return to the user program IRET Note Note that the figure shows the KPTR pointing to top of the kernel stack. However, we have not written any code to set the value of KPTR. This is because the kernel stack is assumed to be empty on entering a kerenl module from the user mode. Therefore, when the kernel mode is entered the next time, SP will be initialised to point to the beginning of the kernel stack. 4. Actions done by the process after returning from a system call \u00b6 Save the return value Pop off the arguments and the system call number from the stack Restore the register context and resume execution. Pseudo code .... POP R0 // Pop and save the return value POP Argument\\_3 POP Argument\\_2 POP Argument\\_1 // Pop and discard the arguments POP System\\_Call\\_Number // Pop and discard the system call number .... // Code to restore the register context and resume execution","title":"During System Calls"},{"location":"os-design/stack-smcall/#1-actions-done-by-the-user-process-before-executing-an-int-instruction","text":"Push the registers in use to the stack Push the system call number into the stack Push the arguments Push an empty space for the return value Invoke the INT machine instruction corresponding to the system call Pseudo code .... // Code to push registers PUSH System\\_Call\\_Number // Push system call number PUSH Argument\\_1 // Push the arguments to the stack PUSH Argument\\_2 PUSH Argument\\_3 PUSH R0 // Push an empty space for return value INT number // Invoke the corresponding INT instruction Note The XSM Machine, on execution of INT instruction, pushes the return adress (IP + 2 value) on to the user stack.*","title":"1. Actions done by the user process before executing an INT instruction"},{"location":"os-design/stack-smcall/#2-actions-done-by-the-system-call-service-routine-upon-entry","text":"Extract the system call number and the arguments from the user stack. Set the MODE field in process table entry of the process to the system call number. Switch from the user stack to the kernel stack. Identify the system call using the system call number and transfer control to the system call code Pseudo code ... syscallNumber < - address\\_translate(UserSP - 5); Argument\\_1 < - address\\_translate(UserSP - 4); Argument\\_2 < - address\\_translate(UserSP - 3); Argument\\_3 < - address\\_translate(UserSP - 2); // Switching the stack UPTR < - UserSP SP < - User Area Page Number * 512 - 1 ...","title":"2. Actions done by the System call service routine upon entry"},{"location":"os-design/stack-smcall/#3-actions-done-by-the-system-call-service-routine-before-returning-from-the-system-call","text":"Store the return value in the user stack Set the stack pointer (SP) to top of the user stack Set the MODE field in process table entry of the current process to 0. Return to the user program using the IRET machine instruction Pseudo code .... // store the return value in the space alloted in the user stack Address\\_RetVal < - address\\_translate(UPTR - 1); [Address\\_RetVal] < - return value // move the value of User Stack Pointer TO SP MOV SP, UPTR // return to the user program IRET Note Note that the figure shows the KPTR pointing to top of the kernel stack. However, we have not written any code to set the value of KPTR. This is because the kernel stack is assumed to be empty on entering a kerenl module from the user mode. Therefore, when the kernel mode is entered the next time, SP will be initialised to point to the beginning of the kernel stack.","title":"3. Actions done by the System call service routine before returning from the system call"},{"location":"os-design/stack-smcall/#4-actions-done-by-the-process-after-returning-from-a-system-call","text":"Save the return value Pop off the arguments and the system call number from the stack Restore the register context and resume execution. Pseudo code .... POP R0 // Pop and save the return value POP Argument\\_3 POP Argument\\_2 POP Argument\\_1 // Pop and discard the arguments POP System\\_Call\\_Number // Pop and discard the system call number .... // Code to restore the register context and resume execution","title":"4. Actions done by the process after returning from a system call"},{"location":"os-design/state-diag/","text":"Process State Transition Diagram in eXpOS \u00b6 The state transitions that a process in eXpOS can undergo are shown in the following diagram. The events that cause each transition are explained below the diagram. The events that cause the transitions: A : CREATED -> RUNNING: The Scheduler has scheduled the process for execution for the first time. B : RUNNING -> WAIT_TERMINAL : The process is either waiting for access to the terminal or for data to be inputted through terminal. RUNNING -> WAIT_DISK : The process is either waiting for access to the disk or for the disk operation to finish. C : RUNNING -> WAIT_SEMAPHORE : The semaphore which the process is trying to use, is found to be locked. RUNNING -> WAIT_FILE : The file which the process is trying to read/write, is found to be locked. RUNNING -> WAIT_BUFFER : The buffer which the process is trying to use, is found to be locked. RUNNING -> WAIT_MEM : The process requires a free memory page but there are none in the memory. D : RUNNING -> WAIT_PROCESS : The process is waiting for another process to either exit or to signal it. E : RUNNING -> TERMINATED: The process has either completed execution or has invoked an Exit System Call. F : WAIT_SEMAPHORE -> READY : The semaphore for which the process was waiting, is now unlocked. WAIT_FILE -> READY : The file for which the process was waiting, is now unlocked. WAIT_BUFFER -> READY : The buffer for which the process was waiting, is now unlocked. WAIT_MEM -> READY : There are free pages in memory. G : WAIT_TERMINAL -> READY : The input data has been read from terminal and terminal is free to be used by any process. WAIT_DISK -> READY : The disk operation is complete. H : WAIT_PROCESS -> READY : The process has either received a signal from the process it was waiting for or the latter has exited the system. I : RUNNING -> READY : Context switch caused by the timer interrupt routine. J : READY -> RUNNING : The Scheduler has scheduled the process for execution. K : ALLOCATED -> CREATED : When a PCB entry is allocated for a process that is being newly created by the Fork system call, its state is set to ALLOCATED. The state is changed to CREATED, once the Fork system call completes the creation of the process. Note The process can go from any state other than running state to the swapped state. A process, once swapped out will not be be swapped back into memory unless it's state becomes READY. Note A process may be unexpectredly TERMINATED due to various reasons like exceptions, logout, shutdown etc.","title":"Process State Diagram"},{"location":"os-design/state-diag/#process-state-transition-diagram-in-expos","text":"The state transitions that a process in eXpOS can undergo are shown in the following diagram. The events that cause each transition are explained below the diagram. The events that cause the transitions: A : CREATED -> RUNNING: The Scheduler has scheduled the process for execution for the first time. B : RUNNING -> WAIT_TERMINAL : The process is either waiting for access to the terminal or for data to be inputted through terminal. RUNNING -> WAIT_DISK : The process is either waiting for access to the disk or for the disk operation to finish. C : RUNNING -> WAIT_SEMAPHORE : The semaphore which the process is trying to use, is found to be locked. RUNNING -> WAIT_FILE : The file which the process is trying to read/write, is found to be locked. RUNNING -> WAIT_BUFFER : The buffer which the process is trying to use, is found to be locked. RUNNING -> WAIT_MEM : The process requires a free memory page but there are none in the memory. D : RUNNING -> WAIT_PROCESS : The process is waiting for another process to either exit or to signal it. E : RUNNING -> TERMINATED: The process has either completed execution or has invoked an Exit System Call. F : WAIT_SEMAPHORE -> READY : The semaphore for which the process was waiting, is now unlocked. WAIT_FILE -> READY : The file for which the process was waiting, is now unlocked. WAIT_BUFFER -> READY : The buffer for which the process was waiting, is now unlocked. WAIT_MEM -> READY : There are free pages in memory. G : WAIT_TERMINAL -> READY : The input data has been read from terminal and terminal is free to be used by any process. WAIT_DISK -> READY : The disk operation is complete. H : WAIT_PROCESS -> READY : The process has either received a signal from the process it was waiting for or the latter has exited the system. I : RUNNING -> READY : Context switch caused by the timer interrupt routine. J : READY -> RUNNING : The Scheduler has scheduled the process for execution. K : ALLOCATED -> CREATED : When a PCB entry is allocated for a process that is being newly created by the Fork system call, its state is set to ALLOCATED. The state is changed to CREATED, once the Fork system call completes the creation of the process. Note The process can go from any state other than running state to the swapped state. A process, once swapped out will not be be swapped back into memory unless it's state becomes READY. Note A process may be unexpectredly TERMINATED due to various reasons like exceptions, logout, shutdown etc.","title":"Process State Transition Diagram in eXpOS"},{"location":"os-design/sw-interface/","text":"INT 4 to INT 18 are software interrupt handlers. They are used by the user program to access kernel services (e.g. Read from a file, fork a child process etc). The OS design is fixed such that only the user program can call the software interrupts. They should not be called from inside another interrupt handler or kernel module. The system call interface is presented below. System Call System Call Number Interrupt Routine Number Argument 1 Argument 2 Argument 3 Return Value Create 1 4 File Name (String) Permission (Integer) * - 0 - Success / File alredy exists -1 - No free inode table entry Delete 4 4 File Name (String) - - 0 - Success/File not found -1 - Permission denied -2 - File is open Seek 6 5 File Descriptor Offset - 0 - Success -1 - File Descriptor is invalid -2 - Offset moves File pointer outside file Open 2 5 File Name - - File Descriptor - Success -1 - File Not found or file is not data file or root file -2 - System has reached its limit of open files -3 - Process has reached its limit of resources Close 3 5 File Descriptor - - 0 - Success -1 - File Descriptor is invalid Read 7 6 File Descriptor (-1 for terminal read) Word Address (Buffer) - 0 - Success -1 - File Descriptor given is invalid -2 - File pointer has reached the end of file Write 5 7 File Descriptor(-2 for terminal write) Word to write - 0 - Success -1 - File Descriptor given is invalid -2 - No disk space / File Full -3 - Permission denied Fork 8 8 - - - PID - Success (in parent process) 0 - Success (in child process) -1 - Failure (in parent process), Number of processes has reached maximum limit Exec 9 9 File Name - - -1 - File not found or file is not executable Exit 10 10 - - - - Getpid 11 11 - - - current PID - Success Getppid 12 11 - - - parent PID - Success Wait 13 11 PID - - 0 - Success -1 - Given PID is invalid or it is PID of invoking process Signal 14 11 - - - 0 - Success Semget 17 13 - - - SEMID - Success -1 - Process has reached its limit of resources -2 - Number of semaphores has reached its maximum Semrelease 18 13 SEMID - - 0 - Success -1 - Invalid SEMID SemLock 19 14 SEMID - - 0 - Success or semaphore is already locked by the current process -1 - invalid SEMID SemUnLock 20 14 SEMID - - 0 - Success -1 - Invalid SEMID -2 - Semaphore was not locked by the calling process Shutdown 21 15 - - - -1 - Permission denied Newusr 22 16 User Name Password - 0 - Success -1 - User already exists -2 - Permission denied -3 - No. of users have reached the system limit. Remusr 23 16 User Name - - 0 - Success -1 - User does not exist -2 - Permission denied -3 - Undeleted files exist for the user Setpwd 24 16 User Name New password - 0 - Success -1 - Unauthorised attempt to change password -2 - The user does not exist. Getuname 25 16 User ID - - User Name - Success -1 - Invalid User ID Getuid 26 16 User Name - - User ID - Success -1 - Invalid username Login 27 17 User Name Password - 0 - Success -1 - Invalid username or password -2 - Permission denied Logout 28 12 - - - -1 - permission denied Test0 96 18 - - - - Test1 97 18 - - - - Test2 98 18 - - - - Test3 99 18 - - - - Test4 ** 100 19 - - - - Test5 ** 101 19 - - - - Test6 ** 102 19 - - - - Test7 ** 103 19 - - - - * If the file is created with permission set to EXCLUSIVE , then write and delete system calls will fail when executed by any user other than the owner or the root (see here ). ** These System Calls are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine.","title":"Low Level System Call Interface"},{"location":"os-design/synchronization-algos/","text":"Wait system call \u00b6 Arguments \u00b6 Process Identifier of the process for which the current process has to wait. Return Values \u00b6 0 Success -1 Given process identifier is invalid or it is the pid of the same process invoking wait Description \u00b6 The current process is blocked till the process with PID given as argument executes a Signal system call or exits. The system call will fail if a process attempts to wait for itself. The only data structure updated is Process Table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 13. Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If process is intending to wait for itself or for a non-existent process, return -1. /* Check the status from Process table. */ Change the status from (RUNNING,_ ) to (WAIT_PROCESS, Argument_PID ) in the Process Table . Invoke the Scheduler by calling the switch_context() function in the Scheduler Module . /* The following code excutes only when scheduled again after the occurance of a signal/exit of the process waiting for. */ Restore SP to the USER SP stored in the process table. Reset the MODE_FLAG in the process table entry to 0. Return 0. /* Success */ Note: At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Signal system call \u00b6 Arguments \u00b6 None Return Value: \u00b6 0 Success Description \u00b6 All processes waiting for the signalling process are resumed. The system call does not fail. The only data structure updated is Process Table .The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call. Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 14. Wake up all processes waiting for the current process. Traverse through the Process Table If the process is in state ( WAIT_PROCESS , Pid) where Pid matches with the PID of the current process. Change the status to ( READY , _ ). Reset the MODE_FLAG in the process table entry to 0. Return 0. /* Success */","title":"Synchronization Algorithms"},{"location":"os-design/synchronization-algos/#wait-system-call","text":"","title":"Wait system call"},{"location":"os-design/synchronization-algos/#arguments","text":"Process Identifier of the process for which the current process has to wait.","title":"Arguments"},{"location":"os-design/synchronization-algos/#return-values","text":"0 Success -1 Given process identifier is invalid or it is the pid of the same process invoking wait","title":"Return Values"},{"location":"os-design/synchronization-algos/#description","text":"The current process is blocked till the process with PID given as argument executes a Signal system call or exits. The system call will fail if a process attempts to wait for itself. The only data structure updated is Process Table . The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call.","title":"Description"},{"location":"os-design/synchronization-algos/#algorithm","text":"Set the MODE_FLAG in the process table entry to 13. Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If process is intending to wait for itself or for a non-existent process, return -1. /* Check the status from Process table. */ Change the status from (RUNNING,_ ) to (WAIT_PROCESS, Argument_PID ) in the Process Table . Invoke the Scheduler by calling the switch_context() function in the Scheduler Module . /* The following code excutes only when scheduled again after the occurance of a signal/exit of the process waiting for. */ Restore SP to the USER SP stored in the process table. Reset the MODE_FLAG in the process table entry to 0. Return 0. /* Success */ Note: At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack.","title":"Algorithm"},{"location":"os-design/synchronization-algos/#signal-system-call","text":"","title":"Signal system call"},{"location":"os-design/synchronization-algos/#arguments_1","text":"None","title":"Arguments"},{"location":"os-design/synchronization-algos/#return-value","text":"0 Success","title":"Return Value:"},{"location":"os-design/synchronization-algos/#description_1","text":"All processes waiting for the signalling process are resumed. The system call does not fail. The only data structure updated is Process Table .The mode flag in the Process Table has to be set to Kernel mode when the process enters the system call and reset before exiting from the system call.","title":"Description"},{"location":"os-design/synchronization-algos/#algorithm_1","text":"Set the MODE_FLAG in the process table entry to 14. Wake up all processes waiting for the current process. Traverse through the Process Table If the process is in state ( WAIT_PROCESS , Pid) where Pid matches with the PID of the current process. Change the status to ( READY , _ ). Reset the MODE_FLAG in the process table entry to 0. Return 0. /* Success */","title":"Algorithm"},{"location":"os-design/term-handler/","text":"Description \u00b6 The Read operation for terminal input, puts the process executing the operation to sleep while the input is being read. Once input data is read, the terminal device sends a hardware interrupt, which is handled by the terminal handler. The terminal handler is responsible for waking up processes that are blocked for input console. The data structures modified are Terminal Status Table and Process Table . Algorithm \u00b6 Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction. Set the status field in Terminal Status Table to 0 to indicate that the terminal is free. Using the PID field of the Terminal Status Table, locate the Process Table entry of the process that read the data. Copy the word read from the standard input to the Input Buffer field in the Process Table entry. Release lock on the terminal by calling release_terminal() function in the Resource Manager Module. Restore the register context of the process using RESTORE instruction. Restore SP to the value stored in USER_SP field of the process table entry of the process. ireturn; Question When interrupts or system calls are invloked, the mode changes from user to kernel. Registers are backed up using the BACKUP instruction in the case of interrupts and not in the case of system calls. Why?","title":"Terminal Interrupt Handler"},{"location":"os-design/term-handler/#description","text":"The Read operation for terminal input, puts the process executing the operation to sleep while the input is being read. Once input data is read, the terminal device sends a hardware interrupt, which is handled by the terminal handler. The terminal handler is responsible for waking up processes that are blocked for input console. The data structures modified are Terminal Status Table and Process Table .","title":"Description"},{"location":"os-design/term-handler/#algorithm","text":"Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction. Set the status field in Terminal Status Table to 0 to indicate that the terminal is free. Using the PID field of the Terminal Status Table, locate the Process Table entry of the process that read the data. Copy the word read from the standard input to the Input Buffer field in the Process Table entry. Release lock on the terminal by calling release_terminal() function in the Resource Manager Module. Restore the register context of the process using RESTORE instruction. Restore SP to the value stored in USER_SP field of the process table entry of the process. ireturn; Question When interrupts or system calls are invloked, the mode changes from user to kernel. Registers are backed up using the BACKUP instruction in the case of interrupts and not in the case of system calls. Why?","title":"Algorithm"},{"location":"os-design/timer-stack-management/","text":"Context switch involves switching a machine from executing one process to executing another even before the former is completed. This involves saving the state of all volatile data like registers, PTBR, BP, etc. (in other words the \"context\") and, then loading the context of a new process or starting a new process from scratch which will have its own context. This technique allows the machine to concurrently execute multiple processes. eXpOS maintains a kernel stack for each application process. Before a context switch, the context of the outgoing process must be saved into its kernel stack. The previously saved context of the incoming process must be restored from the kernel stack of that process. This document specifies how stack management has to be performed during a context switch. There are two situations that can result in a context switch: The time slice of a process executing in the user mode expires and a timer interrupt is raised. The timer interrupt routine invokes the scheduler module(MOD_5) to perform a context switch. While executing in the kernel mode (inside a system call or the exception handler), a process has to wait for some event to happen (ex: wait for a resource like disk, terminal etc) and hence voluntarily invokes the scheduler(MOD_5) to schedule itself out. Case 1 : Saving and Restoring the context during timer interrupt. The Timer ISR saves the user context of the process from which it was entered, into the kernel stack of that process. (see Kernel Stack Management during Interrupts for more details). The Timer ISR then calls the scheduler module. The scheduler module determines which process must be run next, and changes the machine's stack to the kernel stack of the new processes. This stack is expected to contain the previously saved context of the new process. The scheduler is reponsible for resuming execution of the new process. If the new process was scheduled out earlier by the timer interrupt, then the scheduler will return to the instruction in the timer interrupt after the call to the scheduler. When the timer ISR returns to the user mode, the new process will resume execution because the execution context restored by the timer ISR at the time of return to user mode will be from the kernel stack of the new process. More details will be explained below. Note: We will write the Timer ISR in such a way that it does not use any registers. So, we need not store and restore any additional kernel level context inside the timer ISR before or after invoking the scheduler module. Case 2 : Saving and Restoring the context during blocking system calls. In this case, the scheduler modules was invoked from some other kernel code - typically some blocking system call, exception handler etc. Here, it is the responsibility of the calling module/handler to save its context (registers in use) in its kernel stack before invoking the scheduler module. Later, when the scheduler returns to this handler/module, the handler/module should restore the context and resume execution. See the Kernel Stack management during module calls for more details. In spite of the above convention, the ExpL compiler fails to save the value of BP register before making a system call. To solve this problem, a patch is added to the scheduler so that the scheduler saves the current value of BP register to the kernel stack of the process being scheduled out. Scheduler Module \u00b6 The scheduler module is responsible for performing the actual context switch. Context switch happens by a change of SP, PTBR and PTLR registers. We store these register values of the old process to its Process Table and restore SP, PTBR and PTLR values from the Process Table of the new process. Important Note The offset of SP register within the user area page will be stored in the KPTR field of the process table(and not the physical address of the kernel stack pointer). The value of the offset can be calculated by the fomula offset = SP \u2013 (512 * USER AREA PAGE NUMBER) The purpose of storing the offset (instead of the physical address) is to allow the OS to relocate the user area page to another physical memory page during swapping. After switching the registers, the scheduler module executes the return instruction resulting in IP value being set from the top of the kernel stack of the new process (except for one special case which we will see below). This transfers control to the next instruction in the kernel handler/module in the new process. Actions done by the scheduler: \u00b6 1) Save register BP to the kernel stack of current process. 2) Save the current kernel stack pointer offset in the KPTR field of the process table. 3) Save the current PTBR and PTLR values in the process table of the leaving process. (This operation is redundant) 4) Find the pid of the next process to be scheduled. 5) Restore the PTBR, PTLR and kernel stack pointer (KPTR) values from the process table of the entering process. 6) Restore register BP from the top of kernel stack of entering process. 7) Identify whether the state* of the new process is a READY/CREATED from the state field of the process table. (A process that has never been scheduled for execution previously will be in CREATED state. The fork system call creates the child process in the CREATED state.) Case 1 : The new process is in READY state \u00b6 8) Compute the physical address corresponding to the offset stored in KPTR field of the process table entry of the new process, and store this to SP. ... MOV R4, User Area Page Number*512 // find the physical address of the user area page ADD R4, KPTR // find the value of the kernel stack pointer using the formula 512*user area page number + KERNEL STACK POINTER MOV SP, R4 // store the physical address of the kernel stack pointer in SP ... Fig.2.a - Setting the kernel SP from the offset value in the KPTR field of the process table. 9) return instruction is executed and control goes back to the Interrupt routine or kernel module that called the scheduler. Case 2 : The new process is in CREATED state \u00b6 8) Set SP to the address stored in the UPTR field of the process table of the new process. ... MOV SP, UPTR IRET ... Fig.2.a - Setting the kernel SP from the offset value in the KPTR field of the process table. 9) ireturn statement is executed. (In this case, the scheduler directly kicks off execution of the new process in user mode.) Note A process may invoke the scheduler for several reasons. As noted earlier as Case 1, one reason is that the time slice of the process is finished. Other possibilities (handled under Case 2) includes waiting for disk, terminal, semaphore, file etc. Before calling the scheduler a process must set the STATE field of the process table entry to indicate the correct reason for invoking the scheduler. Note that the scheduler cannot set the STATE field as only the caller will know the cause.","title":"During Context Switch"},{"location":"os-design/timer-stack-management/#scheduler-module","text":"The scheduler module is responsible for performing the actual context switch. Context switch happens by a change of SP, PTBR and PTLR registers. We store these register values of the old process to its Process Table and restore SP, PTBR and PTLR values from the Process Table of the new process. Important Note The offset of SP register within the user area page will be stored in the KPTR field of the process table(and not the physical address of the kernel stack pointer). The value of the offset can be calculated by the fomula offset = SP \u2013 (512 * USER AREA PAGE NUMBER) The purpose of storing the offset (instead of the physical address) is to allow the OS to relocate the user area page to another physical memory page during swapping. After switching the registers, the scheduler module executes the return instruction resulting in IP value being set from the top of the kernel stack of the new process (except for one special case which we will see below). This transfers control to the next instruction in the kernel handler/module in the new process.","title":"Scheduler Module"},{"location":"os-design/timer-stack-management/#actions-done-by-the-scheduler","text":"1) Save register BP to the kernel stack of current process. 2) Save the current kernel stack pointer offset in the KPTR field of the process table. 3) Save the current PTBR and PTLR values in the process table of the leaving process. (This operation is redundant) 4) Find the pid of the next process to be scheduled. 5) Restore the PTBR, PTLR and kernel stack pointer (KPTR) values from the process table of the entering process. 6) Restore register BP from the top of kernel stack of entering process. 7) Identify whether the state* of the new process is a READY/CREATED from the state field of the process table. (A process that has never been scheduled for execution previously will be in CREATED state. The fork system call creates the child process in the CREATED state.)","title":"Actions done by the scheduler:"},{"location":"os-design/timer-stack-management/#case-1-the-new-process-is-in-ready-state","text":"8) Compute the physical address corresponding to the offset stored in KPTR field of the process table entry of the new process, and store this to SP. ... MOV R4, User Area Page Number*512 // find the physical address of the user area page ADD R4, KPTR // find the value of the kernel stack pointer using the formula 512*user area page number + KERNEL STACK POINTER MOV SP, R4 // store the physical address of the kernel stack pointer in SP ... Fig.2.a - Setting the kernel SP from the offset value in the KPTR field of the process table. 9) return instruction is executed and control goes back to the Interrupt routine or kernel module that called the scheduler.","title":"Case 1 : The new process is in READY state"},{"location":"os-design/timer-stack-management/#case-2-the-new-process-is-in-created-state","text":"8) Set SP to the address stored in the UPTR field of the process table of the new process. ... MOV SP, UPTR IRET ... Fig.2.a - Setting the kernel SP from the offset value in the KPTR field of the process table. 9) ireturn statement is executed. (In this case, the scheduler directly kicks off execution of the new process in user mode.) Note A process may invoke the scheduler for several reasons. As noted earlier as Case 1, one reason is that the time slice of the process is finished. Other possibilities (handled under Case 2) includes waiting for disk, terminal, semaphore, file etc. Before calling the scheduler a process must set the STATE field of the process table entry to indicate the correct reason for invoking the scheduler. Note that the scheduler cannot set the STATE field as only the caller will know the cause.","title":"Case 2 : The new process is in CREATED state"},{"location":"os-design/timer/","text":"The hardware requirement specification for eXpOS assumes that the machine is equipped with a timer device that sends periodic hardware interrupts. The timer interrupt handler internally invokes the eXpOS scheduler module . Control flow diagram for *Timer interrupt handler* Algorithm: \u00b6 Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction. /* This code is relevant only when the Pager Module is implemented in Stage 27 */ If swapping is initiated, /* check System Status Table */ { /* Call Swap In/Out, if necessary */ if the current process is the Swapper Daemon and Paging Status is SWAP_OUT , Call the swap_out() function in the Pager Module . else if the current process is the Swapper Daemon and Paging Status is SWAP_IN , Call the swap_in() function in the Pager Module . else if the current process is Idle, /* Swapping is ongoing, but the daemon is blocked for some disk operation and idle is being run now */ /* Skip to the end to perform context switch. */ } else /* Swapping is not on now. Check whether it must be initiated */ { if (MEM_FREE_COUNT < MEM_LOW ) /* Check the System Status Table */ /* Swap Out to be invoked during next Timer Interrupt */ Set the Paging Status in System Status Table to SWAP_OUT . else if (there are swapped out processes) /* Check SWAPPED_COUNT in System Status Table */ if (Tick of any Swapped Out process > MAX_TICK or MEM_FREE_COUNT > MEM_HIGH ) /* Swap In to be invoked during next Timer Interrupt */ Set the Paging Status in System Status Table to SWAP_IN . } /* End of Stage 27 code for Swap In/Out management */ Change the state of the current process in its Process Table entry from RUNNING to READY. Loop through the process table entires and increment the TICK field of each process. Invoke the context switch module . Restore the register context of the process using RESTORE instruction. Set SP as the user SP saved in the Process Table entry of the new process. Set the MODE_FLAG in the process table entry to 0. ireturn.","title":"Timer"},{"location":"os-design/timer/#algorithm","text":"Switch to the Kernel Stack. /* See kernel stack management during system calls */ Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. Backup the register context of the current process using the BACKUP instruction. /* This code is relevant only when the Pager Module is implemented in Stage 27 */ If swapping is initiated, /* check System Status Table */ { /* Call Swap In/Out, if necessary */ if the current process is the Swapper Daemon and Paging Status is SWAP_OUT , Call the swap_out() function in the Pager Module . else if the current process is the Swapper Daemon and Paging Status is SWAP_IN , Call the swap_in() function in the Pager Module . else if the current process is Idle, /* Swapping is ongoing, but the daemon is blocked for some disk operation and idle is being run now */ /* Skip to the end to perform context switch. */ } else /* Swapping is not on now. Check whether it must be initiated */ { if (MEM_FREE_COUNT < MEM_LOW ) /* Check the System Status Table */ /* Swap Out to be invoked during next Timer Interrupt */ Set the Paging Status in System Status Table to SWAP_OUT . else if (there are swapped out processes) /* Check SWAPPED_COUNT in System Status Table */ if (Tick of any Swapped Out process > MAX_TICK or MEM_FREE_COUNT > MEM_HIGH ) /* Swap In to be invoked during next Timer Interrupt */ Set the Paging Status in System Status Table to SWAP_IN . } /* End of Stage 27 code for Swap In/Out management */ Change the state of the current process in its Process Table entry from RUNNING to READY. Loop through the process table entires and increment the TICK field of each process. Invoke the context switch module . Restore the register context of the process using RESTORE instruction. Set SP as the user SP saved in the Process Table entry of the new process. Set the MODE_FLAG in the process table entry to 0. ireturn.","title":"Algorithm:"},{"location":"os-design/write/","text":"Arguments \u00b6 File Descriptor(Integer) and the word to be written Return Value \u00b6 0 Success -1 File Descriptor given is invalid -2 No disk space / File Full -3 Permission denied Description \u00b6 The file descriptor is used to identify an open instance of the file. The Write operation writes the word given as argument to the position pointed by the file pointer of the file. After each Write operation, the file pointer advances to the next word in the file. Root file and Executable files cannot be written. In addition to this in Multiuser implementation, data files which are created with exclusive permission, cannot be written into by any user other than the owner, root or kernel. Control flow diagram for *Write* system call Algorithm \u00b6 Set the MODE_FLAG in the process table entry to 5, indicating that the process is in the write system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If the word is to be written to STDOUT (terminal device) /* indicated by a file descriptor value of -2 */ Call the terminal_write() function in the Device manager Module . Switch back to the user stack by restoring USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. /* success */ /* If not terminal, write to file. */ If file descriptor is invalid, return -1. /* File descriptor value should be within the range 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE , return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from the Per Process Resource Table entry. Get the index of the Inode Table entry from the Open File Table entry. If the current user is not root and the current user does not own the file and /* Check the process table entry */ the exclusive permission is set, return -3. Acquire the Lock on the File by calling the acquire_inode() function in the File Manager module. If acquiring the inode fails, return -1. Get the Lseek position from the Open File Table entry. If lseek position is same as the MAX_FILE_SIZE , release_inode() and return -2. /* Maximum file size of 2048 reached*/ If the Lseek position is a multiple of 512 and the same as File size in the inode table /* New block to be allocated */ Get a free disk block by calling the get_free_block() function in the Memory Manager module. If no free disk block is found release_inode() and return -2. Set the new disk block found in the corresponding (lseek / 512) disk block field in the Inode table entry. Find the disk block number and the position in the block from which input is to be written. Get the block index from lseek position. /* block index = lseek / block size (512) */ Get the disk block number corresponding to the block index from the Inode Table . Get the offset value from lseek position. /* offset = lseek % the block size (512) */ Write the word to the File Buffer by calling the buffered_write() function in the Buffer Manager module. If Lseek equals file size, increment file size in the inode table entry and also in the memory copy of the root file . Increment the Lseek position in the Open File Table entry. Release the Lock on the File by calling the release_inode() function in the Resource Manager module. Switch back to the user stack by restoring USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question 1 What happens when the \"root\" is being written into? Question 2 Which data structure constrains the max file size to 2048 words? Question 3 What modification to the file data stuctures will enable files exceeding the max file size?","title":"Write"},{"location":"os-design/write/#arguments","text":"File Descriptor(Integer) and the word to be written","title":"Arguments"},{"location":"os-design/write/#return-value","text":"0 Success -1 File Descriptor given is invalid -2 No disk space / File Full -3 Permission denied","title":"Return Value"},{"location":"os-design/write/#description","text":"The file descriptor is used to identify an open instance of the file. The Write operation writes the word given as argument to the position pointed by the file pointer of the file. After each Write operation, the file pointer advances to the next word in the file. Root file and Executable files cannot be written. In addition to this in Multiuser implementation, data files which are created with exclusive permission, cannot be written into by any user other than the owner, root or kernel. Control flow diagram for *Write* system call","title":"Description"},{"location":"os-design/write/#algorithm","text":"Set the MODE_FLAG in the process table entry to 5, indicating that the process is in the write system call. //Switch to Kernel Stack - See Kernel Stack Management during System Calls . Save the value of SP to the USER SP field in the Process Table entry of the process. Set the value of SP to the beginning of User Area Page. If the word is to be written to STDOUT (terminal device) /* indicated by a file descriptor value of -2 */ Call the terminal_write() function in the Device manager Module . Switch back to the user stack by restoring USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. /* success */ /* If not terminal, write to file. */ If file descriptor is invalid, return -1. /* File descriptor value should be within the range 0 to 7 (both included). */ Locate the Per-Process Resource Table of the current process. Find the PID of the current process from the System Status Table . Find the User Area page number from the Process Table entry. The Per-Process Resource Table is located at the RESOURCE_TABLE_OFFSET from the base of the User Area Page . If the Resource identifier field of the Per Process Resource Table entry is invalid or does not indicate a FILE , return -1. /* No file is open with this file descriptor. */ Get the index of the Open File Table entry from the Per Process Resource Table entry. Get the index of the Inode Table entry from the Open File Table entry. If the current user is not root and the current user does not own the file and /* Check the process table entry */ the exclusive permission is set, return -3. Acquire the Lock on the File by calling the acquire_inode() function in the File Manager module. If acquiring the inode fails, return -1. Get the Lseek position from the Open File Table entry. If lseek position is same as the MAX_FILE_SIZE , release_inode() and return -2. /* Maximum file size of 2048 reached*/ If the Lseek position is a multiple of 512 and the same as File size in the inode table /* New block to be allocated */ Get a free disk block by calling the get_free_block() function in the Memory Manager module. If no free disk block is found release_inode() and return -2. Set the new disk block found in the corresponding (lseek / 512) disk block field in the Inode table entry. Find the disk block number and the position in the block from which input is to be written. Get the block index from lseek position. /* block index = lseek / block size (512) */ Get the disk block number corresponding to the block index from the Inode Table . Get the offset value from lseek position. /* offset = lseek % the block size (512) */ Write the word to the File Buffer by calling the buffered_write() function in the Buffer Manager module. If Lseek equals file size, increment file size in the inode table entry and also in the memory copy of the root file . Increment the Lseek position in the Open File Table entry. Release the Lock on the File by calling the release_inode() function in the Resource Manager module. Switch back to the user stack by restoring USER SP from the process table. Set the MODE_FLAG in the process table entry of the parent process to 0. Return 0. /* success */ Note At each point of return from the system call, remember to reset the MODE FLAG and switch back to the user stack. Question 1 What happens when the \"root\" is being written into? Question 2 Which data structure constrains the max file size to 2048 words? Question 3 What modification to the file data stuctures will enable files exceeding the max file size?","title":"Algorithm"},{"location":"os-spec/","text":"Who should read this document? \u00b6 This document must be read by anyone wishing to write eXpOS application programs in a high level language or assembly language. This OS specification is prepared in a manner independent of programming language and target machine. The document is also informative for system programmers like compiler designers who wishes to write the application programmer's interface for a high level language like ExpL to be run on eXpOS. The application binary interface ABI is the must-read document for the compiler designer. Finally, this document must be read by anyone who wants to implement eXpOS on some machine because one needs to know the specification for the OS before getting started with its implementation! Introduction \u00b6 This document gives application programmer's documentation for the eXperimental Operating System (eXpOS). eXpOS is a tiny multiprogramming operating system. It has a very simple specification that allows a junior undergraduate computer science student to implement it in a few months, subject to availability of adequate hardware and programming platform support. This specification is prepared from the perspective of the user/application programmer and is not hardware specific. Assumptions about the underlying hardware features necessary for the operating system to work are discussed in the first section of this document. This document contains the following sections: Overview \u00b6 eXpOS Abstractions \u00b6 The Logical File System : eXpFS \u00b6 Process Model \u00b6 Synchronization and Access control \u00b6 Miscellaneous \u00b6 Multi-user Extension to eXpOS \u00b6 Application Programmer's Interface (API) \u00b6 High Level System Call Interface \u00b6 High Level Library Interface \u00b6 eXpOS Shell specification \u00b6","title":"Specification"},{"location":"os-spec/#who-should-read-this-document","text":"This document must be read by anyone wishing to write eXpOS application programs in a high level language or assembly language. This OS specification is prepared in a manner independent of programming language and target machine. The document is also informative for system programmers like compiler designers who wishes to write the application programmer's interface for a high level language like ExpL to be run on eXpOS. The application binary interface ABI is the must-read document for the compiler designer. Finally, this document must be read by anyone who wants to implement eXpOS on some machine because one needs to know the specification for the OS before getting started with its implementation!","title":"Who should read this document?"},{"location":"os-spec/#introduction","text":"This document gives application programmer's documentation for the eXperimental Operating System (eXpOS). eXpOS is a tiny multiprogramming operating system. It has a very simple specification that allows a junior undergraduate computer science student to implement it in a few months, subject to availability of adequate hardware and programming platform support. This specification is prepared from the perspective of the user/application programmer and is not hardware specific. Assumptions about the underlying hardware features necessary for the operating system to work are discussed in the first section of this document. This document contains the following sections:","title":"Introduction"},{"location":"os-spec/#overview","text":"","title":"Overview"},{"location":"os-spec/#expos-abstractions","text":"","title":"eXpOS Abstractions"},{"location":"os-spec/#the-logical-file-system-expfs","text":"","title":"The Logical File System : eXpFS"},{"location":"os-spec/#process-model","text":"","title":"Process Model"},{"location":"os-spec/#synchronization-and-access-control","text":"","title":"Synchronization and Access control"},{"location":"os-spec/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"os-spec/#multi-user-extension-to-expos","text":"","title":"Multi-user Extension to eXpOS"},{"location":"os-spec/#application-programmers-interface-api","text":"","title":"Application Programmer's Interface (API)"},{"location":"os-spec/#high-level-system-call-interface","text":"","title":"High Level System Call Interface"},{"location":"os-spec/#high-level-library-interface","text":"","title":"High Level Library Interface"},{"location":"os-spec/#expos-shell-specification","text":"","title":"eXpOS Shell specification"},{"location":"os-spec/dynamicmemoryroutines/","text":"High Level Library Interface \u00b6 The High Level Library Interface is a unified Application Programming Interface (API) to access system call routines and dynamic memory management functions from application programs. The ExpL language allows applications to access the OS routines only through the library interface. The syntax for the call to the library function in ExpL is : t = exposcall(fun_code, arg1, arg2, arg3); Depending on the fun_code the control is transferred to the system call routines and the dynamic memory management functions (see below) . Library Function / System Call Function Code Argument 1 Argument 2 Argument 3 Return value Create \"Create\" File Name Permission - 0 - Success/File already exists -1 - No free inode table entry Open \"Open\" File Name - - File Descriptor - Success -1 - File Not found or file is not data file or root file -2 - System has reached its limit of open files -3 - Process has reached its limit of resources Close \"Close\" File Descriptor - - 0 - Success -1 - File Descriptor is invalid Delete \"Delete\" File Name - - 0 - Success/File does not exist -1 - Permission Denied -2 - File is open Write \"Write\" File Descriptor (-2 for terminal) Word to be written - 0 - Success -1 - File Descriptor given is invalid -2 - No disk space -3 - Permission denied Read \"Read\" File Descriptor (-1 for terminal) Variable name (to which data is to be read) - 0 - Success -1 - File Descriptor given is invalid -2 - File pointer has reached the end of file Seek \"Seek\" File Descriptor Offset - 0 - Success -1 - File Descriptor is invalid -2 - Offset moves File pointer outside file Fork \"Fork\" - - - PID - Success (in parent process) 0 - Success (in child process) -1 - Failure (in parent process), Number of processes has reached maximum limit Exec \"Exec\" File Name - - -1 - File not found or file is not executable -2 - Out of memory or disk swap space Exit \"Exit\" - - - - Getpid \"Getpid\" - - - current PID - Success Getppid \"Getppid\" - - - parent PID - Success Wait \"Wait\" Process Identifier - - 0 - Success -1 - Given PID is invalid or it is PID of invoking process Signal \"Signal\" - - - 0 - Success Semget \"Semget\" - - - SEMID - Success -1 - Process has reached its limit of resources -2 - Number of semaphores has reached its maximum Semrelease \"Semrelease\" Semaphore Descriptor - - 0 - Success -1 - Invalid SEMID SemLock \"SemLock\" Semaphore Descriptor - - 0 - Success or semaphore is already locked by the current process -1 - invalid SEMID SemUnLock \"SemUnLock\" Semaphore Descriptor - - 0 - Success -1 - Invalid SEMID -2 - Semaphore was not locked by the calling process Shutdown \"Shutdown\" - - - -1 - Permission denied Newusr \"Newusr\" User name Password - 0 - Success -1 - User already exists -2 - Permission denied -3 - No. of users have reached the system limit. Remusr \"Remusr\" User name - - 0 - Success -1 - User does not exist -2 - Permission denied -3 - Undeleted files exist for the user Setpwd \"Setpwd\" User name New Password - 0 - Success -1 - Unauthorised attempt to change password -2 - The user does not exist. Getuname \"Getuname\" User ID - - User Name - Success -1 - Invalid User ID Getuid \"Getuid\" User name - - User ID - Success -1 - Invalid username Login \"Login\" User name Password - 0 - Success -1 - Invalid username or password -2 - Permission denied Logout \"Logout\" - - - -1 - permission denied Test0 \"Test0\" Unspecified Unspecified Unspecified - Test1 \"Test1\" Unspecified Unspecified Unspecified - Test2 \"Test2\" Unspecified Unspecified Unspecified - Test3 \"Test3\" Unspecified Unspecified Unspecified - Test4 \"Test4\" Unspecified Unspecified Unspecified - Test5 \"Test5\" Unspecified Unspecified Unspecified - Test6 \"Test6\" Unspecified Unspecified Unspecified - Test7 \"Test7\" Unspecified Unspecified Unspecified - Initialize \"Heapset\" - - - 0 - Success -1 - Failure Alloc \"Alloc\" Size - - Allocated address in Heap - Success -1 - No allocation Free \"Free\" Pointer - - 0 - Success -1 - Failure If the file is created with EXCLUSIVE permissions, then write and delete system calls will fail when executed by any user other than the owner or the root (see here). These System Calls are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine. Note According to syntax of exposcall(), it needs four arguments. These arguments are func_code, arg1, arg2, arg3. func_code is necessary for every exposcall() to recognize the Library function/System call. The remaining number of arguments varies according to Library interface specification of the corresponding func_code. Even if exposcall() is invoked with more number of arguments than required for a particular Library function/System call, they are ignored. Examples to use above mentioned Library functions/system calls : 1) To open a file named example.dat, ExpL library interface call is fd=exposcall(\"Open\",\"example.dat\"); Here return value is stored in variable fd, which is file descriptor for file example.dat on success. 2) From above example, variable 'fd' contains file descriptor for file example.dat. To write the value stored in variable 'num' to this file, ExpL library interface call is temp=exposcall(\"Write\",fd,num); //return value stored in temp To write to terminal, use -2 as first argument. Note that expressions such as 2 + 3, num * 34 are not valid as second argument for write system call. temp=exposcall(\"Write\",fd,num+2); //Invalid library interface call 3) Alloc is a library function, which is predefined in ExpL library. It is a dynamic memory management routine. It allocates memory for variables of user defined type in ExpL. ExpL library interface call to allocate memory for variable 'data', which requires 3 words of memory is data=exposcall(\"Alloc\",3); The present library routine alloc allocates 8 words for any variable irrespective of the size mentioned in its alloc exposcall(). So, do not define a user defined type having more than 8 fields. Remember to call library function Intialize using exposcall() once before invoking first alloc in any ExpL program. The description of the system calls can be seen here . The dynamic memory management routines are described below. Dynamic Memory Routines \u00b6 Initialize \u00b6 Arguments: None Return Value: 0 Success -1 Failure Description: Intitalizes the heap data structures and sets up the heap area of the process. It is the applications responsibility to invoke Initialize() before the first use of Alloc(). The behaviour of Alloc() and Free() when invoked without an Intialize() operation is undefined. Any memory allocated before an Intialize() operation will be reclaimed for future allocation. Alloc \u00b6 Arguments: Size (Integer) Return Value: Allocated address in Heap Success -1 No allocation Description: The Alloc operation takes size (integer) as an input and when successful, allocates contiguous words (in the heap) equal to the size specified and returns the address of the allocated memory.The present implementation of library routine alloc allocates 8 words for any variable irrespective of the size mentioned in its alloc exposcall(). So, do not define a user defined type having more than 8 fields. Free \u00b6 Arguments: Pointer (Integer) Return Value: 0 Success -1 Failure Description: The Free operation takes a pointer (i.e., an integer memory address) of a previously allocated memory block and returns it to the heap memory pool. If the pointer does not correspond to a valid reference to the beginning of a previously allocated memory block, the behaviour of Free is not defined.","title":"High Level Library Interface"},{"location":"os-spec/dynamicmemoryroutines/#high-level-library-interface","text":"The High Level Library Interface is a unified Application Programming Interface (API) to access system call routines and dynamic memory management functions from application programs. The ExpL language allows applications to access the OS routines only through the library interface. The syntax for the call to the library function in ExpL is : t = exposcall(fun_code, arg1, arg2, arg3); Depending on the fun_code the control is transferred to the system call routines and the dynamic memory management functions (see below) . Library Function / System Call Function Code Argument 1 Argument 2 Argument 3 Return value Create \"Create\" File Name Permission - 0 - Success/File already exists -1 - No free inode table entry Open \"Open\" File Name - - File Descriptor - Success -1 - File Not found or file is not data file or root file -2 - System has reached its limit of open files -3 - Process has reached its limit of resources Close \"Close\" File Descriptor - - 0 - Success -1 - File Descriptor is invalid Delete \"Delete\" File Name - - 0 - Success/File does not exist -1 - Permission Denied -2 - File is open Write \"Write\" File Descriptor (-2 for terminal) Word to be written - 0 - Success -1 - File Descriptor given is invalid -2 - No disk space -3 - Permission denied Read \"Read\" File Descriptor (-1 for terminal) Variable name (to which data is to be read) - 0 - Success -1 - File Descriptor given is invalid -2 - File pointer has reached the end of file Seek \"Seek\" File Descriptor Offset - 0 - Success -1 - File Descriptor is invalid -2 - Offset moves File pointer outside file Fork \"Fork\" - - - PID - Success (in parent process) 0 - Success (in child process) -1 - Failure (in parent process), Number of processes has reached maximum limit Exec \"Exec\" File Name - - -1 - File not found or file is not executable -2 - Out of memory or disk swap space Exit \"Exit\" - - - - Getpid \"Getpid\" - - - current PID - Success Getppid \"Getppid\" - - - parent PID - Success Wait \"Wait\" Process Identifier - - 0 - Success -1 - Given PID is invalid or it is PID of invoking process Signal \"Signal\" - - - 0 - Success Semget \"Semget\" - - - SEMID - Success -1 - Process has reached its limit of resources -2 - Number of semaphores has reached its maximum Semrelease \"Semrelease\" Semaphore Descriptor - - 0 - Success -1 - Invalid SEMID SemLock \"SemLock\" Semaphore Descriptor - - 0 - Success or semaphore is already locked by the current process -1 - invalid SEMID SemUnLock \"SemUnLock\" Semaphore Descriptor - - 0 - Success -1 - Invalid SEMID -2 - Semaphore was not locked by the calling process Shutdown \"Shutdown\" - - - -1 - Permission denied Newusr \"Newusr\" User name Password - 0 - Success -1 - User already exists -2 - Permission denied -3 - No. of users have reached the system limit. Remusr \"Remusr\" User name - - 0 - Success -1 - User does not exist -2 - Permission denied -3 - Undeleted files exist for the user Setpwd \"Setpwd\" User name New Password - 0 - Success -1 - Unauthorised attempt to change password -2 - The user does not exist. Getuname \"Getuname\" User ID - - User Name - Success -1 - Invalid User ID Getuid \"Getuid\" User name - - User ID - Success -1 - Invalid username Login \"Login\" User name Password - 0 - Success -1 - Invalid username or password -2 - Permission denied Logout \"Logout\" - - - -1 - permission denied Test0 \"Test0\" Unspecified Unspecified Unspecified - Test1 \"Test1\" Unspecified Unspecified Unspecified - Test2 \"Test2\" Unspecified Unspecified Unspecified - Test3 \"Test3\" Unspecified Unspecified Unspecified - Test4 \"Test4\" Unspecified Unspecified Unspecified - Test5 \"Test5\" Unspecified Unspecified Unspecified - Test6 \"Test6\" Unspecified Unspecified Unspecified - Test7 \"Test7\" Unspecified Unspecified Unspecified - Initialize \"Heapset\" - - - 0 - Success -1 - Failure Alloc \"Alloc\" Size - - Allocated address in Heap - Success -1 - No allocation Free \"Free\" Pointer - - 0 - Success -1 - Failure If the file is created with EXCLUSIVE permissions, then write and delete system calls will fail when executed by any user other than the owner or the root (see here). These System Calls are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine. Note According to syntax of exposcall(), it needs four arguments. These arguments are func_code, arg1, arg2, arg3. func_code is necessary for every exposcall() to recognize the Library function/System call. The remaining number of arguments varies according to Library interface specification of the corresponding func_code. Even if exposcall() is invoked with more number of arguments than required for a particular Library function/System call, they are ignored. Examples to use above mentioned Library functions/system calls : 1) To open a file named example.dat, ExpL library interface call is fd=exposcall(\"Open\",\"example.dat\"); Here return value is stored in variable fd, which is file descriptor for file example.dat on success. 2) From above example, variable 'fd' contains file descriptor for file example.dat. To write the value stored in variable 'num' to this file, ExpL library interface call is temp=exposcall(\"Write\",fd,num); //return value stored in temp To write to terminal, use -2 as first argument. Note that expressions such as 2 + 3, num * 34 are not valid as second argument for write system call. temp=exposcall(\"Write\",fd,num+2); //Invalid library interface call 3) Alloc is a library function, which is predefined in ExpL library. It is a dynamic memory management routine. It allocates memory for variables of user defined type in ExpL. ExpL library interface call to allocate memory for variable 'data', which requires 3 words of memory is data=exposcall(\"Alloc\",3); The present library routine alloc allocates 8 words for any variable irrespective of the size mentioned in its alloc exposcall(). So, do not define a user defined type having more than 8 fields. Remember to call library function Intialize using exposcall() once before invoking first alloc in any ExpL program. The description of the system calls can be seen here . The dynamic memory management routines are described below.","title":"High Level Library Interface"},{"location":"os-spec/dynamicmemoryroutines/#dynamic-memory-routines","text":"","title":"Dynamic Memory Routines"},{"location":"os-spec/dynamicmemoryroutines/#initialize","text":"Arguments: None Return Value: 0 Success -1 Failure Description: Intitalizes the heap data structures and sets up the heap area of the process. It is the applications responsibility to invoke Initialize() before the first use of Alloc(). The behaviour of Alloc() and Free() when invoked without an Intialize() operation is undefined. Any memory allocated before an Intialize() operation will be reclaimed for future allocation.","title":"Initialize"},{"location":"os-spec/dynamicmemoryroutines/#alloc","text":"Arguments: Size (Integer) Return Value: Allocated address in Heap Success -1 No allocation Description: The Alloc operation takes size (integer) as an input and when successful, allocates contiguous words (in the heap) equal to the size specified and returns the address of the allocated memory.The present implementation of library routine alloc allocates 8 words for any variable irrespective of the size mentioned in its alloc exposcall(). So, do not define a user defined type having more than 8 fields.","title":"Alloc"},{"location":"os-spec/dynamicmemoryroutines/#free","text":"Arguments: Pointer (Integer) Return Value: 0 Success -1 Failure Description: The Free operation takes a pointer (i.e., an integer memory address) of a previously allocated memory block and returns it to the heap memory pool. If the pointer does not correspond to a valid reference to the beginning of a previously allocated memory block, the behaviour of Free is not defined.","title":"Free"},{"location":"os-spec/expfs/","text":"eXpOS assumes that the disk is a sequence of blocks, where each block can store a sequence of words.The number of words in a block is hardware dependent. Generally, the hardware comes with machine instructions to transfer a block from the disk to a contiguous space in memory and back. The eXpFS logical file system provides a file abstraction that allows application programs to think of each data (or executable) file stored in the disk as a continuous stream of data (or machine instructions) without having to worry about the details of disk block allocation. Thus eXpFS hides the details of physical storage from application programs. eXpOS provides a sequence of file system calls through which application programs can create/read/write data files. These system calls are OS routines that does the translation of the user request into physical disk block operations. In addition to the eXpOS system call interface, the eXpFS specification also requires that there is an external interface through which executable and data files can be loaded into the file system externally. The details of the external interface are implementation specific. The external interface for eXpOS implementation on the XSM machine is described in XFS Interface . In this section we discuss the abstract logical view provided by eXpFS to the eXpOS application programmer. eXpFS File System Organization \u00b6 The eXpFS logical file system comprises of files organized in a single directory called the root. The root is also treated conceptually as a file. As noted already, every eXpFS file is a sequence of words. Associated with each eXpFS file there are three attributes - name, size and type, each attribute being one word long. The file name must be a string. Each file must have a unique name. The size of the file will be the total number of words stored in the file. (The maximum size of a file is operating system dependent). In extended eXpOS , a file has two additional attributes, username and permission. There are three types of eXpFS files - the root, data files and executable files. Each file in eXpFS has an entry in the root called its root entry. The eXpFS Root File \u00b6 The root file has the name root and contains meta-data about the files stored in the file system. For each file stored in eXpFS, the root file stores three words of information - file name, file-size and file-type . (* In extended eXpOS , the root file stores two additional words - user name and permission .) This triple( * In extended eXpOS , 5-tuple) is called the root entry for the file. The first root entry is for the root itself. The order in which the remaining entries appear is not specified and can vary with the implementation. Example: If the file system stores two files - a data file, file.dat, of size 700 words and an executable file, confirm this program.xexe, of 1025 words, the root file will contain the following information. File name File size File type User name Permission root 512 ROOT kernel 0 file.dat 700 DATA username 0/1 program.xexe 1025 EXEC kernel unused The operations on the root file are Open, Close, Read and Seek . Since the operations on the root file is a subset of the operations on data files, with the same syntax and semantics, these operations are discussed together with other operations on data files. * The owner of the root file is set to kernel (userid = 0) and permission set to exclusive (0) during file system formatting (see also specification of multi-user extension to eXpOS.) eXpFS Data files \u00b6 A data file is a sequence of words. The maximum number of words permissible in a file is defined by the constant MAX_FILE_SIZE. (It is a recommended programming convention to use the extension \".dat\" for data files). eXpFS treats every file other than root and executable files (will be described later) as a data file. The Create system call automatically sets the file type field in the root entry for any file created through the create system call to DATA. eXpOS allows an application program to perform the following operations (by invoking appropriate system calls) on data files: Create , Delete , Open, Close, Read, Write, Seek . Application programs can create only data files using the Create system call. In addition to this, data files may be loaded into the eXpFS file system using the external interface (see XFS Interface ). A detailed specification of the file system calls is given here . In Multiuser implementation of eXpOS, the username of a data file corresponds to the user who creates the file. Its permission can be either exclusive (0) or open (1) according to the value specified by the user at the time of creating the file. If a data file is externally loaded into the file system (see XFS Interface ), the owner field is set to root (value = 1) and the access permission is set to open access (value = 1). eXpFS Executable files \u00b6 These contain executable code for programs that can be loaded and run by the operating system. From the point of view of the eXpFS file system alone, executable files are just like data files except that file type is EXEC in the root entry. eXpFS specification does not allow executable files to be created by application programs . They can only be created externally and loaded using the external interface (see XFS Interface for XSM architecture.) In Multiuser implementation of eXpOS, the access permission field for executable files is not used (value = -1). By default, the owner of all excecutable files is set to 0 (kernel). Executable files are essentially program files that must be loaded and run by the operating system. Hence the Operating system imposes certain structure on these files (called the executable file format ). Moreover, the instructions must execute on the machine on which the OS is running. Thus, there is dependency on the hardware as well. Typically, an application program written in a high level language (like ExpL ) is compiled using a compiler that generates the executable file. The compiler generates executable file that is dependent on the operating system as well as the target machine. An OS implementation on a particular machine specifies an application binary interface (ABI) . The eXpOS ABI for XSM machine is specified here . Important Note Application programs are typically written in a high level language like ExpL. A high level language implementation for an OS comes with an Application Programmers Interface (API) for the OS system calls. API describes the library functions which the application programs must invoke for each operating system call. The compiler will translate the library call to corresponding low level interrupt calls as specified in the ABI. Thus, application programmers need to know only API. A description of the ExpL programming language and eXpOS API are given. The ExpL compiler for eXpOS running on the XSM machine generates target code based on the ABI specification for eXpOS on XSM. Thus the ABI becomes the most important document for compiler back end design. The executable file format recognized by eXpOS is called the Experimental executable file ( XEXE ) format. In this format, an executable file is divided into two sections. The first section is called header and the second section called the code (or text) section. The code section contains the program instructions. The header section contains information like the size of the text and data segments in the file, the space to be allocated for stack and heap areas when the program is loaded for execution etc. This information is used by the OS loader to map the file into a virtual address space and create a process in memory for executing the program.","title":"The Logical File System eXpFS"},{"location":"os-spec/expfs/#expfs-file-system-organization","text":"The eXpFS logical file system comprises of files organized in a single directory called the root. The root is also treated conceptually as a file. As noted already, every eXpFS file is a sequence of words. Associated with each eXpFS file there are three attributes - name, size and type, each attribute being one word long. The file name must be a string. Each file must have a unique name. The size of the file will be the total number of words stored in the file. (The maximum size of a file is operating system dependent). In extended eXpOS , a file has two additional attributes, username and permission. There are three types of eXpFS files - the root, data files and executable files. Each file in eXpFS has an entry in the root called its root entry.","title":"eXpFS File System Organization"},{"location":"os-spec/expfs/#the-expfs-root-file","text":"The root file has the name root and contains meta-data about the files stored in the file system. For each file stored in eXpFS, the root file stores three words of information - file name, file-size and file-type . (* In extended eXpOS , the root file stores two additional words - user name and permission .) This triple( * In extended eXpOS , 5-tuple) is called the root entry for the file. The first root entry is for the root itself. The order in which the remaining entries appear is not specified and can vary with the implementation. Example: If the file system stores two files - a data file, file.dat, of size 700 words and an executable file, confirm this program.xexe, of 1025 words, the root file will contain the following information. File name File size File type User name Permission root 512 ROOT kernel 0 file.dat 700 DATA username 0/1 program.xexe 1025 EXEC kernel unused The operations on the root file are Open, Close, Read and Seek . Since the operations on the root file is a subset of the operations on data files, with the same syntax and semantics, these operations are discussed together with other operations on data files. * The owner of the root file is set to kernel (userid = 0) and permission set to exclusive (0) during file system formatting (see also specification of multi-user extension to eXpOS.)","title":"The eXpFS Root File"},{"location":"os-spec/expfs/#expfs-data-files","text":"A data file is a sequence of words. The maximum number of words permissible in a file is defined by the constant MAX_FILE_SIZE. (It is a recommended programming convention to use the extension \".dat\" for data files). eXpFS treats every file other than root and executable files (will be described later) as a data file. The Create system call automatically sets the file type field in the root entry for any file created through the create system call to DATA. eXpOS allows an application program to perform the following operations (by invoking appropriate system calls) on data files: Create , Delete , Open, Close, Read, Write, Seek . Application programs can create only data files using the Create system call. In addition to this, data files may be loaded into the eXpFS file system using the external interface (see XFS Interface ). A detailed specification of the file system calls is given here . In Multiuser implementation of eXpOS, the username of a data file corresponds to the user who creates the file. Its permission can be either exclusive (0) or open (1) according to the value specified by the user at the time of creating the file. If a data file is externally loaded into the file system (see XFS Interface ), the owner field is set to root (value = 1) and the access permission is set to open access (value = 1).","title":"eXpFS Data files"},{"location":"os-spec/expfs/#expfs-executable-files","text":"These contain executable code for programs that can be loaded and run by the operating system. From the point of view of the eXpFS file system alone, executable files are just like data files except that file type is EXEC in the root entry. eXpFS specification does not allow executable files to be created by application programs . They can only be created externally and loaded using the external interface (see XFS Interface for XSM architecture.) In Multiuser implementation of eXpOS, the access permission field for executable files is not used (value = -1). By default, the owner of all excecutable files is set to 0 (kernel). Executable files are essentially program files that must be loaded and run by the operating system. Hence the Operating system imposes certain structure on these files (called the executable file format ). Moreover, the instructions must execute on the machine on which the OS is running. Thus, there is dependency on the hardware as well. Typically, an application program written in a high level language (like ExpL ) is compiled using a compiler that generates the executable file. The compiler generates executable file that is dependent on the operating system as well as the target machine. An OS implementation on a particular machine specifies an application binary interface (ABI) . The eXpOS ABI for XSM machine is specified here . Important Note Application programs are typically written in a high level language like ExpL. A high level language implementation for an OS comes with an Application Programmers Interface (API) for the OS system calls. API describes the library functions which the application programs must invoke for each operating system call. The compiler will translate the library call to corresponding low level interrupt calls as specified in the ABI. Thus, application programmers need to know only API. A description of the ExpL programming language and eXpOS API are given. The ExpL compiler for eXpOS running on the XSM machine generates target code based on the ABI specification for eXpOS on XSM. Thus the ABI becomes the most important document for compiler back end design. The executable file format recognized by eXpOS is called the Experimental executable file ( XEXE ) format. In this format, an executable file is divided into two sections. The first section is called header and the second section called the code (or text) section. The code section contains the program instructions. The header section contains information like the size of the text and data segments in the file, the space to be allocated for stack and heap areas when the program is loaded for execution etc. This information is used by the OS loader to map the file into a virtual address space and create a process in memory for executing the program.","title":"eXpFS Executable files"},{"location":"os-spec/expos-abstractions/","text":"eXpOS provides the following fundamental abstractions to an application program: The eXpFS logical file system The process abstraction for programs in execution Methods of resource sharing Primitives for concurrent access control and process synchronization The system call interface that specifies the interface through which application programs can invoke the system calls and access the OS services. The extended eXpOS specification provides a user abstraction as discussed here. The eXpFS logical file system \u00b6 The eXpOS kernal provides a hardware independent logical file system model (called the experimental file system or eXpFS ) for application programs. The application program views files as being organized and stored in the eXpFS logical file system. Application programs are not permitted to access files directly. Instead, they must invoke the appropriate file system call for creating, modifying or accessing files. The OS routine implementing each system call internally translates the request into disk block operations, hiding the hardware details from the application program. eXpFS support three kinds of files - data files, program files (executable files) and a special file called the root file. The root file is a meta-data file that contains the list of all files in the file system. A data file consists of a sequence of words. A program contains a header, a sequence of machine instructions called text and static data, if any. eXpOS does not provide any mechanisms for application programs to create executable files . Executable files have to be pre-loaded into the disk using some other external disk access mechanism before OS bootstrap. Since such mechanisms are implementation dependent, they are not part of the OS specification. For instance, the XFS-Interface tool for eXpOS implementation on the XSM machine is one such mechanism. Executable files follow certain format called the experimental executable format or XEXE format . The OS will execute only program files stored in the file system in the XEXE format. Hence system programs like compilers that translate high level application programs must ensure that the executable files adhere to the XEXE format. Application programs can create, modify and delete data files using appropriate OS system calls. These are discussed here . A detailed discussion of the file system structure, file system calls and XEXE format is given in Section 3 . The eXpOS process Abstraction \u00b6 It was noted earlier that at the end of bootstrap, eXpOS loads into memory a program stored in a pre-determined part of the disk and creates the first process called the INIT process. Once a process is created, it can spawn new processes using the fork system call. When a process spawns a new process, the former is called the parent process and the later is called the child process . A process can decide to terminate itself using the exit system call. In the extended eXpOS specification, the INIT process is called the LOGIN process and is executed directly by the kernel. This process invokes the login system call to log a user in. Once a user is logged in, the shell process is created for the user and the original login process waits for the termination of the user shell, to log in the next user. Associated with each process, there is a (virtual) address space (or logical memory space). This address space is a sequence of memory locations, each of which can store a word. eXpOS logically divides the address space of a process into four regions - (shared) library, code, stack and heap . When a process is created using the fork system call, the OS creates a virtual address space for the new process. Each process is given a view that it has its own virtual address space containing its code, library, stack and heap. The virtual address space is a continuous address space starting from address 0 up to a maximum limit that is implementation dependent. Internally, the OS maps the virtual address space into the machine memory using hardware mechanisms available in the machine like paging/segmentation.( Check mapping implementation in XSM here ) The code region of a process contains the machine instructions that are to be executed. This code consists of instructions stored in some executable file in the file system. When a new process is created using the fork system call, the child process shares the library, code and heap with the parent . This means that any modifications to memory words in these regions by one process will result in modification of the contents for both the processes. The stack region of the parent and the child will be separate. The parent and the child concurrently proceeds execution from the instruction immediately following the fork system call in the code. The stack region of a process stores the variables and stack frames during the execution of the program. Since our implementation of eXpOS does not explicitly provide an area for storing static data, they are stored on the stack. Dynamic memory allocation is normally done from the heap region. Variables to be shared between different processes could also be allocated in the heap. Finally all (standard) library code (which is typically shared by all applications) is mapped to the library region. A process can load an XEXE executable file from the file system into the virtual address space (of the calling process) using the exec system call. During loading, the original code and stack regions are overlayed by those of the newly loaded program. If the original process had shared its heap with its parent process (or any other process), the OS ensures that other processes do not lose their shared heap data. Finally, the (shared) library is common to every application. The OS expects that executable files respect the programming conventions laid down by the OS (defined in the Application Binary Interface-ABI ) like the division of memory into stack, code, heap and library. Each XEXE executable file must have a header which specifies how much size must be allocated by the OS for each region when the program is loaded for execution. Application programs are typically written in high level languages like ExpL and eXpOS expects the compiler to generate code respecting the ABI specification. It must be noted here that an application program is free to violate the ABI conventions and decide to use its virtual address space in its own way. It is only required that the executable file follows XEXE format in order to ensure that exec system call does not fail. As long as such a process operates within its own address space, the OS permits the process to execute. However, if at any point during its execution, the process generates a virtual address beyond its permitted virtual address space, a hardware exception will be generated and the OS routine handling the exception will terminate the process. Access Control and Synchronization \u00b6 Two concurrently executing processes sharing resources like files or memory (for example, parent and child processes sharing the heap) would like to ensure that only one of them execute critical section code that access/modify a resource that is shared between them. A classical solution to this problem is using semaphores . A process can acquire a semaphore using the Semget system call and share it with its child (or later generation) processes. A semaphore can be locked by any of these sharing processes using the SemLock system call and the execution of all other processes trying to lock the same semaphore subsequently will be suspended ( blocked ) by the OS until the locking process unlocks the semaphore using the SemUnlock system call. The Wait system call allows a process to suspend its own execution until another process wakes it up using the Signal system call. This primitive is useful when a process must be made to wait at a point during its execution until another related process signals it to continue. Resource Sharing in eXpOS \u00b6 It was already noted that the child process shares the heap of the parent process. Hence memory allocated in the heap will be a shared memory between both the processes. However, if either the parent or the child process loads another program into its virtual address space using the exec system call, then the shared heap is detached from that process and the surviving process will have the heap intact. The file pointers handled by the parent process are also shared by the child process. Thus, eXpOS does not support any explicit primitives for memory sharing, but instead allows related processes to share these resources implicitly using the fork system call semantics. The file sharing semantics between users in Multiuser extension to eXpOS is described here . System Calls \u00b6 The eXpOS system calls are software interrupt routines of the eXpOS kernal which are loaded into the memory when the OS is bootstrapped. These routines define the services provided by the OS to application programs. These services include accessing files and semaphores, creating new processes , sending a signal to another process etc. Application programs are not permitted to directly access files/semaphores or create new processes. Instead they must invoke the corresponding system call routines. System calls are kernal routines and operate in privileged or system mode . Thus when an application program invokes a system call (by invoking the corresponding software interrupt), a change of mode from unprivileged mode to privileged mode occurs. The system call code checks whether the request is valid and the process has permission to the resources/actions requested and then perform the request. Upon completion of the interrupt service routine, control is transferred back to the user process with a switch back to the unprivileged mode. eXpOS system calls can be classified as file system calls, process system calls and system calls for access control and synchronization. The following table lists the system calls. A detailed specification can be found here . File system calls \u00b6 Name Description Create Create an eXpFS file Delete Delete an eXpFS file Open Open an eXpFS file and return a file handle to the calling process Close Close an eXpFS file already opened by the calling process Read Read one word from the location pointed to by the file pointer and advance the file pointer to the next word in the file Write Write one word from the location pointed to by the file pointer and advance the file pointer to the next word in the file Seek Change the position of the file pointer Process system calls \u00b6 Name Description Fork Create a child process allocating a new address space. Exec Load and execute an eXpFS executable file into the virtual address space of the present process. Exit Destroy the process invoking the call Getpid Get the Process ID of the invoking process Getppid Get the process ID of the parent process of the invoking process. System calls for access control and synchronization \u00b6 Name Description Signal Send a signal to a process specified in the call. Wait Suspend execution of the current process until the process specified sends a signal or terminates. Semget Acquire a new semaphore Semrelease Release a semaphore already acquired by the process SemLock Get exclusive access permission to semaphore specified. (Process blocks till lock is obtained.) SemUnLock Release the lock on a semaphore already acquired System calls for Multiuser extension to eXpOS \u00b6 Name Description Newusr Creates a new user with the specified user name and password Remusr Removes the user specified by the username Setpwd Sets the password for the corresponding user Getuid Returns the userid of the user with the corresponding username Getuname Returns the username of the user with the corresponding userid Login Logs in a new user","title":"eXpOS Abstractions"},{"location":"os-spec/expos-abstractions/#the-expfs-logical-file-system","text":"The eXpOS kernal provides a hardware independent logical file system model (called the experimental file system or eXpFS ) for application programs. The application program views files as being organized and stored in the eXpFS logical file system. Application programs are not permitted to access files directly. Instead, they must invoke the appropriate file system call for creating, modifying or accessing files. The OS routine implementing each system call internally translates the request into disk block operations, hiding the hardware details from the application program. eXpFS support three kinds of files - data files, program files (executable files) and a special file called the root file. The root file is a meta-data file that contains the list of all files in the file system. A data file consists of a sequence of words. A program contains a header, a sequence of machine instructions called text and static data, if any. eXpOS does not provide any mechanisms for application programs to create executable files . Executable files have to be pre-loaded into the disk using some other external disk access mechanism before OS bootstrap. Since such mechanisms are implementation dependent, they are not part of the OS specification. For instance, the XFS-Interface tool for eXpOS implementation on the XSM machine is one such mechanism. Executable files follow certain format called the experimental executable format or XEXE format . The OS will execute only program files stored in the file system in the XEXE format. Hence system programs like compilers that translate high level application programs must ensure that the executable files adhere to the XEXE format. Application programs can create, modify and delete data files using appropriate OS system calls. These are discussed here . A detailed discussion of the file system structure, file system calls and XEXE format is given in Section 3 .","title":"The eXpFS logical file system"},{"location":"os-spec/expos-abstractions/#the-expos-process-abstraction","text":"It was noted earlier that at the end of bootstrap, eXpOS loads into memory a program stored in a pre-determined part of the disk and creates the first process called the INIT process. Once a process is created, it can spawn new processes using the fork system call. When a process spawns a new process, the former is called the parent process and the later is called the child process . A process can decide to terminate itself using the exit system call. In the extended eXpOS specification, the INIT process is called the LOGIN process and is executed directly by the kernel. This process invokes the login system call to log a user in. Once a user is logged in, the shell process is created for the user and the original login process waits for the termination of the user shell, to log in the next user. Associated with each process, there is a (virtual) address space (or logical memory space). This address space is a sequence of memory locations, each of which can store a word. eXpOS logically divides the address space of a process into four regions - (shared) library, code, stack and heap . When a process is created using the fork system call, the OS creates a virtual address space for the new process. Each process is given a view that it has its own virtual address space containing its code, library, stack and heap. The virtual address space is a continuous address space starting from address 0 up to a maximum limit that is implementation dependent. Internally, the OS maps the virtual address space into the machine memory using hardware mechanisms available in the machine like paging/segmentation.( Check mapping implementation in XSM here ) The code region of a process contains the machine instructions that are to be executed. This code consists of instructions stored in some executable file in the file system. When a new process is created using the fork system call, the child process shares the library, code and heap with the parent . This means that any modifications to memory words in these regions by one process will result in modification of the contents for both the processes. The stack region of the parent and the child will be separate. The parent and the child concurrently proceeds execution from the instruction immediately following the fork system call in the code. The stack region of a process stores the variables and stack frames during the execution of the program. Since our implementation of eXpOS does not explicitly provide an area for storing static data, they are stored on the stack. Dynamic memory allocation is normally done from the heap region. Variables to be shared between different processes could also be allocated in the heap. Finally all (standard) library code (which is typically shared by all applications) is mapped to the library region. A process can load an XEXE executable file from the file system into the virtual address space (of the calling process) using the exec system call. During loading, the original code and stack regions are overlayed by those of the newly loaded program. If the original process had shared its heap with its parent process (or any other process), the OS ensures that other processes do not lose their shared heap data. Finally, the (shared) library is common to every application. The OS expects that executable files respect the programming conventions laid down by the OS (defined in the Application Binary Interface-ABI ) like the division of memory into stack, code, heap and library. Each XEXE executable file must have a header which specifies how much size must be allocated by the OS for each region when the program is loaded for execution. Application programs are typically written in high level languages like ExpL and eXpOS expects the compiler to generate code respecting the ABI specification. It must be noted here that an application program is free to violate the ABI conventions and decide to use its virtual address space in its own way. It is only required that the executable file follows XEXE format in order to ensure that exec system call does not fail. As long as such a process operates within its own address space, the OS permits the process to execute. However, if at any point during its execution, the process generates a virtual address beyond its permitted virtual address space, a hardware exception will be generated and the OS routine handling the exception will terminate the process.","title":"The eXpOS process Abstraction"},{"location":"os-spec/expos-abstractions/#access-control-and-synchronization","text":"Two concurrently executing processes sharing resources like files or memory (for example, parent and child processes sharing the heap) would like to ensure that only one of them execute critical section code that access/modify a resource that is shared between them. A classical solution to this problem is using semaphores . A process can acquire a semaphore using the Semget system call and share it with its child (or later generation) processes. A semaphore can be locked by any of these sharing processes using the SemLock system call and the execution of all other processes trying to lock the same semaphore subsequently will be suspended ( blocked ) by the OS until the locking process unlocks the semaphore using the SemUnlock system call. The Wait system call allows a process to suspend its own execution until another process wakes it up using the Signal system call. This primitive is useful when a process must be made to wait at a point during its execution until another related process signals it to continue.","title":"Access Control and Synchronization"},{"location":"os-spec/expos-abstractions/#resource-sharing-in-expos","text":"It was already noted that the child process shares the heap of the parent process. Hence memory allocated in the heap will be a shared memory between both the processes. However, if either the parent or the child process loads another program into its virtual address space using the exec system call, then the shared heap is detached from that process and the surviving process will have the heap intact. The file pointers handled by the parent process are also shared by the child process. Thus, eXpOS does not support any explicit primitives for memory sharing, but instead allows related processes to share these resources implicitly using the fork system call semantics. The file sharing semantics between users in Multiuser extension to eXpOS is described here .","title":"Resource Sharing in eXpOS"},{"location":"os-spec/expos-abstractions/#system-calls","text":"The eXpOS system calls are software interrupt routines of the eXpOS kernal which are loaded into the memory when the OS is bootstrapped. These routines define the services provided by the OS to application programs. These services include accessing files and semaphores, creating new processes , sending a signal to another process etc. Application programs are not permitted to directly access files/semaphores or create new processes. Instead they must invoke the corresponding system call routines. System calls are kernal routines and operate in privileged or system mode . Thus when an application program invokes a system call (by invoking the corresponding software interrupt), a change of mode from unprivileged mode to privileged mode occurs. The system call code checks whether the request is valid and the process has permission to the resources/actions requested and then perform the request. Upon completion of the interrupt service routine, control is transferred back to the user process with a switch back to the unprivileged mode. eXpOS system calls can be classified as file system calls, process system calls and system calls for access control and synchronization. The following table lists the system calls. A detailed specification can be found here .","title":"System Calls"},{"location":"os-spec/expos-abstractions/#file-system-calls","text":"Name Description Create Create an eXpFS file Delete Delete an eXpFS file Open Open an eXpFS file and return a file handle to the calling process Close Close an eXpFS file already opened by the calling process Read Read one word from the location pointed to by the file pointer and advance the file pointer to the next word in the file Write Write one word from the location pointed to by the file pointer and advance the file pointer to the next word in the file Seek Change the position of the file pointer","title":"File system calls"},{"location":"os-spec/expos-abstractions/#process-system-calls","text":"Name Description Fork Create a child process allocating a new address space. Exec Load and execute an eXpFS executable file into the virtual address space of the present process. Exit Destroy the process invoking the call Getpid Get the Process ID of the invoking process Getppid Get the process ID of the parent process of the invoking process.","title":"Process system calls"},{"location":"os-spec/expos-abstractions/#system-calls-for-access-control-and-synchronization","text":"Name Description Signal Send a signal to a process specified in the call. Wait Suspend execution of the current process until the process specified sends a signal or terminates. Semget Acquire a new semaphore Semrelease Release a semaphore already acquired by the process SemLock Get exclusive access permission to semaphore specified. (Process blocks till lock is obtained.) SemUnLock Release the lock on a semaphore already acquired","title":"System calls for access control and synchronization"},{"location":"os-spec/expos-abstractions/#system-calls-for-multiuser-extension-to-expos","text":"Name Description Newusr Creates a new user with the specified user name and password Remusr Removes the user specified by the username Setpwd Sets the password for the corresponding user Getuid Returns the userid of the user with the corresponding username Getuname Returns the username of the user with the corresponding userid Login Logs in a new user","title":"System calls for Multiuser extension to eXpOS"},{"location":"os-spec/misc/","text":"Parts of the OS specification which does not fit into other sections of this documentation has been collected here. These topics are internal to the operating system, but part of the OS specification. Some of these details are hidden from application/system programs and have more hardware dependency than most other parts of this documentation. When the machine is powered on, the system is configured to start executing a ROM code in privileged mode. This code is called the bootstrap loader . This ROM code loads the first block of the disk into a pre-defined area in memory and transfers control to the newly loaded code. This code is called the OS startup code . The OS startup code loads the system call routines into memory. These routines are loaded as software interrupt handlers. In addition to these, there are four hardware interrupt / exception handler modules that are to be loaded - the timer interrupt handler, the exception handler , the disk interrupt handler and the terminal handler. If the architecture supports other devices, then the corresponding device interrupt handlers also must be loaded by the OS Startup code. This specification leaves out details regarding other device handlers. Timer interrupt handler \u00b6 The hardware requirement specification for eXpOS assumes that the machine is equipped with a timer device that sends periodic hardware interrupts. The OS scheduler is invoked by the hardware timer interrupt handler. eXpOS specification suggest that a co-operative multitasking round robin scheduling is employed. This means that a round robin scheduling is employed, but a process may go to sleep inside a system call when: The resource which the process is trying to access (like a file or semaphore) is locked by another process (or even internally locked by another OS system call in concurrent execution). There is a disk or I/O device access in a system call which is slow. If the wait for the device access is to be avoided, there must be hardware support from the device to send a hardware interrupt when device operation is finished. This allows the OS to put the process on sleep for now, continue scheduling the remaining processes in round robin fashion and then wake up the sleeping process when the device sends the interrupt. Such hardware support is desirable, but not necessary to implement eXpOS Exception handler \u00b6 If a process generates an illegal instruction, an invalid address (outside its virtual address space) or do a division by zero (or other faulty conditions which are machine dependent), the machine will generate an exception. The exception handler must terminate the process, wake up all processes waiting for it (or resources locked by it) and invoke the scheduler to continue round robin scheduling the remaining processes. The exception handler is invoked when a page required by the process is not present in the memory. This condition is known as a page fault . The module which handles demand paging (if the machine hardware supports demand paging) is invoked by the exception handler when there is a page fault . eXpOS specification does not require implementation of demand paging. However, most machines (including XSM) are equipped with hardware support for demand paging and using the feature can improve machine throughput considerably. A discussion of demand paging is given here . Disk Controller \u00b6 eXpOS treats the disk as a special block device and assumes that the hardware provides low level block transfer routines to transfer disk blocks to memory (pages) and back. The block transfer routines contain instructions to initiate block-memory transfer by the disk controller hardware. After initiating the disk-memory transfer, the block transfer routine normally returns to the calling program, which sleeps for the disk operation to complete. When the disk-memory transfer is complete, the disk controller raises a hardware interrupt. The interrupt service routine (handler) must be part of the OS code to be set up during the bootstrap. The disk interrupt handler is responsible for waking processes that went into sleep awaiting completion of the disk operation. Terminal and other Device Handlers \u00b6 All other data handling devices (other than the disk) are treated as stream devices . This means that each device allows transfer of only one word from memory to the device or back at a time. Some devices may permit only write (like a printer) whereas some devices may permit only read. It is assumed that for each device there are associated low level routines that can be invoked by the OS to transfer data and control instructions. Some of these devices may raise a hardware interrupt when the transfer is complete. Thus, for each device that raises an interrupt, there must be a corresponding device interrupt handler. The details of how data is transferred between memory and specific devices are hardware dependent and are to be handled by the OS routines in an implementation specific way. Here we are concerned about the device interface to application programmers. For each device part of the hardware, the OS assigns a unique device identifier ( devid ) which is announced to the application programmer. (The device identifiers are specific to the particular installation). It is assumed that device identifiers are distinguishable from file handles. A user program can write a word into a device using the write system call. The read system call is used when the device allows a word to be read. (System Call Interface) . Read and Write are the only system calls associated with devices. The standard input and the standard output are two special stream devices with predefined identifiers STDIN = -1 and STDOUT = -2. Standard output permits only Write and standard input permits only Read . The Read operation typically puts the process executing the operation to sleep for console input from the user. When the user inputs data, the console device must send a hardware interrupt. The corresponding handler routine is called terminal handler . The terminal handler is responsible for waking up processes that are blocked for input console. eXpOS Library \u00b6 The eXpOS library consists of a collection of high level (user level) routines. The library is part of the OS and is loaded into the memory at the time of boostrap. The OS loader (exec system call) links the library to the address space of a process if necessary. The executable header contains the information required for the loader to decide whether the library must be linked to the address space of a process when it is loaded for execution. The eXpOS library routines provide a unified interface for invoking system calls and dynamic memory management routines provided by the operating stystem. The interface hides the details of the interrupt service routines corresponding to the system calls from the application. See high level library interface for more details. Idle Process \u00b6 Idle process is a user process created by the kernel during the bootstrap process. It executes an infinite loop. Its purpose is to ensure that there is atleast one user process for the scheduler to schedule. The OS will schedule the idle process when all the other user processes are in sleep state. Idle process is never swapped. Init (Login) and Shell \u00b6 The OS has an INIT program pre-loaded in the disk, which is loaded for execution at the time of bootstrap. The resulting process is the second process scheduled for execution (after the IDLE process ) and is called the INIT process. The INIT program is expected to run a login program that validates a user trying to log into the system using the Login system call. Hence, the INIT process is also called the login process . A shell is created upon successful login and the INIT (login) process waits for the exit of the shell to log in the next user. The shell program is typically designed to repeatedly wait for user commands (executable file names) and execute them. The algorithm design for a typical login process is given here . The algorithm design for a typical eXpOS shell is given here .","title":"Micellaneous"},{"location":"os-spec/misc/#timer-interrupt-handler","text":"The hardware requirement specification for eXpOS assumes that the machine is equipped with a timer device that sends periodic hardware interrupts. The OS scheduler is invoked by the hardware timer interrupt handler. eXpOS specification suggest that a co-operative multitasking round robin scheduling is employed. This means that a round robin scheduling is employed, but a process may go to sleep inside a system call when: The resource which the process is trying to access (like a file or semaphore) is locked by another process (or even internally locked by another OS system call in concurrent execution). There is a disk or I/O device access in a system call which is slow. If the wait for the device access is to be avoided, there must be hardware support from the device to send a hardware interrupt when device operation is finished. This allows the OS to put the process on sleep for now, continue scheduling the remaining processes in round robin fashion and then wake up the sleeping process when the device sends the interrupt. Such hardware support is desirable, but not necessary to implement eXpOS","title":"Timer interrupt handler"},{"location":"os-spec/misc/#exception-handler","text":"If a process generates an illegal instruction, an invalid address (outside its virtual address space) or do a division by zero (or other faulty conditions which are machine dependent), the machine will generate an exception. The exception handler must terminate the process, wake up all processes waiting for it (or resources locked by it) and invoke the scheduler to continue round robin scheduling the remaining processes. The exception handler is invoked when a page required by the process is not present in the memory. This condition is known as a page fault . The module which handles demand paging (if the machine hardware supports demand paging) is invoked by the exception handler when there is a page fault . eXpOS specification does not require implementation of demand paging. However, most machines (including XSM) are equipped with hardware support for demand paging and using the feature can improve machine throughput considerably. A discussion of demand paging is given here .","title":"Exception handler"},{"location":"os-spec/misc/#disk-controller","text":"eXpOS treats the disk as a special block device and assumes that the hardware provides low level block transfer routines to transfer disk blocks to memory (pages) and back. The block transfer routines contain instructions to initiate block-memory transfer by the disk controller hardware. After initiating the disk-memory transfer, the block transfer routine normally returns to the calling program, which sleeps for the disk operation to complete. When the disk-memory transfer is complete, the disk controller raises a hardware interrupt. The interrupt service routine (handler) must be part of the OS code to be set up during the bootstrap. The disk interrupt handler is responsible for waking processes that went into sleep awaiting completion of the disk operation.","title":"Disk Controller"},{"location":"os-spec/misc/#terminal-and-other-device-handlers","text":"All other data handling devices (other than the disk) are treated as stream devices . This means that each device allows transfer of only one word from memory to the device or back at a time. Some devices may permit only write (like a printer) whereas some devices may permit only read. It is assumed that for each device there are associated low level routines that can be invoked by the OS to transfer data and control instructions. Some of these devices may raise a hardware interrupt when the transfer is complete. Thus, for each device that raises an interrupt, there must be a corresponding device interrupt handler. The details of how data is transferred between memory and specific devices are hardware dependent and are to be handled by the OS routines in an implementation specific way. Here we are concerned about the device interface to application programmers. For each device part of the hardware, the OS assigns a unique device identifier ( devid ) which is announced to the application programmer. (The device identifiers are specific to the particular installation). It is assumed that device identifiers are distinguishable from file handles. A user program can write a word into a device using the write system call. The read system call is used when the device allows a word to be read. (System Call Interface) . Read and Write are the only system calls associated with devices. The standard input and the standard output are two special stream devices with predefined identifiers STDIN = -1 and STDOUT = -2. Standard output permits only Write and standard input permits only Read . The Read operation typically puts the process executing the operation to sleep for console input from the user. When the user inputs data, the console device must send a hardware interrupt. The corresponding handler routine is called terminal handler . The terminal handler is responsible for waking up processes that are blocked for input console.","title":"Terminal and other Device Handlers"},{"location":"os-spec/misc/#expos-library","text":"The eXpOS library consists of a collection of high level (user level) routines. The library is part of the OS and is loaded into the memory at the time of boostrap. The OS loader (exec system call) links the library to the address space of a process if necessary. The executable header contains the information required for the loader to decide whether the library must be linked to the address space of a process when it is loaded for execution. The eXpOS library routines provide a unified interface for invoking system calls and dynamic memory management routines provided by the operating stystem. The interface hides the details of the interrupt service routines corresponding to the system calls from the application. See high level library interface for more details.","title":"eXpOS Library"},{"location":"os-spec/misc/#idle-process","text":"Idle process is a user process created by the kernel during the bootstrap process. It executes an infinite loop. Its purpose is to ensure that there is atleast one user process for the scheduler to schedule. The OS will schedule the idle process when all the other user processes are in sleep state. Idle process is never swapped.","title":"Idle Process"},{"location":"os-spec/misc/#init-login-and-shell","text":"The OS has an INIT program pre-loaded in the disk, which is loaded for execution at the time of bootstrap. The resulting process is the second process scheduled for execution (after the IDLE process ) and is called the INIT process. The INIT program is expected to run a login program that validates a user trying to log into the system using the Login system call. Hence, the INIT process is also called the login process . A shell is created upon successful login and the INIT (login) process waits for the exit of the shell to log in the next user. The shell program is typically designed to repeatedly wait for user commands (executable file names) and execute them. The algorithm design for a typical login process is given here . The algorithm design for a typical eXpOS shell is given here .","title":"Init (Login) and Shell"},{"location":"os-spec/multiuser/","text":"Multi-user Extension to eXpOS \u00b6 This document specifies the extended features provided by eXpOS to support multiple users. The extended eXpOS allows a maximum of MAX_USER_NUM users. Each user is alloted a unique userid . Every process is assigned the userid, corresponding to the user executing the process. Two special processes hand created by the kernel at boot-\u00adtime are given the special userid \u00ad0. These processes are the idle process and the login process and are called the kernel processes . At the end of system bootstrap, the login process is scheduled for execution. The present version of eXpOS sets MAX_USER_NUM to 16. The login process waits invoking the (terminal) read system call for a username and password to be input from the console. Both username and password are strings. The login process executes the Login system call with the username and the password as the arguments. The login system call verifies the user and creates a new shell process . (In practice, the shell is preloaded into memory during OS startup and the login process sets the shell ready to run.) The shell is assigned the userid of the logged in user (by the Login system call). The login process thereafter goes to sleep and will wake up only upon execution of the logout system call. All descendent processes of the shell inherit the userid of the shell. Note that Login is the only system call that can set the userid of a process. eXpOS requires one user to logout before another user can login. Hence user processes with multiple userid values will not execute simultaneously. When the shell process executes the logout system call , all processes of the user are terminated and the login process is woken up. The login process then proceeds to login the next user. eXpOS specification allows only the login process to execute the login system call. Other multiuser system calls except getuid and getuname can be executed only from the shell. The high level interface of the login system call is given here . Two special users, the kernel and the root , defined by eXpOS, are assigned userid 0 and userid 1 respectively. Root is the user with administrative privileges. The shutdown system call can be executed only from the shell of the root user. The system calls for adding a user or removing an existing user from the system can be executed only by the root. A new user is created using newusr system call. An existing user can be deleted by the remusr system calls. The special users\u00ad, root and kernel, cannot be removed. A user can change his/her password using setpwd system call which takes username and password as arguments. A user, other than the root is allowed to change only his/her own password. Root can change the password of any user, including itself. The getuid system call returns the user id of the current user. The getuname system call returns the username corresponding to a userid. The API specification of all the multi\u00aduser system calls can be seen here . File Access Permissions \u00b6 When a file is created by a process using the Create system call, the process can set its permission to exclusive(value = 0)/open-access(value = 1) , to restrict access permissions. When a file is created with it's permission set to exclusive, write and delete system calls to that file will fail if executed by any user other than the owner of the file or the root. Open-access data files have no such restrictions. The root can modify/delete any data file (but not the root file or executable files) irrespective of the permissions . Kernel processes (Idle and Init/Login) have unrestricted access to all system calls . The root file has default userid 0 (kernel) and permission exclusive (value = 0). By default, the owner of all executable files is set to kernel (value = 0). File access permissions are not used for executable files. They can only be created externally and loaded using the external interface (see XFS Interface for XSM architecture.) The owner of any data file preloaded into the system through xfs-interface is set to root and permission to open-access. Hence there is no access restriction to these files.","title":"Multi-User Extension to eXpOS"},{"location":"os-spec/multiuser/#multi-user-extension-to-expos","text":"This document specifies the extended features provided by eXpOS to support multiple users. The extended eXpOS allows a maximum of MAX_USER_NUM users. Each user is alloted a unique userid . Every process is assigned the userid, corresponding to the user executing the process. Two special processes hand created by the kernel at boot-\u00adtime are given the special userid \u00ad0. These processes are the idle process and the login process and are called the kernel processes . At the end of system bootstrap, the login process is scheduled for execution. The present version of eXpOS sets MAX_USER_NUM to 16. The login process waits invoking the (terminal) read system call for a username and password to be input from the console. Both username and password are strings. The login process executes the Login system call with the username and the password as the arguments. The login system call verifies the user and creates a new shell process . (In practice, the shell is preloaded into memory during OS startup and the login process sets the shell ready to run.) The shell is assigned the userid of the logged in user (by the Login system call). The login process thereafter goes to sleep and will wake up only upon execution of the logout system call. All descendent processes of the shell inherit the userid of the shell. Note that Login is the only system call that can set the userid of a process. eXpOS requires one user to logout before another user can login. Hence user processes with multiple userid values will not execute simultaneously. When the shell process executes the logout system call , all processes of the user are terminated and the login process is woken up. The login process then proceeds to login the next user. eXpOS specification allows only the login process to execute the login system call. Other multiuser system calls except getuid and getuname can be executed only from the shell. The high level interface of the login system call is given here . Two special users, the kernel and the root , defined by eXpOS, are assigned userid 0 and userid 1 respectively. Root is the user with administrative privileges. The shutdown system call can be executed only from the shell of the root user. The system calls for adding a user or removing an existing user from the system can be executed only by the root. A new user is created using newusr system call. An existing user can be deleted by the remusr system calls. The special users\u00ad, root and kernel, cannot be removed. A user can change his/her password using setpwd system call which takes username and password as arguments. A user, other than the root is allowed to change only his/her own password. Root can change the password of any user, including itself. The getuid system call returns the user id of the current user. The getuname system call returns the username corresponding to a userid. The API specification of all the multi\u00aduser system calls can be seen here .","title":"Multi-user Extension to eXpOS"},{"location":"os-spec/multiuser/#file-access-permissions","text":"When a file is created by a process using the Create system call, the process can set its permission to exclusive(value = 0)/open-access(value = 1) , to restrict access permissions. When a file is created with it's permission set to exclusive, write and delete system calls to that file will fail if executed by any user other than the owner of the file or the root. Open-access data files have no such restrictions. The root can modify/delete any data file (but not the root file or executable files) irrespective of the permissions . Kernel processes (Idle and Init/Login) have unrestricted access to all system calls . The root file has default userid 0 (kernel) and permission exclusive (value = 0). By default, the owner of all executable files is set to kernel (value = 0). File access permissions are not used for executable files. They can only be created externally and loaded using the external interface (see XFS Interface for XSM architecture.) The owner of any data file preloaded into the system through xfs-interface is set to root and permission to open-access. Hence there is no access restriction to these files.","title":"File Access Permissions"},{"location":"os-spec/overview/","text":"Terminology \u00b6 It is assumed that the reader has some working familiarity with the following terms and concepts. (The description of the machine used in this experiment is given here . However reading the description is NOT a prerequisite for this document.) Machine: The hardware/machine (computer) on which the operating system is running. (Physical) Memory: The physical memory (primary memory) of the machine. Word: The fundamental unit of memory access/storage recognized by the eXpOS. A word is assumed to be able to store an integer or a character string. Page: The memory is assumed to be divided into pages of contiguous memory words. It is assumed that the machine supports paging hardware. Disk: The secondary storage where data and program files are stored. The operating system is also stored in the disk and is loaded from the disk to the memory at the time of bootstrap. Block: The basic unit of disk access. A block can store a sequence of words. The number of words per block is hardware dependent. File: Each file is a sequence of words, stored in the disk. The most important file types are program files (or executable files or application programs) and data files. Process: An application program under execution is called a process. Kernel: The core part of the eXpOS operating system that forms a layer between the hardware and application programs. The kernel essentially is a collection of routines residing in the memory of the machine. In this document, the term operating system normally refers to the kernel. System Calls: These are kernel routines which application programs can invoke to do actions which only the OS reserves right to perform (Example: creating/modifying files or creating/destroying processes). Multiprogramming: Multiple processes reside in the memory simultaneously and the OS time-shares the machine between the processes by scheduling . The processes are said to execute concurrently. An OS that supports concurrent execution of processes is called a multiprogramming OS. Timer: The hardware device that interrupts the machine periodically. The scheduler is generally invoked by the timer interrupt service routine . User: Any person logged in and currently using the system to run processes. Login: The process which gives a user access to the system through username and password authentication. Primitive Concepts \u00b6 The OS specification assumes a generic hardware model described below. The arrows show interaction between various components of the system. The basic Machine model consists of memory, disk and the CPU. A small part of memory is assumed to contain a bootstrap loader stored permanently in ROM memory. These are machine instructions to load into the memory an OS startup code stored in a pre-defined area in the disk. The ROM code then transfers control to this newly loaded code. This code loads the operating system routines stored in (pre-defined areas of) the disk into memory and sets up the Operating system. This includes all the OS code for various system calls, the scheduler, the exception handler, device drivers etc. Further hardware support required like the timer, disk controller, Input-output system etc. are discussed later. For eXpOS to work, the machine should support two privilege levels of program execution. These are called the user mode (unprivileged mode) and the system mode (privileged mode). User programs (or application programs) run in user mode whereas OS routines run in system mode. The collection of OS routines that run in system mode is called the kernel of the operating system. A user program in execution is called a process . (Sometimes the term \"program\" may be (ab)used to refer to the corresponding process). An application process has access only to a limited set of machine instructions and can only access a limited set of memory addresses called the virtual address space of the process. This restricted machine model provided by the OS (of course, using the support from the machine architecture) is called the virtual machine model . The eXpOS logically divides the virtual address space of a process into library, code, stack and heap regions. eXpOS assumes that the machine provides paging hardware to implement the mapping of the virtual address space of a process into the physical memory of the machine. The following link discusses how such mapping is done. The discussion here assumes no segmentation support. (However, If the machine supports segmented paging , the mapping can be done more easily and profitably.) Data and program files are stored in the disk. The disk is typically divided into blocks and the machine provides instructions to transfer blocks into and out of the memory. These instructions can be accessed only in the system mode. The specific mechanisms available are hardware dependent. (The disk access model for XSM architecture is discussed here ). Note that since processes run in user mode, they can access disk files only by invoking the designated system calls for the purpose. User programs are generally stored as executable files in the disk. Typically the user writes the application programs in a high level language and a compiler generates the executable file. The eXpOS expects that executable files follow certain format and compilers must adhere to the format. This allows the eXpOS to figure out how much space must be allocated for library, stack, code and heap in the virtual address space when the program is loaded into memory for execution. The virtual machine model as well as the executable file format for eXpOS implementation in XSM are described in the eXpOS application binary interface documentation. At the end of the bootstrap process, the OS startup code hand-creates the first user process called the INIT process in memory. Thereafter, new processes can be created by existing processes by invoking the OS system calls for the purpose. Recall that the system call routines would have been set up in the memory during the bootstrap process. The INIT process creates a special user process called the shell process by loading and executing a shell program from the disk. The shell program repetitively reads user commands from the input and executes programs specified by the user and the OS becomes functional. The specification of the INIT and the shell process are described in this link . * In the extended eXpOS specification, the INIT process is called the LOGIN process and is executed directly by the kernel. This process invokes the login system call to log a user in. Once a user is logged in, the shell process is created for the user and the original login process waits for the termination of the user shell, to log in the next user. eXpOS treats the standard input and output devices just like special files. Hence user processes must use the system calls to read/write files to perform I/O operations. The underlying implementation details are hardware dependent and are left unspecified in the OS specification. Finally, eXpOS assumes that the machine is equipped with a hardware timer device that can interrupt the machine at pre-defined regular intervals. The timer is crucial for multiprogramming. The timer interrupt handler is the eXpOS kernel's scheduler routine which is responsible for timesharing the machine between processes. Similarly, disk/input-output devices may require a handler for interrupt service routines. These are hardware dependent and hence left unspecified in the OS specification. More details can be found in Section 6 .","title":"Overview"},{"location":"os-spec/overview/#terminology","text":"It is assumed that the reader has some working familiarity with the following terms and concepts. (The description of the machine used in this experiment is given here . However reading the description is NOT a prerequisite for this document.) Machine: The hardware/machine (computer) on which the operating system is running. (Physical) Memory: The physical memory (primary memory) of the machine. Word: The fundamental unit of memory access/storage recognized by the eXpOS. A word is assumed to be able to store an integer or a character string. Page: The memory is assumed to be divided into pages of contiguous memory words. It is assumed that the machine supports paging hardware. Disk: The secondary storage where data and program files are stored. The operating system is also stored in the disk and is loaded from the disk to the memory at the time of bootstrap. Block: The basic unit of disk access. A block can store a sequence of words. The number of words per block is hardware dependent. File: Each file is a sequence of words, stored in the disk. The most important file types are program files (or executable files or application programs) and data files. Process: An application program under execution is called a process. Kernel: The core part of the eXpOS operating system that forms a layer between the hardware and application programs. The kernel essentially is a collection of routines residing in the memory of the machine. In this document, the term operating system normally refers to the kernel. System Calls: These are kernel routines which application programs can invoke to do actions which only the OS reserves right to perform (Example: creating/modifying files or creating/destroying processes). Multiprogramming: Multiple processes reside in the memory simultaneously and the OS time-shares the machine between the processes by scheduling . The processes are said to execute concurrently. An OS that supports concurrent execution of processes is called a multiprogramming OS. Timer: The hardware device that interrupts the machine periodically. The scheduler is generally invoked by the timer interrupt service routine . User: Any person logged in and currently using the system to run processes. Login: The process which gives a user access to the system through username and password authentication.","title":"Terminology"},{"location":"os-spec/overview/#primitive-concepts","text":"The OS specification assumes a generic hardware model described below. The arrows show interaction between various components of the system. The basic Machine model consists of memory, disk and the CPU. A small part of memory is assumed to contain a bootstrap loader stored permanently in ROM memory. These are machine instructions to load into the memory an OS startup code stored in a pre-defined area in the disk. The ROM code then transfers control to this newly loaded code. This code loads the operating system routines stored in (pre-defined areas of) the disk into memory and sets up the Operating system. This includes all the OS code for various system calls, the scheduler, the exception handler, device drivers etc. Further hardware support required like the timer, disk controller, Input-output system etc. are discussed later. For eXpOS to work, the machine should support two privilege levels of program execution. These are called the user mode (unprivileged mode) and the system mode (privileged mode). User programs (or application programs) run in user mode whereas OS routines run in system mode. The collection of OS routines that run in system mode is called the kernel of the operating system. A user program in execution is called a process . (Sometimes the term \"program\" may be (ab)used to refer to the corresponding process). An application process has access only to a limited set of machine instructions and can only access a limited set of memory addresses called the virtual address space of the process. This restricted machine model provided by the OS (of course, using the support from the machine architecture) is called the virtual machine model . The eXpOS logically divides the virtual address space of a process into library, code, stack and heap regions. eXpOS assumes that the machine provides paging hardware to implement the mapping of the virtual address space of a process into the physical memory of the machine. The following link discusses how such mapping is done. The discussion here assumes no segmentation support. (However, If the machine supports segmented paging , the mapping can be done more easily and profitably.) Data and program files are stored in the disk. The disk is typically divided into blocks and the machine provides instructions to transfer blocks into and out of the memory. These instructions can be accessed only in the system mode. The specific mechanisms available are hardware dependent. (The disk access model for XSM architecture is discussed here ). Note that since processes run in user mode, they can access disk files only by invoking the designated system calls for the purpose. User programs are generally stored as executable files in the disk. Typically the user writes the application programs in a high level language and a compiler generates the executable file. The eXpOS expects that executable files follow certain format and compilers must adhere to the format. This allows the eXpOS to figure out how much space must be allocated for library, stack, code and heap in the virtual address space when the program is loaded into memory for execution. The virtual machine model as well as the executable file format for eXpOS implementation in XSM are described in the eXpOS application binary interface documentation. At the end of the bootstrap process, the OS startup code hand-creates the first user process called the INIT process in memory. Thereafter, new processes can be created by existing processes by invoking the OS system calls for the purpose. Recall that the system call routines would have been set up in the memory during the bootstrap process. The INIT process creates a special user process called the shell process by loading and executing a shell program from the disk. The shell program repetitively reads user commands from the input and executes programs specified by the user and the OS becomes functional. The specification of the INIT and the shell process are described in this link . * In the extended eXpOS specification, the INIT process is called the LOGIN process and is executed directly by the kernel. This process invokes the login system call to log a user in. Once a user is logged in, the shell process is created for the user and the original login process waits for the termination of the user shell, to log in the next user. eXpOS treats the standard input and output devices just like special files. Hence user processes must use the system calls to read/write files to perform I/O operations. The underlying implementation details are hardware dependent and are left unspecified in the OS specification. Finally, eXpOS assumes that the machine is equipped with a hardware timer device that can interrupt the machine at pre-defined regular intervals. The timer is crucial for multiprogramming. The timer interrupt handler is the eXpOS kernel's scheduler routine which is responsible for timesharing the machine between processes. Similarly, disk/input-output devices may require a handler for interrupt service routines. These are hardware dependent and hence left unspecified in the OS specification. More details can be found in Section 6 .","title":"Primitive Concepts"},{"location":"os-spec/processmodel/","text":"A program under execution is called a process. A process is newly created when a process already in execution invokes the Fork system call. The first process, the INIT process, is created by the OS during bootstrap by loading a code stored in a pre-defined disk location to memory and setting up a process. The OS assigns a unique integer identifier called process id for each process when it is created. The process id does not change during the lifetime of the process. The process that creates the new process is called the parent process of the newly created process. In Multiuser implemention of eXpOS, each process is assigned a userid corresponding to the currently logged in user. The structure of Processes \u00b6 eXpOS associates a virtual (memory) address space for each process. Shared Library Heap Text/Code Stack The address space of a process is a contiguous sequence of memory addresses, starting from zero, accessible to a process. The maximum limit on the address space of a process is 5120 (10 pages). The eXpOS logically partitions the address space into four regions library, heap, code and stack . These regions are mapped into physical memory using hardware mechanisms like paging/segmentation. (Mapping virtual to physical address in XSM) . Every process corresponds to some executable file stored in XEXE format stored in the XFS file system. The XEXE header of the executable file contains the information about how much space must be allocated for the various memory regions. When the program is loaded into memory by the operating system, the OS reads the header and sets up the regions of the virtual address space accordingly. Once the layout of the virtual address space is clear, the OS maps the virtual address space into the physical memory. The part of the OS which does all these tasks is called the OS loader . The eXpOS loader is the interrupt service routine corresponding to the Exec system call. A process may open files or semaphores. The OS associates a file handle with each open instance of a file. The semantics of file handle is discussed here . Similarly, the OS assigns a semaphore identifier ( semid ) for each semaphore acquired by the process. The file handles and semids acquired by a process are also attributes of a process. Note: In addition to the above attributes of a process that are visible to application/system programs, a process under execution at any given point of time has an execution context . The context of a process refers to the contents of the registers, instruction pointer, contents of the memory etc. These are hardware dependent and are managed internally by the OS. In fact, managing the execution contexts of multiple processes simultaneously and running them all in one machine is the main challenge in the design and implementation of a multiprogramming OS. However, the OS hides these internal details from the application programs as well as system programs like compilers. Hence, they are part of this documentation. A process can get its process id using the Getpid system call. The pid of the parent process can be obtained using the Getppid system call. Operations on Processes \u00b6 The two most fundamental operations associated with process are Fork and Exec . The remaining operations are Exit, Wait, Signal, Getpid and Getppid. Semantics of Exec operation: \u00b6 The OS closes all files and semaphores opened by the process. A new address space is created replacing the existing one. ( what happens to the original address space is irrelevant to the application/system programmer. But it is important to know that any other process sharing code/heap/library regions with this process will not be affected. This is discussed in Section 5 ). The new process inherits the process id of the calling process. The code (and static data, if any) of the executable file are loaded into the code (and stack) regions of the new address space. The system library is mapped to the library region and stack is initialized to empty. The machine instruction pointer is set to the location specified in the executable header. The machine stack pointer is initialized to the beginning of the stack. (These details are hidden from the application programmer by the compiler if a high level language is used for writing the application.). From here, execution continues with the newly loaded program. When a process executes the Fork system call, the following sequence of events occur. Semantics of Fork operation: \u00b6 A new child process with a new process id and address space is created which is an exact replica of the original process with the same library, code,stack and heap regions. (The OS assigns a new process id for the child and returns this value to the parent as the return parameter of the fork system call.) The heap, code and library regions of the parent are shared by the child. This means, any modification of contents of these regions by one process during subsequent execution will change the other as well. Note that both processes are in concurrent execution subsequent to the fork operation. Stack is separate for the child and is not shared. All open file handles and semaphores are shared by the parent and the child. Note that file handles (or semaphore identifiers) of files (or semaphores) that are opened (or created) subsequent to the fork operation by the parent or the child will be exclusive to the particular process and will not be shared. The parent and the child continue execution from here on. The Exit system call terminates a process after closing all files and semaphores. The Wait system call suspends the execution of a process till another process exits or executes a Signal system call. (System calls for access control and synchronization) . The Signal system call resumes the execution of a process that was suspended by wait. Wait and Signal operations are discussed in more detail in the next section. In Multiuser implemention of eXpOS, the child inherits the userid of the parent process . Special Processes in eXpOS \u00b6 eXpOS specifies two special processes, the idle and the init process. These are stored in a predefined location in the disk and loaded to the memory by the bootstrap loader. The main purpose of idle process is to run as a background process in an infinite loop. This is demanded by the OS so that the scheduler will always have a process to schedule. The init process is the first process executed by the OS. The process identifiers for the idle and init processes are fixed as 0 and 1 respectively. A shell is an ExpL program which takes the name of an executable file as input and executes it. The shell process Forks itself and the child process invokes the Exec system call with the executable file as argument. The shell runs until the user stops the process. In the Multiuser extension of eXpOS , the init process is responsible for logging in users and hence, called the Login process. The process identifier for shell in this case is 2.","title":"Process Model"},{"location":"os-spec/processmodel/#the-structure-of-processes","text":"eXpOS associates a virtual (memory) address space for each process. Shared Library Heap Text/Code Stack The address space of a process is a contiguous sequence of memory addresses, starting from zero, accessible to a process. The maximum limit on the address space of a process is 5120 (10 pages). The eXpOS logically partitions the address space into four regions library, heap, code and stack . These regions are mapped into physical memory using hardware mechanisms like paging/segmentation. (Mapping virtual to physical address in XSM) . Every process corresponds to some executable file stored in XEXE format stored in the XFS file system. The XEXE header of the executable file contains the information about how much space must be allocated for the various memory regions. When the program is loaded into memory by the operating system, the OS reads the header and sets up the regions of the virtual address space accordingly. Once the layout of the virtual address space is clear, the OS maps the virtual address space into the physical memory. The part of the OS which does all these tasks is called the OS loader . The eXpOS loader is the interrupt service routine corresponding to the Exec system call. A process may open files or semaphores. The OS associates a file handle with each open instance of a file. The semantics of file handle is discussed here . Similarly, the OS assigns a semaphore identifier ( semid ) for each semaphore acquired by the process. The file handles and semids acquired by a process are also attributes of a process. Note: In addition to the above attributes of a process that are visible to application/system programs, a process under execution at any given point of time has an execution context . The context of a process refers to the contents of the registers, instruction pointer, contents of the memory etc. These are hardware dependent and are managed internally by the OS. In fact, managing the execution contexts of multiple processes simultaneously and running them all in one machine is the main challenge in the design and implementation of a multiprogramming OS. However, the OS hides these internal details from the application programs as well as system programs like compilers. Hence, they are part of this documentation. A process can get its process id using the Getpid system call. The pid of the parent process can be obtained using the Getppid system call.","title":"The structure of Processes"},{"location":"os-spec/processmodel/#operations-on-processes","text":"The two most fundamental operations associated with process are Fork and Exec . The remaining operations are Exit, Wait, Signal, Getpid and Getppid.","title":"Operations on Processes"},{"location":"os-spec/processmodel/#semantics-of-exec-operation","text":"The OS closes all files and semaphores opened by the process. A new address space is created replacing the existing one. ( what happens to the original address space is irrelevant to the application/system programmer. But it is important to know that any other process sharing code/heap/library regions with this process will not be affected. This is discussed in Section 5 ). The new process inherits the process id of the calling process. The code (and static data, if any) of the executable file are loaded into the code (and stack) regions of the new address space. The system library is mapped to the library region and stack is initialized to empty. The machine instruction pointer is set to the location specified in the executable header. The machine stack pointer is initialized to the beginning of the stack. (These details are hidden from the application programmer by the compiler if a high level language is used for writing the application.). From here, execution continues with the newly loaded program. When a process executes the Fork system call, the following sequence of events occur.","title":"Semantics of Exec operation:"},{"location":"os-spec/processmodel/#semantics-of-fork-operation","text":"A new child process with a new process id and address space is created which is an exact replica of the original process with the same library, code,stack and heap regions. (The OS assigns a new process id for the child and returns this value to the parent as the return parameter of the fork system call.) The heap, code and library regions of the parent are shared by the child. This means, any modification of contents of these regions by one process during subsequent execution will change the other as well. Note that both processes are in concurrent execution subsequent to the fork operation. Stack is separate for the child and is not shared. All open file handles and semaphores are shared by the parent and the child. Note that file handles (or semaphore identifiers) of files (or semaphores) that are opened (or created) subsequent to the fork operation by the parent or the child will be exclusive to the particular process and will not be shared. The parent and the child continue execution from here on. The Exit system call terminates a process after closing all files and semaphores. The Wait system call suspends the execution of a process till another process exits or executes a Signal system call. (System calls for access control and synchronization) . The Signal system call resumes the execution of a process that was suspended by wait. Wait and Signal operations are discussed in more detail in the next section. In Multiuser implemention of eXpOS, the child inherits the userid of the parent process .","title":"Semantics of Fork operation:"},{"location":"os-spec/processmodel/#special-processes-in-expos","text":"eXpOS specifies two special processes, the idle and the init process. These are stored in a predefined location in the disk and loaded to the memory by the bootstrap loader. The main purpose of idle process is to run as a background process in an infinite loop. This is demanded by the OS so that the scheduler will always have a process to schedule. The init process is the first process executed by the OS. The process identifiers for the idle and init processes are fixed as 0 and 1 respectively. A shell is an ExpL program which takes the name of an executable file as input and executes it. The shell process Forks itself and the child process invokes the Exec system call with the executable file as argument. The shell runs until the user stops the process. In the Multiuser extension of eXpOS , the init process is responsible for logging in users and hence, called the Login process. The process identifier for shell in this case is 2.","title":"Special Processes in eXpOS"},{"location":"os-spec/shell-spec/","text":"The eXpOS shell program is designed to repeatedly ask for user commands and execute the command specified by the user. There are two types of commands that the user can input to the shell: Built in Shell commands \u00b6 Built in shell commands are Newusr (to create a new user) Remusr (to remove a user), 3) Setpwd (set the password of a user) Getuid (to get the user-id of the currently logged in user) Getuname (to get the username of the currently logged in user) Logout (logout the current user) Shutdown (to shutdown the system after committing back the memory copies of all disk data structures into the disk). To execute the system call for the corresponding shell command - eg : For the system call Newusr, enter the string \"Newusr\" (without quotes) from the console. Upon receipt of one of these commands, the shell directly asks the user for the input arguments for the corresponding system call (for example - setpwd requires the username and the new password to be entered) and invokes the corresponding system call directly to execute the command. In all the above cases except logout and shutdown, the shell continues to ask the user for the next command after execution of the system call. If the executed system call for the input command is not successful, then shell simply prints \"BAD COMMAND\". Executable commands/filenames \u00b6 An executable command is essentially the name of an executable file. In such case, shell first spawns a child using the Fork system call and the parent (shell) waits for the child to do an Exit upon completion of command execution. The child runs the input file using the Exec system call. If Exec fails, then child prints \u201cBAD COMMAND\u201d and executes the Exit system call to activate the shell again. eXpOS specifies that some standard executable programs called ( system utilities ) are supplied to the user along with the OS implementation. These programs essentially help the user to manipulate files using the shell. They are listed below: List all files \u00b6 Command : ls.xsm Input : - Semantics : Displays the names of all the files present in the disk. Remove a File \u00b6 Command : rm.xsm Input : filename Semantics : Removes a data file filename from the disk. Copy content of one file to another \u00b6 Command : cp.xsm Input : filename1, filename2 Semantics : Copies the word to word data from a file filename1 to the file filename2 . ( filename1 can be only data or root file.) Print the content of a file \u00b6 Command : cat.xsm Input : filename Semantics : Displays the content of the file filename . List all users \u00b6 Command : lu.xsm Input : - Semantics : Displays the names of all the users in the system. Remove all files owned by a user \u00b6 Command : ru.xsm Input : username Semantics : Deletes all the data files owned by the user with name username . (Typically it is executed from the root user to delete all the files owned by a user before removing the user from the system.) A sample shell implementation is given here . The details of implementation of system utilities are left to the OS programmer. Since eXpOS ABI does not support command line arguments, these programs may need to ask the user for inputs (like filename in the case of the cat command) using the Read system call. The eXpOS specification stipulates that shell always executes from the context of the currently logged in user. The shell is spawned by the login process .","title":"eXpOS Shell Specification"},{"location":"os-spec/shell-spec/#built-in-shell-commands","text":"Built in shell commands are Newusr (to create a new user) Remusr (to remove a user), 3) Setpwd (set the password of a user) Getuid (to get the user-id of the currently logged in user) Getuname (to get the username of the currently logged in user) Logout (logout the current user) Shutdown (to shutdown the system after committing back the memory copies of all disk data structures into the disk). To execute the system call for the corresponding shell command - eg : For the system call Newusr, enter the string \"Newusr\" (without quotes) from the console. Upon receipt of one of these commands, the shell directly asks the user for the input arguments for the corresponding system call (for example - setpwd requires the username and the new password to be entered) and invokes the corresponding system call directly to execute the command. In all the above cases except logout and shutdown, the shell continues to ask the user for the next command after execution of the system call. If the executed system call for the input command is not successful, then shell simply prints \"BAD COMMAND\".","title":"Built in Shell commands"},{"location":"os-spec/shell-spec/#executable-commandsfilenames","text":"An executable command is essentially the name of an executable file. In such case, shell first spawns a child using the Fork system call and the parent (shell) waits for the child to do an Exit upon completion of command execution. The child runs the input file using the Exec system call. If Exec fails, then child prints \u201cBAD COMMAND\u201d and executes the Exit system call to activate the shell again. eXpOS specifies that some standard executable programs called ( system utilities ) are supplied to the user along with the OS implementation. These programs essentially help the user to manipulate files using the shell. They are listed below:","title":"Executable commands/filenames"},{"location":"os-spec/shell-spec/#list-all-files","text":"Command : ls.xsm Input : - Semantics : Displays the names of all the files present in the disk.","title":"List all files"},{"location":"os-spec/shell-spec/#remove-a-file","text":"Command : rm.xsm Input : filename Semantics : Removes a data file filename from the disk.","title":"Remove a File"},{"location":"os-spec/shell-spec/#copy-content-of-one-file-to-another","text":"Command : cp.xsm Input : filename1, filename2 Semantics : Copies the word to word data from a file filename1 to the file filename2 . ( filename1 can be only data or root file.)","title":"Copy content of one file to another"},{"location":"os-spec/shell-spec/#print-the-content-of-a-file","text":"Command : cat.xsm Input : filename Semantics : Displays the content of the file filename .","title":"Print the content of a file"},{"location":"os-spec/shell-spec/#list-all-users","text":"Command : lu.xsm Input : - Semantics : Displays the names of all the users in the system.","title":"List all users"},{"location":"os-spec/shell-spec/#remove-all-files-owned-by-a-user","text":"Command : ru.xsm Input : username Semantics : Deletes all the data files owned by the user with name username . (Typically it is executed from the root user to delete all the files owned by a user before removing the user from the system.) A sample shell implementation is given here . The details of implementation of system utilities are left to the OS programmer. Since eXpOS ABI does not support command line arguments, these programs may need to ask the user for inputs (like filename in the case of the cat command) using the Read system call. The eXpOS specification stipulates that shell always executes from the context of the currently logged in user. The shell is spawned by the login process .","title":"Remove all files owned by a user"},{"location":"os-spec/synchronization/","text":"eXpOS assumes a single processor multi programming environment. This means that all processes exist concurrently in the machine and the OS time shares the machine between various processes. The OS specification requires that Round Robin scheduling is used with co-operative time-sharing. This is discussed in Section 6 . The OS does not provide any promise to the application program about the order in which processes will be executed. However, application programs often need to stop and wait for another process to execute certain operations before proceeding. The OS provides system calls that allow user processes to synchronize execution. Process Synchronization \u00b6 eXpOS provides the Wait and Signal system calls for process synchronization. When a process executes the wait system call specifying the process id of another process as argument, the OS puts the calling process to sleep. This means, the OS will schedule the process out and won't execute it until one of the following events occur: The process specified as argument terminates by the exit system call. The process specified as argument executes a Signal system call. The specification of Signal and Wait system calls are given here . Access Control \u00b6 A second major concurrency related requirement is that when multiple processes access the same data (in memory or files), it is often required to have some kind of locking mechanism to ensure that when one process is accessing the shared data, no other process is allowed to modify the same. This is to ensure data integrity and this issue is called the critical section problem . eXpOS provides (binary) semaphores to allow application programs to handle the critical section problem. A (binary) semaphore is conceptually a binary-valued variable whose value can be set or reset only by the OS through designated system call. (Internally how it is implemented is an OS concern and is oblivious to the application programmer). A process can acquire a semaphore using the Semget system call, which returns a unique semid for the semaphore. The semaphore is initially not set. A process may open several files and semaphores and execute the Fork system call multiple times to create an several process that shares all the opened file handles, the heap memory region and all the semaphores acquired by the parent. Any of these processes sharing a semaphore identifier can set the semaphore (called locking) using the SemLock system call giving the semid as an argument. SemUnLock will reset (called release) the semaphore waking up all other processes which went to sleep trying to lock the semaphore. Semantics of Locking operation for semaphores \u00b6 If the semaphore/file is already locked, the process goes to sleep and wakes up only when the semaphore/file is free. Otherwise, process locks the semaphore/file and continues execution.","title":"Synchronization and Access Control"},{"location":"os-spec/synchronization/#process-synchronization","text":"eXpOS provides the Wait and Signal system calls for process synchronization. When a process executes the wait system call specifying the process id of another process as argument, the OS puts the calling process to sleep. This means, the OS will schedule the process out and won't execute it until one of the following events occur: The process specified as argument terminates by the exit system call. The process specified as argument executes a Signal system call. The specification of Signal and Wait system calls are given here .","title":"Process Synchronization"},{"location":"os-spec/synchronization/#access-control","text":"A second major concurrency related requirement is that when multiple processes access the same data (in memory or files), it is often required to have some kind of locking mechanism to ensure that when one process is accessing the shared data, no other process is allowed to modify the same. This is to ensure data integrity and this issue is called the critical section problem . eXpOS provides (binary) semaphores to allow application programs to handle the critical section problem. A (binary) semaphore is conceptually a binary-valued variable whose value can be set or reset only by the OS through designated system call. (Internally how it is implemented is an OS concern and is oblivious to the application programmer). A process can acquire a semaphore using the Semget system call, which returns a unique semid for the semaphore. The semaphore is initially not set. A process may open several files and semaphores and execute the Fork system call multiple times to create an several process that shares all the opened file handles, the heap memory region and all the semaphores acquired by the parent. Any of these processes sharing a semaphore identifier can set the semaphore (called locking) using the SemLock system call giving the semid as an argument. SemUnLock will reset (called release) the semaphore waking up all other processes which went to sleep trying to lock the semaphore.","title":"Access Control"},{"location":"os-spec/synchronization/#semantics-of-locking-operation-for-semaphores","text":"If the semaphore/file is already locked, the process goes to sleep and wakes up only when the semaphore/file is free. Otherwise, process locks the semaphore/file and continues execution.","title":"Semantics of Locking operation for semaphores"},{"location":"os-spec/systemcallinterface/","text":"Application programmers interact with the Operating System using the system calls. System calls are stored in the disk and are loaded into memory when the OS is loaded by the bootstrap loader. When a process invokes a system call, the process is interrupted and control goes to the corresponding interrupt service routine of the kernel, resulting in a switch from user mode to kernel mode. Once the system call is carried out, the control goes back to the application program, with a switch back to the user mode. The system calls of eXpOS are classified into file system calls, process system calls and system calls for access control and synchronization. * In addition to this, Multiuser extension of eXpOS includes system calls for handling multiple users. File System Calls \u00b6 Create \u00b6 Arguments: Filename (String), Permission (Integer) Return Value: 0 Success/File already exists -1 No free inode table entry Description: The Create operation takes as input a filename and creates an empty file by that name. If a root entry for the file already exists, then the system call returns 0 (success). Otherwise, it creates a root entry for the file name, sets the file type to DATA and file size to 0. * In Multiuser implementation, the file permission is either 0 or 1, indicating file is open-access or exclusive respectively. If the exclusive flag is set, write and delete system calls will fail except when made by the owner or the root. Delete \u00b6 Arguments: Filename (String) Return Value: 0 Success -1 Permission Denied -2 File is open Description: Delete removes the file from the file system and removes its root entry. A file that is currently opened by any application cannot be deleted. Root file and Executable files also cannot be deleted. * In addition to this in Multiuser implementation, data files which are created with exclusive permission, cannot be deleted by any user other than the owner, root or kernel. Open \u00b6 Arguments: Filename (String) Return Value: File Descriptor (Integer) Success, the return value is the file descriptor for the opened file. -1 File not found or file is not a data file or root file -2 System has reached its limit of open files -3 Process has reached its limit of resources Description: For a process to read/write a file, it must first open the file. Only data and root files can be opened. The Open operation returns a file descriptor. An application can open the same file several times and each time, a different descriptor will be returned by the Open operation. The file descriptor must be passed as argument to other file system calls, to identify the open instance of the file. The OS associates a file pointer with every open instance of a file. The file pointer indicates the current location of file access (read/write). The Open system call sets the file pointer to 0 (beginning of the file). Close \u00b6 Arguments: File Descriptor (Integer) 0 Success -1 File Descriptor given is invalid Description: After all the operations are done, the user closes the file using the Close system call. The file descriptor ceases to be valid once the close system call is invoked. Read \u00b6 Arguments: File Descriptor (Integer) and a Buffer (a String/Integer variable) into which a word is to be read from the file Return Value: 0 Success -1 File Descriptor given is invalid -2 File pointer has reached the end of file Description: The file descriptor is used to identify an open instance of the file. The Read operation reads one word from the position pointed by the file pointer and stores it into the buffer. After each read operation, the file pointer advances to the next word in the file. Write \u00b6 Arguments: File Descriptor(Integer) and the word to be written Return Value: 0 Success -1 File Descriptor given is invalid -2 No disk space / File Full -3 Permission denied Description: The file descriptor is used to identify an open instance of the file. The Write operation writes the word passed as argument to the position pointed by the file pointer of the file. After each Write operation, the file pointer advances to the next word in the file. Root file and Executable files cannot be written. * In addition to this in Multiuser implementation, data files which are created with exclusive permission, cannot be written into by any user other than the owner, root or kernel. Seek \u00b6 Arguments: File Descriptor (Integer) and Offset (Integer) specifying the number of positions by which the file pointer has to be shifted 0 Success -1 File Descriptor given is invalid -2 Offset value moves the file pointer to a position outside the file Description: The Seek operation allows the application program to change the value of the file pointer so that subsequent Read/Write is performed from a new position in the file. The new value of the file pointer is determined by adding the offset to the current value. (A negative Offset will move the pointer backwards). An Offset of 0 will reset the pointer to the beginning of the file. An offset that moves beyond the end of the file will set the file pointer to the end of the file, then returns -2. This is useful to append data to the file. Process System Calls \u00b6 Fork \u00b6 Arguments: None Return Value: PID (Integer) Success, the return value to the parent is the process descriptor(PID) of the child process. 0 Success, the return value to the child. -1 Failure, Number of processes has reached the maximum limit. Returns to the parent Description: Replicates the process invoking the system call. The heap, code and library regions of the parent are shared by the child. A new stack is allocated to the child and the parent's stack is copied into the child's stack. When a process executes the Fork system call, the child process shares with the parent all the file and semaphore descriptors previously acquired by the parent. Semaphore/file descriptors acquired subsequent to the fork operation by either the child or the parent will be exclusive to the respective process and will not be shared. * In Multiuser implementation, the child process inherits the userid of the parent process. Exec \u00b6 Arguments: File Name (String) of the executable file (which must be of XEXE format) Return Value: -1 File not found or file is of invalid type -2 Out of memory or disk swap space Description: Exec destroys the present process and loads the executable file given as input into a new memory address space. A successful Exec operation results in the extinction of the invoking application and hence never returns to it. All open instances of file and semaphores of the parent process are closed. However, the newly created process will inherit the PID of the calling process. * In Multiuser implementation, the newly created process inherits the userid of the invoking process. Exit \u00b6 Arguments: None Return Value: None Description: Exit system call terminates the execution of the process which invoked it and destroys its memory address space. The calling application ceases to exist after the system call and hence the system call never returns. All processes waiting for this process using Wait system call , are awakened on exit of this process. Exit never fails. * In Multiuser implementation, if the process created by the login process (shell) exits, all processes with that userid has to be killed and the login process that was waiting for its exit has to be awakened. Getpid \u00b6 Arguments: None Return Value: Process Identifier (Integer) Success Description: Returns the process identifier of the invoking process. The system call does not fail. Getppid \u00b6 Arguments: None Return Value: Parent Process Identifier (Integer) Success Description: Returns to the calling process the value of the process identifier of its parent. The system call does not fail. Shutdown \u00b6 Arguments: None Return Value: -1 Permission denied Description: Shutdown system call terminates all processes and halts the machine. * In Multiuser implemention of eXpOS, only processes with the user as either the root or kernel can execute shutdown system call. System Calls for access control and synchronization \u00b6 Wait \u00b6 Arguments: Process Identifier (Integer) of the process for which the current process has to wait. Return Value: 0 Success -1 Given process identifier is invalid or it is the pid of the invoking process. Description: The current process is blocked till the process with PID given as argument executes a Signal system call or exits. Note that the system call will fail if a process attempts to wait for itself. Signal \u00b6 Arguments: None Return Value: 0 Success Description: All processes waiting for the signaling process are resumed. The system call does not fail. Semget \u00b6 Argument: None Return Value : SEMID (Integer) Success, returns a semaphore descriptor(SEMID) -1 Process has reached its limit of resources -2 Number of semaphores has reached its maximum Description: This system call is used to obtain a binary semaphore. eXpOS has a fixed number of semaphores. The calling process can share the semaphore with its child processes using the fork system call Semrelease \u00b6 Arguments: Semaphore Descriptor (Integer) Return Value: 0 Success -1 Semaphore Descriptor is invalid Description: This system call is used to release a semaphore descriptor held by the process. SemLock \u00b6 Arguments: Semaphore Descriptor (Integer) Return Value: 0 Success or the semaphore is already locked by the current process -1 Semaphore Descriptor is invalid Description: This system call is used to lock the semaphore. If the semaphore is already locked by some other process, then the calling process goes to sleep and wakes up only when the semaphore is unlocked. Otherwise, it locks the semaphore and continues execution. SemUnLock \u00b6 Arguments: Semaphore Descriptor (Integer) Return Value: 0 Success -1 Semaphore Descriptor is invalid -2 Semaphore was not locked by the calling process Description: This system call is used to unlock a semaphore that was previously locked by the calling process. It wakes up all the processes which went to sleep trying to lock the semaphore while the semaphore was locked by the calling process. Multiuser System Calls \u00b6 Newusr \u00b6 Arguments: User name, Password Return Value: 0 Success -1 User already exists -2 Permission denied -3 Number of users have reached the system limit Description: This system call is used to create a new user. It checks whether the user already exists. If not, it creates a new user with the username and password specified. This system call can be executed only by the shell process of root user. Remusr \u00b6 Arguments: User name Return Value: 0 Success -1 User does not exist -2 Permission denied -3 Undeleted files exist for the user Description: This system call is used to remove an existing user. This system call can be executed from the shell proces of the root user. The root user and kernel cannot be removed. Setpwd \u00b6 Arguments: User name, New Password Return Value: 0 Success -1 Unauthorised attempt to change password -2 The user does not exist. Description: This system call is used to change the password of an existing user. This system call can be exected only from the shell process. A user can set only his/her password. Root user can set any user's password. Getuid \u00b6 Arguments: User name Return Value: User Identifier Success -1 Invalid Username Description: If the username is valid, this system call returns the userid corresponding to the username. Otherwise, it returns -1. Getuname \u00b6 Arguments: User ID Return Value: User Name Success -1 Invalid UserID Description: If the userid is valid, this system call returns the username corresponding to the userid. Otherwise, it returns -1. Login \u00b6 Arguments: User name, Password Return Value: 0 Success -1 Invalid username or password -2 Permission denied Description: This system call is used to login a new user. It can be executed only from the login process. It verifies the user. Upon successful login, a new user process (shell) with the userid of the user specified is created and the calling process goes to sleep till the exit of the newly created shell process. Logout \u00b6 Arguments: None Return Value: -1 on error, otherwise does not return Description: This system call is used to logout the current user. It can be invoked only from the shell process (PID = 2). When the logout system call is invoked, all running processes of the current user are terminated and all resources released. Idle and init/Login will be the only processes running after the execution of Logout. Login is woken up at the end of logout.","title":"High Level System Call Interface"},{"location":"os-spec/systemcallinterface/#file-system-calls","text":"","title":"File System Calls"},{"location":"os-spec/systemcallinterface/#create","text":"Arguments: Filename (String), Permission (Integer) Return Value: 0 Success/File already exists -1 No free inode table entry Description: The Create operation takes as input a filename and creates an empty file by that name. If a root entry for the file already exists, then the system call returns 0 (success). Otherwise, it creates a root entry for the file name, sets the file type to DATA and file size to 0. * In Multiuser implementation, the file permission is either 0 or 1, indicating file is open-access or exclusive respectively. If the exclusive flag is set, write and delete system calls will fail except when made by the owner or the root.","title":"Create"},{"location":"os-spec/systemcallinterface/#delete","text":"Arguments: Filename (String) Return Value: 0 Success -1 Permission Denied -2 File is open Description: Delete removes the file from the file system and removes its root entry. A file that is currently opened by any application cannot be deleted. Root file and Executable files also cannot be deleted. * In addition to this in Multiuser implementation, data files which are created with exclusive permission, cannot be deleted by any user other than the owner, root or kernel.","title":"Delete"},{"location":"os-spec/systemcallinterface/#open","text":"Arguments: Filename (String) Return Value: File Descriptor (Integer) Success, the return value is the file descriptor for the opened file. -1 File not found or file is not a data file or root file -2 System has reached its limit of open files -3 Process has reached its limit of resources Description: For a process to read/write a file, it must first open the file. Only data and root files can be opened. The Open operation returns a file descriptor. An application can open the same file several times and each time, a different descriptor will be returned by the Open operation. The file descriptor must be passed as argument to other file system calls, to identify the open instance of the file. The OS associates a file pointer with every open instance of a file. The file pointer indicates the current location of file access (read/write). The Open system call sets the file pointer to 0 (beginning of the file).","title":"Open"},{"location":"os-spec/systemcallinterface/#close","text":"Arguments: File Descriptor (Integer) 0 Success -1 File Descriptor given is invalid Description: After all the operations are done, the user closes the file using the Close system call. The file descriptor ceases to be valid once the close system call is invoked.","title":"Close"},{"location":"os-spec/systemcallinterface/#read","text":"Arguments: File Descriptor (Integer) and a Buffer (a String/Integer variable) into which a word is to be read from the file Return Value: 0 Success -1 File Descriptor given is invalid -2 File pointer has reached the end of file Description: The file descriptor is used to identify an open instance of the file. The Read operation reads one word from the position pointed by the file pointer and stores it into the buffer. After each read operation, the file pointer advances to the next word in the file.","title":"Read"},{"location":"os-spec/systemcallinterface/#write","text":"Arguments: File Descriptor(Integer) and the word to be written Return Value: 0 Success -1 File Descriptor given is invalid -2 No disk space / File Full -3 Permission denied Description: The file descriptor is used to identify an open instance of the file. The Write operation writes the word passed as argument to the position pointed by the file pointer of the file. After each Write operation, the file pointer advances to the next word in the file. Root file and Executable files cannot be written. * In addition to this in Multiuser implementation, data files which are created with exclusive permission, cannot be written into by any user other than the owner, root or kernel.","title":"Write"},{"location":"os-spec/systemcallinterface/#seek","text":"Arguments: File Descriptor (Integer) and Offset (Integer) specifying the number of positions by which the file pointer has to be shifted 0 Success -1 File Descriptor given is invalid -2 Offset value moves the file pointer to a position outside the file Description: The Seek operation allows the application program to change the value of the file pointer so that subsequent Read/Write is performed from a new position in the file. The new value of the file pointer is determined by adding the offset to the current value. (A negative Offset will move the pointer backwards). An Offset of 0 will reset the pointer to the beginning of the file. An offset that moves beyond the end of the file will set the file pointer to the end of the file, then returns -2. This is useful to append data to the file.","title":"Seek"},{"location":"os-spec/systemcallinterface/#process-system-calls","text":"","title":"Process System Calls"},{"location":"os-spec/systemcallinterface/#fork","text":"Arguments: None Return Value: PID (Integer) Success, the return value to the parent is the process descriptor(PID) of the child process. 0 Success, the return value to the child. -1 Failure, Number of processes has reached the maximum limit. Returns to the parent Description: Replicates the process invoking the system call. The heap, code and library regions of the parent are shared by the child. A new stack is allocated to the child and the parent's stack is copied into the child's stack. When a process executes the Fork system call, the child process shares with the parent all the file and semaphore descriptors previously acquired by the parent. Semaphore/file descriptors acquired subsequent to the fork operation by either the child or the parent will be exclusive to the respective process and will not be shared. * In Multiuser implementation, the child process inherits the userid of the parent process.","title":"Fork"},{"location":"os-spec/systemcallinterface/#exec","text":"Arguments: File Name (String) of the executable file (which must be of XEXE format) Return Value: -1 File not found or file is of invalid type -2 Out of memory or disk swap space Description: Exec destroys the present process and loads the executable file given as input into a new memory address space. A successful Exec operation results in the extinction of the invoking application and hence never returns to it. All open instances of file and semaphores of the parent process are closed. However, the newly created process will inherit the PID of the calling process. * In Multiuser implementation, the newly created process inherits the userid of the invoking process.","title":"Exec"},{"location":"os-spec/systemcallinterface/#exit","text":"Arguments: None Return Value: None Description: Exit system call terminates the execution of the process which invoked it and destroys its memory address space. The calling application ceases to exist after the system call and hence the system call never returns. All processes waiting for this process using Wait system call , are awakened on exit of this process. Exit never fails. * In Multiuser implementation, if the process created by the login process (shell) exits, all processes with that userid has to be killed and the login process that was waiting for its exit has to be awakened.","title":"Exit"},{"location":"os-spec/systemcallinterface/#getpid","text":"Arguments: None Return Value: Process Identifier (Integer) Success Description: Returns the process identifier of the invoking process. The system call does not fail.","title":"Getpid"},{"location":"os-spec/systemcallinterface/#getppid","text":"Arguments: None Return Value: Parent Process Identifier (Integer) Success Description: Returns to the calling process the value of the process identifier of its parent. The system call does not fail.","title":"Getppid"},{"location":"os-spec/systemcallinterface/#shutdown","text":"Arguments: None Return Value: -1 Permission denied Description: Shutdown system call terminates all processes and halts the machine. * In Multiuser implemention of eXpOS, only processes with the user as either the root or kernel can execute shutdown system call.","title":"Shutdown"},{"location":"os-spec/systemcallinterface/#system-calls-for-access-control-and-synchronization","text":"","title":"System Calls for access control and synchronization"},{"location":"os-spec/systemcallinterface/#wait","text":"Arguments: Process Identifier (Integer) of the process for which the current process has to wait. Return Value: 0 Success -1 Given process identifier is invalid or it is the pid of the invoking process. Description: The current process is blocked till the process with PID given as argument executes a Signal system call or exits. Note that the system call will fail if a process attempts to wait for itself.","title":"Wait"},{"location":"os-spec/systemcallinterface/#signal","text":"Arguments: None Return Value: 0 Success Description: All processes waiting for the signaling process are resumed. The system call does not fail.","title":"Signal"},{"location":"os-spec/systemcallinterface/#semget","text":"Argument: None Return Value : SEMID (Integer) Success, returns a semaphore descriptor(SEMID) -1 Process has reached its limit of resources -2 Number of semaphores has reached its maximum Description: This system call is used to obtain a binary semaphore. eXpOS has a fixed number of semaphores. The calling process can share the semaphore with its child processes using the fork system call","title":"Semget"},{"location":"os-spec/systemcallinterface/#semrelease","text":"Arguments: Semaphore Descriptor (Integer) Return Value: 0 Success -1 Semaphore Descriptor is invalid Description: This system call is used to release a semaphore descriptor held by the process.","title":"Semrelease"},{"location":"os-spec/systemcallinterface/#semlock","text":"Arguments: Semaphore Descriptor (Integer) Return Value: 0 Success or the semaphore is already locked by the current process -1 Semaphore Descriptor is invalid Description: This system call is used to lock the semaphore. If the semaphore is already locked by some other process, then the calling process goes to sleep and wakes up only when the semaphore is unlocked. Otherwise, it locks the semaphore and continues execution.","title":"SemLock"},{"location":"os-spec/systemcallinterface/#semunlock","text":"Arguments: Semaphore Descriptor (Integer) Return Value: 0 Success -1 Semaphore Descriptor is invalid -2 Semaphore was not locked by the calling process Description: This system call is used to unlock a semaphore that was previously locked by the calling process. It wakes up all the processes which went to sleep trying to lock the semaphore while the semaphore was locked by the calling process.","title":"SemUnLock"},{"location":"os-spec/systemcallinterface/#multiuser-system-calls","text":"","title":"Multiuser System Calls"},{"location":"os-spec/systemcallinterface/#newusr","text":"Arguments: User name, Password Return Value: 0 Success -1 User already exists -2 Permission denied -3 Number of users have reached the system limit Description: This system call is used to create a new user. It checks whether the user already exists. If not, it creates a new user with the username and password specified. This system call can be executed only by the shell process of root user.","title":"Newusr"},{"location":"os-spec/systemcallinterface/#remusr","text":"Arguments: User name Return Value: 0 Success -1 User does not exist -2 Permission denied -3 Undeleted files exist for the user Description: This system call is used to remove an existing user. This system call can be executed from the shell proces of the root user. The root user and kernel cannot be removed.","title":"Remusr"},{"location":"os-spec/systemcallinterface/#setpwd","text":"Arguments: User name, New Password Return Value: 0 Success -1 Unauthorised attempt to change password -2 The user does not exist. Description: This system call is used to change the password of an existing user. This system call can be exected only from the shell process. A user can set only his/her password. Root user can set any user's password.","title":"Setpwd"},{"location":"os-spec/systemcallinterface/#getuid","text":"Arguments: User name Return Value: User Identifier Success -1 Invalid Username Description: If the username is valid, this system call returns the userid corresponding to the username. Otherwise, it returns -1.","title":"Getuid"},{"location":"os-spec/systemcallinterface/#getuname","text":"Arguments: User ID Return Value: User Name Success -1 Invalid UserID Description: If the userid is valid, this system call returns the username corresponding to the userid. Otherwise, it returns -1.","title":"Getuname"},{"location":"os-spec/systemcallinterface/#login","text":"Arguments: User name, Password Return Value: 0 Success -1 Invalid username or password -2 Permission denied Description: This system call is used to login a new user. It can be executed only from the login process. It verifies the user. Upon successful login, a new user process (shell) with the userid of the user specified is created and the calling process goes to sleep till the exit of the newly created shell process.","title":"Login"},{"location":"os-spec/systemcallinterface/#logout","text":"Arguments: None Return Value: -1 on error, otherwise does not return Description: This system call is used to logout the current user. It can be invoked only from the shell process (PID = 2). When the logout system call is invoked, all running processes of the current user are terminated and all resources released. Idle and init/Login will be the only processes running after the execution of Logout. Login is woken up at the end of logout.","title":"Logout"},{"location":"roadmap/","text":"This roadmap is divided into stages. Each stage is to be done in sequential order. You will build eXpOS incrementally. Links are provided throughout the document for further reference. There are two kinds of links. The contents of the important links must be read immediately before proceeding with the roadmap. The informative links may be clicked for more information about a particular concept. However this information may not be necessary at that point and you may proceed with the roadmap without visiting these links. It is very important that you proceed with the roadmap on a regular schedule and not get lost in the links. Hence, an approximate amount of time (in hours) which you are expected to spend on each stage is noted along with the stage. If you find that reading a particular documentation/link takes too much time, skip it for the time being and come back to it only when needed. Preparatory Stages: The preparatory stages help you to get familiarized with the disk bootstrap loading process, disk access mechanism, file-system specification, debugger, paging hardware, interrupt handling mechanism, program loading, library linkage and function calling conventions, application binary interface (ABI), context switching between applications and so forth. You will need 2-3 weeks to complete these stages. Stage 1 : Setting up the System Stage 2 : Understanding the Filesystem (2 Hours) Stage 3 : Bootstrap Loader (2 Hours) Stage 4 : Learning the SPL Language (2 Hours) Stage 5 : XSM Debugging (2 Hours) Stage 6 : Running a user program (4 Hours) Stage 7 : ABI and XEXE Format (2 Hours) Stage 8 : Handling Timer Interrupt (2 Hours) Stage 9 : Handling kernel stack (4 Hours) Stage 10 : Console output (4 Hours) Stage 11 : Introduction to ExpL (4 Hours) Stage 12 : Introduction to Multiprogramming (4 Hours) Intermediate Stages In these stages, you will come across more advanced hardware features like, disk interrupt handling and exception handling. You will be implementing some basic kernel subsystems that will be used throughout the project. You will modularize your kernel into functional subsystems for resource management, memory management, device management, etc. You will implement a primitive user interface (Shell) and the final version of the OS loader (Exec system call). The amount of implementation details given in the road map will gradually diminish and many details will be left to be worked out by you. You wil need 3-4 weeks to complete these stages. Stage 13 : Boot Module (4 Hours) Stage 14 : Round robin scheduler (4 Hours) Stage 15 : Resource Manager Module (4 Hours) Stage 16 : Console Input (6 Hours) Stage 17 : Program Loader (6 Hours) Stage 18 : Disk Interrupt Handler (6 Hours) Stage 19 : Exception Handler (6 Hours) Final Stages Stage 20-Stage 27 are the final stages of the project where you will implement all the system calls stipulated in the ABI documentation. Typically 5-6 weeks will be needed to complete these stages. At the end of the twentieth stage, basic system calls for process creation and termination \u2013 Fork, Exec and Exit will be completed. The next two stages take up system calls implementing signals and semaphores. The next three stages address the implementation of the file system. The subsequent stages add multi-user support and virtual memory support. (An advanced stage (Stage 28) describing how the OS can be ported to a two-core extension of the XSM machine has been added subsequently.) Stage 20 : Process Creation and Termination (12 Hours) Stage 21 : Process Synchronization (4 Hours) Stage 22 : Semaphores (4 Hours) Stage 23 : File Creation and Deletion (6 Hours) Stage 24 : File Read (12 Hours) Stage 25 : File Write (12 Hours) Stage 26 : User Management (12 Hours) Stage 27 : Pager Module (18 Hours) Stage 28 : Multi-Core Extension (12 Hours)","title":"Roadmap"},{"location":"roadmap/stage-01/","text":"Learning Objectives At the end of this experiment, you will learn how to set up the environment to build eXpOS. Please follow the setting up procedure from here . After the setting up of the system is done correctly the following directories will be created.","title":"Stage 1"},{"location":"roadmap/stage-02/","text":"Learning Objectives Load/retrieve data and executable files from/to your host (Unix) system into the XSM disk. Explain the disk data structures of the XFS file system - INODE table, disk free list and root file. Find out the data blocks into which a data/executable file is stored in the XSM disk by examining the INODE table and root file. Pre-requisite Reading Quickly go through the Filesystem (eXpFS) Specification and XFS-Interface Specification (interface between the UNIX System and eXpFS). Do not spent more than 30 minutes! The eXpOS package that you had downloaded in the previous stage consists mainly of a machine simulator. The machine is called the eXperimental String Machine (XSM) and consists of a processor, memory and disk. Some support tools that help you to program the machine are also provided. One important point to note about the system is that the machine is a bare, and comes with no software in it (except for a boot ROM). Hence, the only way to insert some software code into the system is to prepare the code \"outside\" (that is, in your Linux/Unix system) and insert your code into the machine. The support tools provided along with the package are precisely designed to help you with this task. The package comes with three major support tools - two compilers and a disk interface tool called XFS-Interface . The compilers allow you to write high level code and translate it into the XSM machine code. We will look at them in later stages. The XFS-Inteface tool helps you to transfer files between your Linux/Unix system and the XSM machines disk. XSM machine's disk contains 512 blocks, each capable of storing 512 words. When files are stored in the disk, some format has to be followed so that one can figure out where in the disk are the blocks of a file located. XSM disk is formatted to what is known as the eXpFS file system format . The format specifies how data as well as meta-data for each file stored in the disk must be organized. The XFS interface tool allows you to load data files (and executable files as well) from your Linux/Unix system into the XSM disk in accordance with the eXpFS format. The eXpFS format specifies that each data/executable file can span across at most four data blocks, and that the index to these blocks along with the name and the size of the file must be stored in a pre-define area of the disk called the Inode table . (The inode table is stored in disk blocks 3 and 4). There are also other pre-defined areas of the disk that stores meta data about the disk (see description of the root file and the disk free list for more details). When you use XFS interface to load a file from your Linux/Unix system to the XSM disk, the interface tool will correctly fill all the required meta data information as stipulated by the eXpFS format. The eXperimental Filesystem (eXpFS) is a simulated filesystem. A UNIX file named \"disk.xfs\" simulates the hard disk of the XSM machine. Building eXpOS begins with understanding the underlying filesystem (eXpFS) and its interface (xfs-interface) to the host (UNIX) environment. The xfs-interface is used for transferring files between your linux system and the xsm disk. Schematic interface between linux system and XSM disk In this stage, you will create a text file and load it to the XFS disk using xfs-interface. Run the XFS Interface cd $HOME/myexpos/xfs-interface ./xfs-interface This will take you to the xfs-interface prompt. Start by formatting the disk to the eXpOS file system format in the XFS interface using fdisk command. The fdisk< command converts the raw disk into the filesystem format recognised by the eXpOS operating system. It initialises the disk data structures such as disk free list, inode table, user table and root file . Type the following commands in the xfs-interface prompt. # fdisk # exit You will be back in the UNIX shell and a file named disk.xfs is created in the location $HOME/myexpos/xfs-interface/ . This UNIX file simulates the hard disk of the XSM machine. The disk is formatted to eXperimental File System (eXpFS) (see eXpFS Specification ). The XSM machine's disk is a sequence of 512 blocks, each block capable of holding 512 words (see Disk Organization ). The second block of the formatted disk contains a disk free list which is explained below. The Disk Free List in XFS is a data structure which keeps track of used and unused blocks in the disk. An unused block is indicated by 0 and a used block is indicated by 1. Check the contents of the Disk Free List after formatting the disk. Use the df command to view the Disk Free List (stored in disk block number 2). The output will be as follows: 0 - 1 1 - 1 2 - 1 3 - 1 4 - 1 5 - 1 6 - 1 7 - 1 8 - 1 9 - 1 10 - 1 11 - 1 12 - 1 13 - 1 14 - 1 15 - 1 16 - 1 17 - 1 18 - 1 19 - 1 20 - 1 21 - 1 22 - 1 23 - 1 24 - 1 25 - 1 . . No of Free Blocks = 443 Total No of Blocks = 512 The first 69 blocks (blocks 0 to 68) are reserved for stroing various OS data structures and routines as well as Idle code, INIT program, etc (see Disk Organization) . Hence the Disk Free List entries for these are marked as 1 (used) and the remaining entries for blocks 69 to 511 are 0 (unused). Create a file in your UNIX machine with sample data. A sample data file is given below: There is a place where the sidewalk ends And before the street begins, And there the grass grows soft and white, And there the sun burns crimson bright, And there the moon-bird rests from his flight To cool in the peppermint wind. Save the file as $HOME/myexpos/sample.dat Load this data file $HOME/myexpos/sample.dat to the XFS disk from your UNIX machine. This can be done by the following commands: cd $HOME/myexpos/xfs-interface ./xfs-interface This will take you to the xfs-interface prompt. Type the following commands. # load --data $HOME/myexpos/sample.dat This will load the file to the XFS disk and the following updations happen in disk data structures : 1) A disk block will be allocated for the file (as sample.dat contains less than 512 words) and corresponding to this allocated block (here block 69 - this is because the 1 st free block is allocated by the allocator), an entry will be marked as 1 (used) in the Disk Free List . 2) An entry in the InodeTable will be created for this file. Inode Table contains information such as the file type, file name, file size, userid, permission and the block numbers of the data of data files loaded through xfs-interface is the root . Userid is the index of the user entry in the User Table .The userid of root is 1 and hence the userid field in the inode table is set to 1 for all data files loaded through the xfs interface . The permission is set to open(1). Note that any file in eXpFS file system is permitted to have a maximum of four data blocks. 3) An entry for this file will be made in the Root File also. Before proceeding further you must be clear about eXpFS (eXperimental File System) . In the following steps we will see the above mentioned updations. Find out the block numbers of the Data Blocks corresponding to the loaded file. Use the copy command to copy the Inode Table (Inode Table is stored in disk blocks 3 and 4) to a UNIX file (say $HOME/myexpos/inode_table.txt ). # copy 3 4 $HOME/myexpos/inode_table.txt # exit Note The Inode table occupies only the first 960 words (60 entries, each of size 16 words) in the disk blocks 3 and 4. User table occupies the next 32 words (16 entries, each of size 2 words) and the last 32 words are reserved for future use. (You will learn about User Table later on). Now check the Inode table entry for the file sample.dat in the UNIX file inode_table.txt and find the block numbers of its data blocks. The contents of the file inode_table.txt will be as follows: 1 root 512 0 0 -1 -1 -1 5 -1 -1 -1 -1 -1 -1 -1 2 sample.dat 19 1 1 -1 -1 -1 69 -1 -1 -1 -1 -1 -1 -1 -1 . . . Note Instead of using the copy command you can use dump command provided by the XFS interface to directly copy the disk data structures (inode table, root file) to the UNIX machine as shown below. # dump --inodeusertable This will write the contents of the inodetable into the file $HOME/myexpos/xfs-interface/inodeusertable.txt Now check the contents of the disk free list and verify that the entry for the 69 th block is marked as used. This corresponds to the Data Block 1 of sample.dat . Copy the data blocks from the XFS disk and display it as a UNIX file $HOME/myexpos/data.txt . # copy 69 69 $HOME/myexpos/data.txt You will get back the contents of the file $HOME/myexpos/sample.dat in $HOME/myexpos/data.txt . However in $HOME/myexpos/data.txt , each word is displayed in a line because a word in XFS is 16 characters long. Sample data.txt file is shown below. There is a plac e where the sid ewalk ends And before the street begins, And there the g rass grows soft and white, And there the s un burns crimso n bright, And there the m oon-bird rests from his flight To cool in the peppermint wind xfs-interface provides the export command to export files from the XSM machine to the UNIX machine in a single step. Export the file sample.dat to the UNIX file $HOME/myexpos/data.txt using xfs-inteface as shown below and verify that the contents are same as sample.dat. # export sample.dat $HOME/myexpos/data.txt Q1. When a file is created entries are made in the Inode table as well as the Root file. What is the need for this duplication? Inode table is a data structure which is accessible only in Kernel mode, whereas Root file is accessible both in Kernel and User mode. This enables the user to search for a file from an application program itself by reading the Root file. Assignment 1 Copy the contents of Root File (from Block 5 of XFS disk) to a UNIX file $HOME/myexpos/root_file.txt and verify that an entry for sample.dat is made in it also. Assignment 2 Delete the sample.dat from the XSM machine using xfs-interface and note the changes for the entries for this file in inode table, root file and disk free list .","title":"Stage 2"},{"location":"roadmap/stage-03/","text":"Learning Objectives Use the XSM Instruction set to write a small OS startup code. Load your OS startup code into the boot block of the disk and get this code executed on bootstrap. Pre-requisite Reading Have a quick look at XSM Machine Organisation . (Do not spend more than 15 minutes). Have a quick look at XSM Instruction set . (Do not spend more than 15 minutes). It is absolutely necessary to read the XSM privileged mode execution tutorial before proceeding further. When the XSM machine is started up, the ROM Code , which resides in page 0 of the memory, is executed. It is hard-coded into the machine. That is, the ROM code at physical address 0 (to 511) is \"already there\" when machine starts up. The ROM code is called the \"Boot ROM\" in OS literature. Boot ROM code does the following operations : Loads block 0 of the disk to page 1 of the memory (physical address 512). After loading the block to memory, it sets the value of the register IP (Instruction Pointer) to 512 so that the next instruction is fetched from location 512 (page 1 in memory starts from location 512). In this stage, you will write a small assembly program to print \"HELLO_WORLD\" using XSM Instruction set and load it into block 0 of the disk using XFS-Interface as the OS Startup Code . As described above, this OS Startup Code is loaded from disk block 0 to memory page 1 by the ROM Code on machine startup and is then executed. The steps to do this are explained in detail below. 1) Create the assembly program to print \"HELLO_WORLD\". The assembly code to print \"HELLO_WORLD\" : MOV R0, \"HELLO_WORLD\" MOV R16, R0 PORT P1, R16 OUT HALT Save this file as $HOME/myexpos/spl/spl_progs/helloworld.xsm . 2) Load the file as OS Startup code to disk.xfs using XFS-Interface. Invoke the XFS interface and use the following command to load the OS Startup Code cd $HOME/myexpos/xfs-interface ./xfs-interface # load --os $HOME/myexpos/spl/spl_progs/helloworld.xsm # exit Note that the --os option loads the file to Block 0 of the XFS disk. 3) Run the machine cd $HOME/myexpos/xsm ./xsm The machine will halt after printing \"HELLO_WORLD\". HELLO_WORLD Machine is halting. Note The XSM simulator given to you is an assembly language interpeter for XSM. Hence, it is possible to load and run assembly language programs on the simulator (unlike real systems where binary programs need to be supplied). If the OS Startup Code is loaded to some other page other than Page 1, will XSM work fine? No. This is because after the execution of the ROM Code, IP points to 512 which is the 1 st instruction of Page 1. So if the OS Startup Code is not loaded to Page 1, it results in an exception and leads to system crash. Assignment 1 Write an assembly program to print numbers from 1 to 20 and run it as the OS Startup code.","title":"Stage 3"},{"location":"roadmap/stage-04/","text":"Learning Objectives Use the SPL language to write a small OS startup code and generate target using the SPL compiler. Pre-requisite Reading Quickly go through SPL specification . (Do not spend more than 15 minutes). SPL (Systems Programming Language) allows high level programs to be written for the XSM machine (eliminating the need to write all the code in assembly language). SPL is not a full fledged programming language, but is an extension to the XSM assembly language with support for high level constructs like if-then-else, while-do etc. Programs written in SPL language needs to be compiled to XSM assembly code using the SPL compiler supplied along with the eXpOS package before loading for execution on the XSM simulator. You will be writing the eXpOS kernel using the SPL language. In this stage you will write a program in SPL and compile it using the SPL compiler. After compilation, the target machine code is generated. We will then load this compiled code to block 0 of the disk as the OS startup code, using the XFS-Interface, and get it executed by the machine as in the previous stage. 1) Create the program to print odd numbers from 1 to 20 using SPL. (You can see more examples of SPL programs in $HOME/myexpos/spl/samples .) Here is the SPL Code to print odd numbers from 1 to 20 : alias counter R0; counter = 0; while(counter <= 20) do if(counter%2 != 0) then print counter; endif; counter = counter + 1; endwhile; SPL doesn't support variables. Instead you can directly use XSM registers for storing program data. For convenience, you can alias the registers with appropriate identifiers to imitate the behaviour of variables. In the above program register R0 is aliased to the identifier counter . 2) Save this file as $HOME/myexpos/spl/spl_progs/oddnos.spl . Compile this SPL program using the commands cd $HOME/myexpos/spl ./spl $HOME/myexpos/spl/spl_progs/oddnos.spl Go through the generated assembly code in file 'oddnos.xsm' and make sure that the generated assembly code indeed gives the desired output. 3) Load the file generated by the SPL compiler ( $HOME/myexpos/spl/spl_progs/oddnos.xsm ) as the OS startup code to disk.xfs using the XFS Interface. 4) Run the machine. The machine will halt after printing all odd numbers from 1 to 20. 1 3 5 7 9 11 13 15 17 19 Machine is halting Assignment 1 Write the spl program to print sum of squares of the first 20 natural numbers. Load it using xfs interface and run the in the machine.","title":"Stage 4"},{"location":"roadmap/stage-05/","text":"Learning Objectives Getting familiarised with the XSM Debugger. Pre-requisite Reading Read and understand the Debugger Specification In this stage you will write an SPL program with a breakpoint statement. The breakpoint statement translates to the BRKP machine instruction and is used for debugging. If the XSM machine is run in the Debug mode , on encountering the BRKP instruction, the machine simulator will suspend the program execution and allow you to inspect the values of the registers, memory, os data structures etc. Execution resumes only after you instruct the simulator to proceed. 1) Write an SPL code to generate odd numbers from 1 to 10. Add a debug instruction in between : alias counter R0; counter = 0; while(counter <= 10) do if(counter%2 != 0) then breakpoint; endif; counter = counter + 1; endwhile; 2) Compile the program using the SPL compiler. 3) Load the compiled xsm code as OS startup code into the XSM disk using the XFS interface. 4) Run the machine in debug mode. cd $HOME/myexpos/xsm ./xsm --debug 5) The Machine pauses after the execution of the first BRKP instruction. View the contents of registers using the command reg Enter the following command mem 1 This will write the contents of memory page 1 to the file mem inside the xsm folder (if xsm is run from any other directory then the file mem will be created in that directory). Open this file and view the contents. Use the following command step to the next instruction. s 6) Press c to continue execution till the BRKP instruction is executed again. You can see that the content of R0 register changes during each iteration. c","title":"Stage 5"},{"location":"roadmap/stage-06/","text":"Learning Objectives Learn how to set up the address space for an application. Run an init program in user mode from the OS startup code. Pre-requisite Reading It is absolutely necessary to read and understand the tutorial on XSM Unprivileged Mode Execution before proceeding further. Have a quick look at the XSM specification documentation on Virtual Machine Model and Address Translation Mechanism . Before proceeding further, try to solve the following question that test your understanding of XSM Unprivileged Mode Execution Q1: Suppose the machine is executing in unprivileged mode. Assume that the following are some of the register values: IP: 3000, PTBR: 29696, SP: 5000, PTLR: 10 Which physical memory location will contain the physical page number of the page from which the machine will fetch the next instruction? 29706 Suppose further that the memory location 29706 contains value 100. What will be the physical memory address from which the XSM machine will fetch the next instruction? 51640 Suppose the instruction stored at memory address 51640 is JMP 3080, which all registers will be updated? IP will be updated to 3080 Suppose the instruction stored in memory address was MOV R0,[4096]. From which physical address will value be fetched and transferred to register R0? Assume that the value stored in memory address 29712 is 75. 38400 Suppose the instruction stored at memory address 51640 was MOV R0, [7000], what will happen? The machine will try to translate the logical address 7000 to the corresponding physical address. The logical page number 7000/512 = 13. However, since the PTLR value is 10 and the logical page number exceeds the value of PTLR, this is an illegal memory access. Consequently, the machine will generate an exception. You will learn about exceptions in later stages. In the previous stages, you wrote and executed system programs in privileged (kernel) mode. In this stage, you will write a user program in assembly code and execute it in unprivileged (user) mode. The first user program which is executed is called the INIT program * . The eXpOS design stipulates that the INIT program must be stored in blocks 7 and 8 of the XSM disk. See Disk Organisation . In this stage, first you will write a user program in assembly language and load it into the disk as the INIT program using XFS-Interface. You will then write the OS startup code such that it loads the INIT program into the memory and initiate its execution at the time of system startup. In OS jargon, a user program in execution is called a \"process\" . Thus, in this stage, you are going to run the first user process. Typically the OS maintains some memory data structures associated with each process - like the process table, page table, user area etc. For now, we will not be concerned with most of these data structures except the page table. In later stages, you will be introduced to these data structures one by one. Note At many places in this roadmap a process is identified with the underlying program in execution when there can be no scope for confusion. Note * In later stages, you will see that eXpOS actually schedules the idle process once before the INIT process is scheduled for the first time. This is done to ensure that the idle process is scheduled for execution at least once, so that the OS data structures associated with the idle process are not left un-initialized. User Program \u00b6 The following code illustrates the INIT program used in this stage. It computes squares of first 5 numbers. The value of Register R1 during each iteration will hold the result. //Program to calculate Squares of first 5 numbers // R0 will hold value of n // R1 will hold value of n^2 //Initialising R0(n) to 1 MOV R0, 1 _L1: // Exit loop if n < 5 MOV R2, 5 GE R2, R0 JZ R2, _L2 // Computing n^2 in R1 MOV R1, R0 MUL R1, R0 //breakpoint instruction (to view contents of R1) BRKP // n = n + 1 ADD R0, 1 JMP _L1 _L2: EXIT // End of Program. While executing in the user mode, the machine uses logical addressing scheme. The machine translates logical addresses to physical addresses using the address translation mechanism . In this stage, we will use a simple logical memory model where the first two logical pages are alloted for code (address 0 - 1023) and the third logical page is alloted for the stack (address 1024 - 1535). The actual logical memory model used in eXpOS is different and will be explained in the later stages. The above code contains labels that are not recognised by the XSM machine. Since the code section occupies first two pages according to our memory model, the code address begins from logical address 0 . Hence, we will translate the labels accordingly. The code is given in bold and the corresponding addresses are added for reference. In the roadmap, the path of the file is assumed to be $HOME/myexpos/expl/expl_progs/squares.xsm 0 MOV R0, 1 2 MOV R2, 5 4 GE R2, R0 6 JZ R2, 18 8 MOV R1, R0 10 MUL R1, R0 12 BRKP 14 ADD R0, 1 16 JMP 2 18 INT 10 The methods for terminal input and output of user programs have not been studied till now. (Note that IN and OUT are privileged instructions and cannot be used in user mode programs). Hence you have to use the debug mode to view the contents of register R1 to watch the ouput. Interrupt handlers for input and output from user programs will be discussed in later stages. Load this file to the XSM disk as the INIT program using XFS interface. # load --init $HOME/myexpos/expl/expl_progs/squares.xsm The xfs-interface will store squares.xsm program to disk blocks 7-8. INT 10 \u00b6 At the end of the program, a user program calls the exit system call to return control back to the operating system. This is acheived by an INT 10 instruction. INT 10 instruction will invoke the software interrupt handler 10. This interrupt handler is responsible for graceful termination of the user program. Interrupt handlers and system calls will be covered in detail in later stages of the roadmap. Since we have only one user process for now, we will write the interrupt 10 handler with only the \"halt\" statement. 1) Create a file haltprog.spl with a single halt statement. halt; 2) Compile the program 3) Load the compiled code as INT 10 from the xfs-interface load --int=10 ../spl/spl_progs/haltprog.xsm Exception handler \u00b6 We also load the exception handler routine to memory. The machine may raise an exception if it encounters any unexpected events like illegal instruction, invalid address, page table entry for a logical page not set valid etc. Our default action is to halt machine execution in the case of an exception. In later stages you will learn to handle exceptions in a more elaborate way. Load the haltprog.xsm used above as the exception handler using XFS-interface load --exhandler ../spl/progs/haltprog.xsm OS Startup Code \u00b6 The OS startup code of any operating system, which is the first piece of OS code to be executed on bootstrap, is responsible for loading the rest of the OS into the memory, initialize OS data structures and set up the first user program for execution. In this stage, we will write the OS startup code to load the init program and setup the OS data structures necessary to run the program as a process. Finally, the OS startup code will transfer control to the init program using the IRET instruction. 1) Load the INIT program from the disk to the memory. In the memory, init program is stored in pages 65-66. The blocks 7-8 from disk is to be loaded to the memory pages 65-66 by the OS startup Code. (See Memory Organization and Disk Organization ). loadi(65,7); loadi(66,8); Load the INT10 module from the disk to the memory. loadi(22,35); loadi(23,36); Load the exception handler routine from the disk to the memory. loadi(2, 15); loadi(3, 16); Note the use of the loadi instruction for loading a disk block to a memory page. The loadi instruction will suspend the execution of the XSM machine till the disk to memory transfer is completed. XSM will execute the next instruction after the transfer is complete. (In later stages you will use the load instruction that can help to speed up execution). 2) Page Table for INIT must be set up for address translation scheme to work correctly. This is because INIT is a user process and all addresses generated are logical. Machine translates these logical addresses to physical addresses by looking up the page table for INIT. The PTBR or Page Table Base Register stores the starting address of the page table of a process.We must set PTBR to the starting address of the page table of INIT. The eXpOS memory organization stipulates that the page tables are stored from memory address 29696. Here since we are running the first user program, we will use the first few entries of this memory region for setting up the page table for the INIT process. The SPL constant PAGE_TABLE_BASE holds the value 29696. You need two pages for storing the INIT program code (loaded from disk blocks 7 and 8) and one additional page for stack (why?). Hence, PTLR is set to value 3. PTBR = PAGE_TABLE_BASE; PTLR = 3; 3) In the page table of INIT, set page numbers 65 and 66 for code and 76 for stack. (Pages 67 - 75 are reserved. See Memory Organisation .) Thus, the first word of each entry must be set to the corresponding physical page number (65 ,66 and 76).Set the second word ( Auxiliary information ) for pages 65 and 66 to \"0100\" and page 76 to \"0110\". This sets the code pages \"read only\" and stack \"read/write\". (why?) [PTBR+0] = 65; [PTBR+1] = \"0100\"; [PTBR+2] = 66; [PTBR+3] = \"0100\"; [PTBR+4] = 76; [PTBR+5] = \"0110\"; Note Here we have introduced a simple memory model with 2 page code and 1 page stack memory. The actual memory model which you will be using is different and will be explained in the later stages. 4) The OS Startup Code transfers control of execution to the user program using an IRET instruction. An IRET performs the following operations i. The privilege mode is changed from KERNEL to USER mode. ii. The instruction pointer is set to the value at the top of the user stack iii. The value of SP is decremented by 1 The code of this program must execute from logical address 0. Hence IP or the instruction pointer needs to be set to 0 before the user program starts execution. As IP cannot be set explicitly, push 0, which is the value of starting IP to the top of the stack, and IRET instruction will implicitly set the IP to this value. Since the OS Startup Code runs in KERNEL mode, physical address must be used to access the top of the stack. Stack of INIT process is allocated at physical page number 76. Its corresponding physical address is 76 * 512. The stack pointer must be set to point to this address so that IRET fetches the correct address. [76*512] = 0; SP = 2*512; 5)Use the ireturn instruction to transfer control to user program. ireturn translates to IRET machine instruction ireturn; Making Things Work \u00b6 1) Save the OS startup Code as $HOME/myexpos/spl/spl_progs/os_startup.spl . Compile this file using SPL compiler. cd $HOME/myexpos/spl ./spl $HOME/myexpos/spl/spl_progs/os_startup.spl 2) This will generate a file $HOME/myexpos/spl/spl_progs/os_startup.xsm . Load this file as the OS startup code to disk.xfs using the XFS Interface. Invoke the XFS interface and use the following command to load the OS Startup Code. # load --os $HOME/myexpos/spl/spl_progs/os_startup.xsm # exit 3) Run the machine in debug mode. (We will disable the timer for now). cd $HOME/myexpos/xsm/ ./xsm --debug --timer 0 4) View the contents of R1 at each step. Assignment 1 Change virtual memory model such that code occupies logical pages 4 and 5 and the stack lies in logical page 8. You will have to modify the user program as well as the os startup code.","title":"Stage 6"},{"location":"roadmap/stage-06/#user-program","text":"The following code illustrates the INIT program used in this stage. It computes squares of first 5 numbers. The value of Register R1 during each iteration will hold the result. //Program to calculate Squares of first 5 numbers // R0 will hold value of n // R1 will hold value of n^2 //Initialising R0(n) to 1 MOV R0, 1 _L1: // Exit loop if n < 5 MOV R2, 5 GE R2, R0 JZ R2, _L2 // Computing n^2 in R1 MOV R1, R0 MUL R1, R0 //breakpoint instruction (to view contents of R1) BRKP // n = n + 1 ADD R0, 1 JMP _L1 _L2: EXIT // End of Program. While executing in the user mode, the machine uses logical addressing scheme. The machine translates logical addresses to physical addresses using the address translation mechanism . In this stage, we will use a simple logical memory model where the first two logical pages are alloted for code (address 0 - 1023) and the third logical page is alloted for the stack (address 1024 - 1535). The actual logical memory model used in eXpOS is different and will be explained in the later stages. The above code contains labels that are not recognised by the XSM machine. Since the code section occupies first two pages according to our memory model, the code address begins from logical address 0 . Hence, we will translate the labels accordingly. The code is given in bold and the corresponding addresses are added for reference. In the roadmap, the path of the file is assumed to be $HOME/myexpos/expl/expl_progs/squares.xsm 0 MOV R0, 1 2 MOV R2, 5 4 GE R2, R0 6 JZ R2, 18 8 MOV R1, R0 10 MUL R1, R0 12 BRKP 14 ADD R0, 1 16 JMP 2 18 INT 10 The methods for terminal input and output of user programs have not been studied till now. (Note that IN and OUT are privileged instructions and cannot be used in user mode programs). Hence you have to use the debug mode to view the contents of register R1 to watch the ouput. Interrupt handlers for input and output from user programs will be discussed in later stages. Load this file to the XSM disk as the INIT program using XFS interface. # load --init $HOME/myexpos/expl/expl_progs/squares.xsm The xfs-interface will store squares.xsm program to disk blocks 7-8.","title":"User Program"},{"location":"roadmap/stage-06/#int-10","text":"At the end of the program, a user program calls the exit system call to return control back to the operating system. This is acheived by an INT 10 instruction. INT 10 instruction will invoke the software interrupt handler 10. This interrupt handler is responsible for graceful termination of the user program. Interrupt handlers and system calls will be covered in detail in later stages of the roadmap. Since we have only one user process for now, we will write the interrupt 10 handler with only the \"halt\" statement. 1) Create a file haltprog.spl with a single halt statement. halt; 2) Compile the program 3) Load the compiled code as INT 10 from the xfs-interface load --int=10 ../spl/spl_progs/haltprog.xsm","title":"INT 10"},{"location":"roadmap/stage-06/#exception-handler","text":"We also load the exception handler routine to memory. The machine may raise an exception if it encounters any unexpected events like illegal instruction, invalid address, page table entry for a logical page not set valid etc. Our default action is to halt machine execution in the case of an exception. In later stages you will learn to handle exceptions in a more elaborate way. Load the haltprog.xsm used above as the exception handler using XFS-interface load --exhandler ../spl/progs/haltprog.xsm","title":"Exception handler"},{"location":"roadmap/stage-06/#os-startup-code","text":"The OS startup code of any operating system, which is the first piece of OS code to be executed on bootstrap, is responsible for loading the rest of the OS into the memory, initialize OS data structures and set up the first user program for execution. In this stage, we will write the OS startup code to load the init program and setup the OS data structures necessary to run the program as a process. Finally, the OS startup code will transfer control to the init program using the IRET instruction. 1) Load the INIT program from the disk to the memory. In the memory, init program is stored in pages 65-66. The blocks 7-8 from disk is to be loaded to the memory pages 65-66 by the OS startup Code. (See Memory Organization and Disk Organization ). loadi(65,7); loadi(66,8); Load the INT10 module from the disk to the memory. loadi(22,35); loadi(23,36); Load the exception handler routine from the disk to the memory. loadi(2, 15); loadi(3, 16); Note the use of the loadi instruction for loading a disk block to a memory page. The loadi instruction will suspend the execution of the XSM machine till the disk to memory transfer is completed. XSM will execute the next instruction after the transfer is complete. (In later stages you will use the load instruction that can help to speed up execution). 2) Page Table for INIT must be set up for address translation scheme to work correctly. This is because INIT is a user process and all addresses generated are logical. Machine translates these logical addresses to physical addresses by looking up the page table for INIT. The PTBR or Page Table Base Register stores the starting address of the page table of a process.We must set PTBR to the starting address of the page table of INIT. The eXpOS memory organization stipulates that the page tables are stored from memory address 29696. Here since we are running the first user program, we will use the first few entries of this memory region for setting up the page table for the INIT process. The SPL constant PAGE_TABLE_BASE holds the value 29696. You need two pages for storing the INIT program code (loaded from disk blocks 7 and 8) and one additional page for stack (why?). Hence, PTLR is set to value 3. PTBR = PAGE_TABLE_BASE; PTLR = 3; 3) In the page table of INIT, set page numbers 65 and 66 for code and 76 for stack. (Pages 67 - 75 are reserved. See Memory Organisation .) Thus, the first word of each entry must be set to the corresponding physical page number (65 ,66 and 76).Set the second word ( Auxiliary information ) for pages 65 and 66 to \"0100\" and page 76 to \"0110\". This sets the code pages \"read only\" and stack \"read/write\". (why?) [PTBR+0] = 65; [PTBR+1] = \"0100\"; [PTBR+2] = 66; [PTBR+3] = \"0100\"; [PTBR+4] = 76; [PTBR+5] = \"0110\"; Note Here we have introduced a simple memory model with 2 page code and 1 page stack memory. The actual memory model which you will be using is different and will be explained in the later stages. 4) The OS Startup Code transfers control of execution to the user program using an IRET instruction. An IRET performs the following operations i. The privilege mode is changed from KERNEL to USER mode. ii. The instruction pointer is set to the value at the top of the user stack iii. The value of SP is decremented by 1 The code of this program must execute from logical address 0. Hence IP or the instruction pointer needs to be set to 0 before the user program starts execution. As IP cannot be set explicitly, push 0, which is the value of starting IP to the top of the stack, and IRET instruction will implicitly set the IP to this value. Since the OS Startup Code runs in KERNEL mode, physical address must be used to access the top of the stack. Stack of INIT process is allocated at physical page number 76. Its corresponding physical address is 76 * 512. The stack pointer must be set to point to this address so that IRET fetches the correct address. [76*512] = 0; SP = 2*512; 5)Use the ireturn instruction to transfer control to user program. ireturn translates to IRET machine instruction ireturn;","title":"OS Startup Code"},{"location":"roadmap/stage-06/#making-things-work","text":"1) Save the OS startup Code as $HOME/myexpos/spl/spl_progs/os_startup.spl . Compile this file using SPL compiler. cd $HOME/myexpos/spl ./spl $HOME/myexpos/spl/spl_progs/os_startup.spl 2) This will generate a file $HOME/myexpos/spl/spl_progs/os_startup.xsm . Load this file as the OS startup code to disk.xfs using the XFS Interface. Invoke the XFS interface and use the following command to load the OS Startup Code. # load --os $HOME/myexpos/spl/spl_progs/os_startup.xsm # exit 3) Run the machine in debug mode. (We will disable the timer for now). cd $HOME/myexpos/xsm/ ./xsm --debug --timer 0 4) View the contents of R1 at each step. Assignment 1 Change virtual memory model such that code occupies logical pages 4 and 5 and the stack lies in logical page 8. You will have to modify the user program as well as the os startup code.","title":"Making Things Work"},{"location":"roadmap/stage-07/","text":"Learning Objectives Familiarise with the Application Binary Interface(ABI) of eXpOS. Modify the INIT program to comply with the eXpOS ABI. Pre-requisite Reading Read and Understand the eXpOS Virtual Address Space Model and XEXE Executable File Format from eXpOS ABI Documentation before proceeding further. In this stage we will rewrite the user program and OS startup code of Stage 6 in compliance with expos ABI. Modifying INIT \u00b6 The INIT program must be modified to comply with the XEXE executable format. The executable format stipulates that the first 8 words of the file must contain a header. The rest of the file contains the program instructions. The OS is expected to load the file into logical pages starting from page 4. Thus the first disk block of the program is loaded into logical address starting from 2048, second (if the file size exceeds 512 words) to logical addresses starting from 2560 and so forth. Since the first instruction starts after the 8 word header, the first instruction in the program will be loaded into memory address 2056. Since each instruction requires two words, the second instruction will start at memory address 2058 and so on. Thus the jump addresses in the INIT program must be designed with this in mind. The INIT program complying to ABI is given below. The code is given in bold and the corresponding addresses are added for reference. 2048 0 2049 2056 2050 0 2051 0 2052 0 2053 0 2054 0 2055 0 2056 MOV R0, 1 2058 MOV R2, 5 2060 GE R2, R0 2062 JZ R2, 2074 2064 MOV R1, R0 2066 MUL R1, R0 2068 BRKP 2070 ADD R0, 1 2072 JMP 2058 2074 INT 10 Modifications to OS Startup Code \u00b6 1) Load Library Code from disk to memory loadi(63,13); loadi(64,14); The eXpOS ABI stipulates that the code for a shared library must be loaded to disk blocks 13 and 14 of the disk. During OS startup, the OS is supposed to load this code into memory pages 63 and 64. This library code must be attached to logical page 0 and logical page 1 of each process . Thus, this code will be shared by every application program running on the operating system and is called the common shared library or simply the library. The library provides a common code interface for all system calls. This means, to invoke a system call, the application can call the corresponding library function and the library will in turn invoke the system call and return values back to the application. The library also implements some functions like dynamic memory allocation and de-allocation from the heap area. The dynamic memory allocation functions of the library manage the heap memory of the application program. The ABI stipulates that each application must be provided 2 pages of memory for the heap. These two pages must be attached to logical pages 2 and 3 of the application. Note here that the library code is not part of the application's XEXE executable file. The library code is \"attached\" to the address space of the application when the application is loaded into memory for execution. Since the ABI stipulates the the library will be loaded to logical pages 0 and 1, the application \"knows\" the logical address of the library routines and will contain call to these routines, though the routines are not present in the application's code. Thus, the OS must do the following to ensure correct run time linkage of library code to each application. i. The library code must be pre-loaded to disk blocks 13 and 14 before OS startup.The library code can be found in the expl folder in eXpOs package.Load it into the XSM disk using the xfs-interface load --library ../expl/library.lib ii. During OS start-up, this code must be loaded to memory pages 63 and 64. iii. When each application is loaded for execution, the logical pages 0 and 1 must be mapped to physical pages 63 and 64. iv. Two physical pages must be allocated for the application's heap and attached to logical pages 2 and 3. 2) Modify the Page table entries according to ABI. The SPL constant PAGE_TABLE_BASE holds the value 29696. A total of 16 page tables can be stored starting from this address. Each page table will be 20 entries. For each user process, one page table will be allocated. Here since we are running the first user program, we will use the first few entries of this memory region for setting up the page table for the INIT process. As noted, the first disk block of the INIT program (block 7) must be loaded to logical page 4. Similarly, block 8 must be loaded to logical page 5. The ABI stipulates that two pages must be allocated for the stack at logical pages 8 and 9. The following code sets page table entries for logical page 4 and 5(for code area), logical page 8 and 9(for user stack), logical pages 2 and 3(for heap) and logical pages 0 and 1(for library). Since pages 0 to 75 are reserved for the use of the OS kernel, the first four free pages (76,77,78 and 79) will be allocated for stack and heap area. See Memory Organisation. Note that the code and library pages must be kept read only where as stack and heap must be read-write.(see page table settings for details). //Library [PTBR+0] = 63; [PTBR+1] = \"0100\"; [PTBR+2] = 64; [PTBR+3] = \"0100\"; //Heap [PTBR+4] = 78; [PTBR+5] = \"0110\"; [PTBR+6] = 79; [PTBR+7] = \"0110\"; //Code [PTBR+8] = 65; [PTBR+9] = \"0100\"; [PTBR+10] = 66; [PTBR+11] = \"0100\"; [PTBR+12] = -1; [PTBR+13] = \"0000\"; [PTBR+14] = -1; [PTBR+15] = \"0000\"; //Stack [PTBR+16] = 76; [PTBR+17] = \"0110\"; [PTBR+18] = 77; [PTBR+19] = \"0110\"; 3) Since the total address space of a process is 10 pages, PTLR register must be set to value 10. PTLR = 10; 4) The second entry of the header of an executable file will contain an entry point value. This is the address of the first instruction to be executed when the program is run. Hence, you must initialise IP to the second word in the header. Since the first code page is loaded into memory page 65, the address of the second word in header is calculated as (65 * 512) + 1. This value is stored to the top of the user stack. The machine on executing IRET instructions pops this value from the stack and sets IP to that value. SP = 8*512; [76*512] = [65 * 512 + 1]; Making Things Work \u00b6 Compile and load the modified OS startup Code. Load the modified user program. Run the machine in debug mode. Assignment 1 Change the user program to compute cubes of the first five numbers.","title":"Stage 7"},{"location":"roadmap/stage-07/#modifying-init","text":"The INIT program must be modified to comply with the XEXE executable format. The executable format stipulates that the first 8 words of the file must contain a header. The rest of the file contains the program instructions. The OS is expected to load the file into logical pages starting from page 4. Thus the first disk block of the program is loaded into logical address starting from 2048, second (if the file size exceeds 512 words) to logical addresses starting from 2560 and so forth. Since the first instruction starts after the 8 word header, the first instruction in the program will be loaded into memory address 2056. Since each instruction requires two words, the second instruction will start at memory address 2058 and so on. Thus the jump addresses in the INIT program must be designed with this in mind. The INIT program complying to ABI is given below. The code is given in bold and the corresponding addresses are added for reference. 2048 0 2049 2056 2050 0 2051 0 2052 0 2053 0 2054 0 2055 0 2056 MOV R0, 1 2058 MOV R2, 5 2060 GE R2, R0 2062 JZ R2, 2074 2064 MOV R1, R0 2066 MUL R1, R0 2068 BRKP 2070 ADD R0, 1 2072 JMP 2058 2074 INT 10","title":"Modifying INIT"},{"location":"roadmap/stage-07/#modifications-to-os-startup-code","text":"1) Load Library Code from disk to memory loadi(63,13); loadi(64,14); The eXpOS ABI stipulates that the code for a shared library must be loaded to disk blocks 13 and 14 of the disk. During OS startup, the OS is supposed to load this code into memory pages 63 and 64. This library code must be attached to logical page 0 and logical page 1 of each process . Thus, this code will be shared by every application program running on the operating system and is called the common shared library or simply the library. The library provides a common code interface for all system calls. This means, to invoke a system call, the application can call the corresponding library function and the library will in turn invoke the system call and return values back to the application. The library also implements some functions like dynamic memory allocation and de-allocation from the heap area. The dynamic memory allocation functions of the library manage the heap memory of the application program. The ABI stipulates that each application must be provided 2 pages of memory for the heap. These two pages must be attached to logical pages 2 and 3 of the application. Note here that the library code is not part of the application's XEXE executable file. The library code is \"attached\" to the address space of the application when the application is loaded into memory for execution. Since the ABI stipulates the the library will be loaded to logical pages 0 and 1, the application \"knows\" the logical address of the library routines and will contain call to these routines, though the routines are not present in the application's code. Thus, the OS must do the following to ensure correct run time linkage of library code to each application. i. The library code must be pre-loaded to disk blocks 13 and 14 before OS startup.The library code can be found in the expl folder in eXpOs package.Load it into the XSM disk using the xfs-interface load --library ../expl/library.lib ii. During OS start-up, this code must be loaded to memory pages 63 and 64. iii. When each application is loaded for execution, the logical pages 0 and 1 must be mapped to physical pages 63 and 64. iv. Two physical pages must be allocated for the application's heap and attached to logical pages 2 and 3. 2) Modify the Page table entries according to ABI. The SPL constant PAGE_TABLE_BASE holds the value 29696. A total of 16 page tables can be stored starting from this address. Each page table will be 20 entries. For each user process, one page table will be allocated. Here since we are running the first user program, we will use the first few entries of this memory region for setting up the page table for the INIT process. As noted, the first disk block of the INIT program (block 7) must be loaded to logical page 4. Similarly, block 8 must be loaded to logical page 5. The ABI stipulates that two pages must be allocated for the stack at logical pages 8 and 9. The following code sets page table entries for logical page 4 and 5(for code area), logical page 8 and 9(for user stack), logical pages 2 and 3(for heap) and logical pages 0 and 1(for library). Since pages 0 to 75 are reserved for the use of the OS kernel, the first four free pages (76,77,78 and 79) will be allocated for stack and heap area. See Memory Organisation. Note that the code and library pages must be kept read only where as stack and heap must be read-write.(see page table settings for details). //Library [PTBR+0] = 63; [PTBR+1] = \"0100\"; [PTBR+2] = 64; [PTBR+3] = \"0100\"; //Heap [PTBR+4] = 78; [PTBR+5] = \"0110\"; [PTBR+6] = 79; [PTBR+7] = \"0110\"; //Code [PTBR+8] = 65; [PTBR+9] = \"0100\"; [PTBR+10] = 66; [PTBR+11] = \"0100\"; [PTBR+12] = -1; [PTBR+13] = \"0000\"; [PTBR+14] = -1; [PTBR+15] = \"0000\"; //Stack [PTBR+16] = 76; [PTBR+17] = \"0110\"; [PTBR+18] = 77; [PTBR+19] = \"0110\"; 3) Since the total address space of a process is 10 pages, PTLR register must be set to value 10. PTLR = 10; 4) The second entry of the header of an executable file will contain an entry point value. This is the address of the first instruction to be executed when the program is run. Hence, you must initialise IP to the second word in the header. Since the first code page is loaded into memory page 65, the address of the second word in header is calculated as (65 * 512) + 1. This value is stored to the top of the user stack. The machine on executing IRET instructions pops this value from the stack and sets IP to that value. SP = 8*512; [76*512] = [65 * 512 + 1];","title":"Modifications to OS Startup Code"},{"location":"roadmap/stage-07/#making-things-work","text":"Compile and load the modified OS startup Code. Load the modified user program. Run the machine in debug mode. Assignment 1 Change the user program to compute cubes of the first five numbers.","title":"Making Things Work"},{"location":"roadmap/stage-08/","text":"Learning Objectives Run the XSM machine with Timer enabled. Familiarise with timer interrupt handling. Pre-requisite Reading Read and understand the XSM tutorial on Interrupts and Exception handling before proceeding further. (Read only the Timer Interrupt part). Try to solve the following question that tests your understanding. Question Suppose the XSM machine was executing in unprivileged mode and just after instruction at logical address 3000 was fetched and executed, the machine found that the timer interrupt was pending. Suppose that at this time, the values of the some of the machine registers were as the following : IP: 3000, PTBR: 29696, SP 5000 Which physical memory location will contain the physical page number to which return address will be stored by the machine before transferring control to the timer interrupt handler? 29714 (Why?) It is absolutely necessary that you read the XSM unprivileged mode execution tutorial if you are not able to solve this question yourself. Suppose further that the memory location 29714 contains value 35. What will be the physical memory address to which the XSM machine will copy the value of the next instruction to be executed? 18313 (Again if you are not able to solve the problem yourself, you must read the XSM unprivileged mode execution tutorial ) What will be the value stored into the location 18313 by the machine? 3002 This is the (logical) address of the next instruction to be executed after return from the interrupt handler. Note the each XSM instruction occupies two words in memory and hence the next instruction's address is at 3002 (and not 3001). What value will the SP and IP registers contain after the execution of the INT instruction? SP=5001 and IP=2048 What will be the physical address from which the machine will fetch the next instruction? 2048 Since the machine switches to privileged mode once the interrupt handler is entered, the next instruction will be fetched from the address pointed to by IP register without performing address translation. If the XSM simulator is run with the the timer set to some value - say 20, then every time the machine completes execution of 20 instructions in user mode, the timer device will send a hardware signal that interrupts machine execution. The machine will push the IP value of the next user mode instruction to the stack and pass control to the the timer interrupt handler at physical address 2048. eXpOS design given here requires you to load a timer interrupt routine into two pages of memory starting at memory address 2048 (pages 4 and 5). The routine must be written by you and loaded into disk blocks 17 and 18 so that the OS startup code can load this code into memory pages 4 and 5. In this stage, we will run the machine with timer on and write a simple timer interrupt handler. Modifications to OS Startup Code \u00b6 OS Startup code used in the previous stage has to be modified to load the timer interrupt routine from disk blocks 17 and 18 to memory pages 4 and 5. loadi(4, 17); loadi(5, 18); Timer Interrupt \u00b6 We will write the timer interupt routine such that it just prints \"TIMER\" and returns to the user program. print \"TIMER\"; ireturn; 1) Save this file in your UNIX machine as $HOME/myexpos/spl/spl_progs/sample_timer.spl 2) Compile this program using the SPL compiler. 3) Load the compiled XSM code as the timer interrupt into the XSM disk using XFS Interface. cd $HOME/myexpos/xfs-interface ./xfs-interface # load --int=timer $HOME/spl/spl_progs/sample_timer.xsm # exit 4) Recompile and reload the OS Startup code. 5) Run the XSM machine with timer enabled. cd $HOME/myexpos/xsm ./xsm --timer 2","title":"Stage 8"},{"location":"roadmap/stage-08/#modifications-to-os-startup-code","text":"OS Startup code used in the previous stage has to be modified to load the timer interrupt routine from disk blocks 17 and 18 to memory pages 4 and 5. loadi(4, 17); loadi(5, 18);","title":"Modifications to OS Startup Code"},{"location":"roadmap/stage-08/#timer-interrupt","text":"We will write the timer interupt routine such that it just prints \"TIMER\" and returns to the user program. print \"TIMER\"; ireturn; 1) Save this file in your UNIX machine as $HOME/myexpos/spl/spl_progs/sample_timer.spl 2) Compile this program using the SPL compiler. 3) Load the compiled XSM code as the timer interrupt into the XSM disk using XFS Interface. cd $HOME/myexpos/xfs-interface ./xfs-interface # load --int=timer $HOME/spl/spl_progs/sample_timer.xsm # exit 4) Recompile and reload the OS Startup code. 5) Run the XSM machine with timer enabled. cd $HOME/myexpos/xsm ./xsm --timer 2","title":"Timer Interrupt"},{"location":"roadmap/stage-09/","text":"Learning Objectives Get introduced to setting up process table entry for a user program. Familiarise with the management of kernel stack in hardware interrupt handlers. Pre-requisite Reading Read and understand the Kernel Stack Management during Interrupts before proceeding further. eXpOS requires that when the OS enters an interrupt handler that runs in kernel mode, the interrupt handler must switch to a different stack. This requirement is to prevent user level \u201chacks\u201d into the kernel through the stack. In the previous stage, though you entered the timer interrupt service routine in the kernel mode, you did not change the stack. In this stage, this will be done. To isolate the kernel from the user stack, the OS kernel must maintain two stacks for a program - a user stack and a kernel stack . In eXpOS, one page called the user area page is allocated for each process. A part of the space in this page will be used for the kernel stack (some other process information also will be stored in this page). Whenever there is a transfer of program control from the user mode to kernel during interrupts (or exceptions), the interrupt handler will change the stack to the kernel stack of the program (that is, the SP register must point to the top of the kernel stack of the program). Before the machine returns to user mode from the interrupt, the user stack must be restored (that is, the SP register must point to the top of the user stack of the program). Once we have two stacks for a user program, we need to design some data structure in memory to store the SP values of the two stacks. This is because the SP register of the machine can store only one value. eXpOS requires you to maintain a Process Table ,where data such as value of the kernel stack pointer, user stack pointer etc. pertaining to each process is stored. For now, we just have one user program in execution. Hence we will need just one process table entry to be created. Each process table entry contains several fields. But for now, we are only interested in storing only 1) user stack pointer and 2) the memory page allocated as user area for the program. The process table starts at page number 56 (address 28672). The process table has space for 16 entries, each having 16 words. Each entry holds information pertaining to one user process. Since we have only one process, we will use the first entry (the first 16 words starting at address 28672). Among these, we will be updating only entries for user stack pointer (word 13) and user area page number (word 11) in this stage. You will modify the previous stage code so that the user program is allocated a user area page. You will also create a process table entry for the program where you will make the necessary entries. Modifications to the OS Startup Code \u00b6 1) Set the User Area page number in the Process Table entry of the current process. Since the first available free page is 80, the User Area page is allocated at the physical page number 80. The SPL constant PROCESS_TABLE points to the starting address(28672) of the Process Table. [PROCESS_TABLE + 11] = 80; 2) As we are using the first Process Table entry, the PID will be 0. eXpOS kernel is expected to store the PID in the PID field of the process table. [PROCESS_TABLE + 1] = 0; 3) The kernel maintains a data structure called System Status Table where the PID of the currently executing user process is maintained. This makes it easy to keep track of the current PID whenever the machine enters any kernel mode routine. The System Status Table is stored starting from memory address 29560. The second field of this table must be set to the PID of the process which is going to be run in user mode. Set the current PID field in the System Status Table. The SPL constant SYSTEM_STATUS_TABLE points to the starting address of the System Status Table. [SYSTEM_STATUS_TABLE + 1] = 0; 4) The kernel stack pointer for the process need not be set now as all interrupt handlers assume that the kernel stack is empty when the handler is entered from user mode . Thus whenever an interrupt handler is entered from user mode, the kernelstack pointer will be initialized assuming that the stack is empty. (See Kernel Stack Management during hardware interrupts and exceptions ).The KPTR value will be used in later stages when kernel modules invoke each other. Timer Interrupt \u00b6 1) Save the current value of User SP into the corresponding Process Table entry. Obtain the process id of the currently executing process from System Status Table . This value can be used to get the Process Table entry of the currently executing process. Important Note Registers R0-R15 are user registers. Since you have not saved the register values into the stack yet, you should be careful not to write any code that alters these registers till the user context is saved into the stack. Registers R16-R19 are marked for kernel use and hence the kernel can modify them. The SPL compiler will use these registers to translate your SPL code. [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP; 2) Set the SP to beginning of the kernel stack.User Area Page number is the 11th word of the Process Table. The initial value of SP must be set to this address*512 - 1 . // Setting SP to UArea Page number * 512 - 1 SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1; 3) Save the user context to the kernel stack using the Backup instruction. backup; 4) Print \"timer\". print \"TIMER\"; 5)Restore the user context from the kernel stack and set SP to the user SP saved in Process Table, before returning to user mode. restore; SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13]; 6) Use ireturn statement to switch to user mode. ireturn; Assignment 1 Print the process id of currently executing process in timer interrupt before returning to user mode. You can look up this value from the System Status Table.","title":"Stage 9"},{"location":"roadmap/stage-09/#modifications-to-the-os-startup-code","text":"1) Set the User Area page number in the Process Table entry of the current process. Since the first available free page is 80, the User Area page is allocated at the physical page number 80. The SPL constant PROCESS_TABLE points to the starting address(28672) of the Process Table. [PROCESS_TABLE + 11] = 80; 2) As we are using the first Process Table entry, the PID will be 0. eXpOS kernel is expected to store the PID in the PID field of the process table. [PROCESS_TABLE + 1] = 0; 3) The kernel maintains a data structure called System Status Table where the PID of the currently executing user process is maintained. This makes it easy to keep track of the current PID whenever the machine enters any kernel mode routine. The System Status Table is stored starting from memory address 29560. The second field of this table must be set to the PID of the process which is going to be run in user mode. Set the current PID field in the System Status Table. The SPL constant SYSTEM_STATUS_TABLE points to the starting address of the System Status Table. [SYSTEM_STATUS_TABLE + 1] = 0; 4) The kernel stack pointer for the process need not be set now as all interrupt handlers assume that the kernel stack is empty when the handler is entered from user mode . Thus whenever an interrupt handler is entered from user mode, the kernelstack pointer will be initialized assuming that the stack is empty. (See Kernel Stack Management during hardware interrupts and exceptions ).The KPTR value will be used in later stages when kernel modules invoke each other.","title":"Modifications to the OS Startup Code"},{"location":"roadmap/stage-09/#timer-interrupt","text":"1) Save the current value of User SP into the corresponding Process Table entry. Obtain the process id of the currently executing process from System Status Table . This value can be used to get the Process Table entry of the currently executing process. Important Note Registers R0-R15 are user registers. Since you have not saved the register values into the stack yet, you should be careful not to write any code that alters these registers till the user context is saved into the stack. Registers R16-R19 are marked for kernel use and hence the kernel can modify them. The SPL compiler will use these registers to translate your SPL code. [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP; 2) Set the SP to beginning of the kernel stack.User Area Page number is the 11th word of the Process Table. The initial value of SP must be set to this address*512 - 1 . // Setting SP to UArea Page number * 512 - 1 SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1; 3) Save the user context to the kernel stack using the Backup instruction. backup; 4) Print \"timer\". print \"TIMER\"; 5)Restore the user context from the kernel stack and set SP to the user SP saved in Process Table, before returning to user mode. restore; SP = [PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13]; 6) Use ireturn statement to switch to user mode. ireturn; Assignment 1 Print the process id of currently executing process in timer interrupt before returning to user mode. You can look up this value from the System Status Table.","title":"Timer Interrupt"},{"location":"roadmap/stage-10/","text":"Learning Objectives Familiarise with the low level system call interface in eXpOS. Familiarise with the console output mechanism in eXpOS. Pre-requisite Reading Read and understand the Kernel Stack Management during system calls before proceeding further. In Stage 7, we wrote a user program and used the BRKP instruction to view the result in debug mode. In this stage, we will modify the program such that the result is printed directly to the terminal. The terminal print is acheived by issuing a write system call from the user program. The write system call is serviced by interrupt routine 7. Modifications to the user program \u00b6 A system call is an OS routine that can be invoked from a user program. The OS provides system call routines for various services like writing to a file/console, forking a process etc. Each system call routine is written inside some software interrupt handler. For example, the write system call of eXpOS is coded inside the INT 7 handler.An interrupt handler may contain code for several system calls. (For example, in the eXpOS implementation on XSM, the routines for create and delete system calls are coded inside the INT 4 handler - find details here ). To identify the correct routine, the OS assigns a unique systemcall number to each system call routine. To invoke a system call from a program, the program must pass the system call number (along with other arguments to the system call) and invoke the corresponding software interrupt using the INT instruction. The arguments and the system call number are passed through the user program's stack. When a program invokes a system call, the system switches from user mode to kernel mode. Hence, system calls run in kernel mode and thus have access to all the hardware resources. Upon completing the call, the system call places return value of the call into designated position in the user program's stack and returns to the calling program using the IRET. Since the IRET instruction switches mode back to user mode, the user program resumes execution after the call in user mode. The user program extracts the return values of the call from the user stack. In this stage, we will write a small kernel routine for handling console write. This is part of the functionality of the write system call (system call number 5) programmed inside the INT 7 handler. You will implement the full functionality of the write system call in later stages. The user program of Stage 7 is modified such that a write system call is issued to print the contents of register R1 to the terminal. You will no longer need to run the program in debug mode. This is because once we implement the system call service for console output, this system call can be used by the user program to print the output to the console. A user program must execute the following steps to invoke the system call: 1) Save the registers in use to the user stack (in the program below R0, R1, R2 are saved). As per the specification, since the user program calls system call routine , the OS expects that it saves its own context (registers in use) before issuing the system call. 2) Push the system call number and arguments to the stack. For the Write system call, the system call number is 5. Argument 1 is the file descriptor which is -2 for the terminal. Argument 2 is the word which has to be written to the terminal. Here the word we are going to write is present in R1. By convention, all system calls have 3 arguments. As we do not have a third argument in this case, push any register, say R0 on to the stack. (In this case the last argument will be ignored by the system call handler.) Refer to the low level system call interface for write here . 3) Push any register, say R0 to allocate space for the return value. 4) Invoke the interrupt by \"INT 7\" instruction. //The following code will be executed after return from the system call. Normally, the return value of a system call gives information regarding whether the system call succeeded or whether there was an error etc. In some cases, the system call returns a value which is to be used later in program (for instance, the open system call returns a file descriptor). In the present case, since console write never fails, we ignore the return value. 5) Pop out the return value, the system call number and arguments which were pushed on the stack prior to the system call. 6) Restore the register context from the stack (in the following program R0,R1,R2 are restored). The resulting program is given below. 0 2056 0 0 0 0 0 0 MOV R0, 1 MOV R2, 5 GE R2, R0 JZ R2, 2110 MOV R1, R0 MUL R1, R0 // saving register context PUSH R0 PUSH R1 PUSH R2 // pushing system call number and arguments MOV R0, 5 MOV R2, -2 PUSH R0 PUSH R2 PUSH R1 PUSH R0 // pushing space for return value PUSH R0 INT 7 // poping out return value and ignore POP R1 // pop out argumnets and system call number and ignore POP R1 POP R1 POP R1 POP R1 // restoring the register context POP R2 POP R1 POP R0 ADD R0, 1 JMP 2058 INT 10 Contents of the stack before and after the INT instruction Now, you will write the system call handler for processing the write request. INT 7 \u00b6 The write operation is handled by Interrupt 7. The word to be printed is passed from the user program through its user stack as the second argument to the interrupt routine. The interrupt routine retrieves this word from the stack and writes the word to the terminal using the OUT instruction. Detailed instructions for doing so are given below 1) Set the MODE FLAG field in the process table to the system call number which is 5 for write system call. To get the process table of current process, use the PID obtained from the system status table . MODE FLAG field in the process table is used to indicate whether the current process is executing in a system call, exception handler or usermode. [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 5; 2) Store the value of user SP in a register as we need it for further computations. alias userSP R0; userSP = SP; 3) Switch the stack from user stack to kernel stack. Save the value of SP in the user SP field of Process Table entry of the process. Set the value of SP to beginning of the kernel stack. Details can be found at Kernel Stack Management during system calls . 4) First we have to access argument 1 which is file descriptor to check whether it is valid or not. In user mode, logical addresses are translated to physical address by the machine using its address translation scheme . Since interrupts are executed in the kernel mode, the actual physical address is used to access memory locations. Hence to access the file descriptor (argument 1) we must calculate the physical address of the memory location where it is stored. According to system call conventions, userSP - 4 is the location of the argument 1. So we will manually address translate userSP -4 (See contents of the stack after INT instruction in above image for reference). alias physicalPageNum R1; alias offset R2; alias fileDescPhysicalAddr R3; physicalPageNum = [PTBR + 2 * ((userSP - 4)/ 512)]; offset = (userSP - 4) % 512; fileDescPhysicalAddr = (physicalPageNum * 512) + offset; alias fileDescriptor R4; fileDescriptor=[fileDescPhysicalAddr]; 5) Check whether the file descriptor obtained in above step is valid or not. In this stage it should be -2 because file descriptor for console is -2. (see details here .) Write an IF condition to check whether file descriptor is -2 or not. if (fileDescriptor != -2) then //code when argument 1 is not valid else //code when argument 1 is valid endif; 6) If the file descriptor is not equal to -2, store -1 as a return value. According to system call convention, return value is stored at memory location userSP -1 in the user stack. Calculate physical address of the return value corresponding to userSP - 1 using address translation mechanism. if (fileDescriptor != -2) then alias physicalAddrRetVal R5; physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512); [physicalAddrRetVal] = -1; else //code when argument 1 is valid endif; 7) The following three steps has to be included in the else block. Calculate physical address of the argument 2 and extract the value from it , which is the word to be printed to the console. alias word R5; word = [[PTBR + 2 * ((userSP - 3) / 512)] * 512 + ((userSP - 3) % 512)]; 8) Write the word to the terminal using the print instruction. print word; 9) Set the return value as 0 indicating success. According to system call convention, return value is stored at memory location userSP -1 in the user stack. alias physicalAddrRetVal R6; physicalAddrRetVal = ([PTBR + 2 * (userSP - 1)/ 512] * 512) + ((userSP - 1) % 512); [physicalAddrRetVal] = 0; 10) Outside the else block, set back the value of SP to point to top of user stack. SP = userSP; 11) Reset the MODE FLAG field in the process table to 0. Value 0 indicates that process is running in user mode. [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0; 12) Pass control back to the user program using the ireturn statement. Modifications to the OS startup code \u00b6 Add code in the OS startup code to load INT7 from disk to memory. loadi(16,29); loadi(17,30); Making Things Work \u00b6 Implementation Tip From this stage onwards, you have to load multiple files using XFS-interface. To make things easier, create a batch file containing XFS-interface commands to load the required files and run this batch file using run command. See the usage of run command in XFS-interface documentation Save this file in your UNIX machine as $HOME/myexpos/spl/spl_progs/sample_int7.spl Compile this program using the SPL compiler. Load the compiled XSM code as INT 7 into the XSM disk using XFS Interface. Run the Machine with timer disabled. Note Starting from the next stage, you will be writing user programs using a high level language called ExpL. ExpL allows you to write programs that invoke system calls using the exposcall() function . The ExpL compiler will automatically generate code to translate your high level function call to a call to the eXpOS library and the library contains code to translate the call to an INT invocation as done by you in this stage. The next stage will introduce you to ExpL. Why should we calculate the physical address of userSP-3 and userSP-1 seperately instead of calculating one and adding/subtracting the difference from the calculated value? Suppose the physical address corresponding to logical address in userSP be - say 5000. it may not be the case that 4997 is the physical address corresponding to the logical address userSP-3 . Similarly the physical address corresponding to userSP-1 need not be 4999. The problem is that the stack of a process spreads over two pages and these two physical pages need not be contiguous. Hence, logical addresses which are close together may be far separated in physical memory. Assignment Write a program to print the first 20 numbers and run the system with timer enabled.","title":"Stage 10"},{"location":"roadmap/stage-10/#modifications-to-the-user-program","text":"A system call is an OS routine that can be invoked from a user program. The OS provides system call routines for various services like writing to a file/console, forking a process etc. Each system call routine is written inside some software interrupt handler. For example, the write system call of eXpOS is coded inside the INT 7 handler.An interrupt handler may contain code for several system calls. (For example, in the eXpOS implementation on XSM, the routines for create and delete system calls are coded inside the INT 4 handler - find details here ). To identify the correct routine, the OS assigns a unique systemcall number to each system call routine. To invoke a system call from a program, the program must pass the system call number (along with other arguments to the system call) and invoke the corresponding software interrupt using the INT instruction. The arguments and the system call number are passed through the user program's stack. When a program invokes a system call, the system switches from user mode to kernel mode. Hence, system calls run in kernel mode and thus have access to all the hardware resources. Upon completing the call, the system call places return value of the call into designated position in the user program's stack and returns to the calling program using the IRET. Since the IRET instruction switches mode back to user mode, the user program resumes execution after the call in user mode. The user program extracts the return values of the call from the user stack. In this stage, we will write a small kernel routine for handling console write. This is part of the functionality of the write system call (system call number 5) programmed inside the INT 7 handler. You will implement the full functionality of the write system call in later stages. The user program of Stage 7 is modified such that a write system call is issued to print the contents of register R1 to the terminal. You will no longer need to run the program in debug mode. This is because once we implement the system call service for console output, this system call can be used by the user program to print the output to the console. A user program must execute the following steps to invoke the system call: 1) Save the registers in use to the user stack (in the program below R0, R1, R2 are saved). As per the specification, since the user program calls system call routine , the OS expects that it saves its own context (registers in use) before issuing the system call. 2) Push the system call number and arguments to the stack. For the Write system call, the system call number is 5. Argument 1 is the file descriptor which is -2 for the terminal. Argument 2 is the word which has to be written to the terminal. Here the word we are going to write is present in R1. By convention, all system calls have 3 arguments. As we do not have a third argument in this case, push any register, say R0 on to the stack. (In this case the last argument will be ignored by the system call handler.) Refer to the low level system call interface for write here . 3) Push any register, say R0 to allocate space for the return value. 4) Invoke the interrupt by \"INT 7\" instruction. //The following code will be executed after return from the system call. Normally, the return value of a system call gives information regarding whether the system call succeeded or whether there was an error etc. In some cases, the system call returns a value which is to be used later in program (for instance, the open system call returns a file descriptor). In the present case, since console write never fails, we ignore the return value. 5) Pop out the return value, the system call number and arguments which were pushed on the stack prior to the system call. 6) Restore the register context from the stack (in the following program R0,R1,R2 are restored). The resulting program is given below. 0 2056 0 0 0 0 0 0 MOV R0, 1 MOV R2, 5 GE R2, R0 JZ R2, 2110 MOV R1, R0 MUL R1, R0 // saving register context PUSH R0 PUSH R1 PUSH R2 // pushing system call number and arguments MOV R0, 5 MOV R2, -2 PUSH R0 PUSH R2 PUSH R1 PUSH R0 // pushing space for return value PUSH R0 INT 7 // poping out return value and ignore POP R1 // pop out argumnets and system call number and ignore POP R1 POP R1 POP R1 POP R1 // restoring the register context POP R2 POP R1 POP R0 ADD R0, 1 JMP 2058 INT 10 Contents of the stack before and after the INT instruction Now, you will write the system call handler for processing the write request.","title":"Modifications to the user program"},{"location":"roadmap/stage-10/#int-7","text":"The write operation is handled by Interrupt 7. The word to be printed is passed from the user program through its user stack as the second argument to the interrupt routine. The interrupt routine retrieves this word from the stack and writes the word to the terminal using the OUT instruction. Detailed instructions for doing so are given below 1) Set the MODE FLAG field in the process table to the system call number which is 5 for write system call. To get the process table of current process, use the PID obtained from the system status table . MODE FLAG field in the process table is used to indicate whether the current process is executing in a system call, exception handler or usermode. [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 5; 2) Store the value of user SP in a register as we need it for further computations. alias userSP R0; userSP = SP; 3) Switch the stack from user stack to kernel stack. Save the value of SP in the user SP field of Process Table entry of the process. Set the value of SP to beginning of the kernel stack. Details can be found at Kernel Stack Management during system calls . 4) First we have to access argument 1 which is file descriptor to check whether it is valid or not. In user mode, logical addresses are translated to physical address by the machine using its address translation scheme . Since interrupts are executed in the kernel mode, the actual physical address is used to access memory locations. Hence to access the file descriptor (argument 1) we must calculate the physical address of the memory location where it is stored. According to system call conventions, userSP - 4 is the location of the argument 1. So we will manually address translate userSP -4 (See contents of the stack after INT instruction in above image for reference). alias physicalPageNum R1; alias offset R2; alias fileDescPhysicalAddr R3; physicalPageNum = [PTBR + 2 * ((userSP - 4)/ 512)]; offset = (userSP - 4) % 512; fileDescPhysicalAddr = (physicalPageNum * 512) + offset; alias fileDescriptor R4; fileDescriptor=[fileDescPhysicalAddr]; 5) Check whether the file descriptor obtained in above step is valid or not. In this stage it should be -2 because file descriptor for console is -2. (see details here .) Write an IF condition to check whether file descriptor is -2 or not. if (fileDescriptor != -2) then //code when argument 1 is not valid else //code when argument 1 is valid endif; 6) If the file descriptor is not equal to -2, store -1 as a return value. According to system call convention, return value is stored at memory location userSP -1 in the user stack. Calculate physical address of the return value corresponding to userSP - 1 using address translation mechanism. if (fileDescriptor != -2) then alias physicalAddrRetVal R5; physicalAddrRetVal = ([PTBR + 2 * ((userSP - 1) / 512)] * 512) + ((userSP - 1) % 512); [physicalAddrRetVal] = -1; else //code when argument 1 is valid endif; 7) The following three steps has to be included in the else block. Calculate physical address of the argument 2 and extract the value from it , which is the word to be printed to the console. alias word R5; word = [[PTBR + 2 * ((userSP - 3) / 512)] * 512 + ((userSP - 3) % 512)]; 8) Write the word to the terminal using the print instruction. print word; 9) Set the return value as 0 indicating success. According to system call convention, return value is stored at memory location userSP -1 in the user stack. alias physicalAddrRetVal R6; physicalAddrRetVal = ([PTBR + 2 * (userSP - 1)/ 512] * 512) + ((userSP - 1) % 512); [physicalAddrRetVal] = 0; 10) Outside the else block, set back the value of SP to point to top of user stack. SP = userSP; 11) Reset the MODE FLAG field in the process table to 0. Value 0 indicates that process is running in user mode. [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0; 12) Pass control back to the user program using the ireturn statement.","title":"INT 7"},{"location":"roadmap/stage-10/#modifications-to-the-os-startup-code","text":"Add code in the OS startup code to load INT7 from disk to memory. loadi(16,29); loadi(17,30);","title":"Modifications to the OS startup code"},{"location":"roadmap/stage-10/#making-things-work","text":"Implementation Tip From this stage onwards, you have to load multiple files using XFS-interface. To make things easier, create a batch file containing XFS-interface commands to load the required files and run this batch file using run command. See the usage of run command in XFS-interface documentation Save this file in your UNIX machine as $HOME/myexpos/spl/spl_progs/sample_int7.spl Compile this program using the SPL compiler. Load the compiled XSM code as INT 7 into the XSM disk using XFS Interface. Run the Machine with timer disabled. Note Starting from the next stage, you will be writing user programs using a high level language called ExpL. ExpL allows you to write programs that invoke system calls using the exposcall() function . The ExpL compiler will automatically generate code to translate your high level function call to a call to the eXpOS library and the library contains code to translate the call to an INT invocation as done by you in this stage. The next stage will introduce you to ExpL. Why should we calculate the physical address of userSP-3 and userSP-1 seperately instead of calculating one and adding/subtracting the difference from the calculated value? Suppose the physical address corresponding to logical address in userSP be - say 5000. it may not be the case that 4997 is the physical address corresponding to the logical address userSP-3 . Similarly the physical address corresponding to userSP-1 need not be 4999. The problem is that the stack of a process spreads over two pages and these two physical pages need not be contiguous. Hence, logical addresses which are close together may be far separated in physical memory. Assignment Write a program to print the first 20 numbers and run the system with timer enabled.","title":"Making Things Work"},{"location":"roadmap/stage-11/","text":"Learning Objectives Familiarise with the use of ExpL for writing application programs Familiarise with the ExpL high level library interface Pre-requisite Reading Read and understand the ExpL Specification ExpL high level library interface before proceeding further. Read only the specification just enough to write simple programs in the language. Don't get lost in the links ExpL is a high level language in which you can write high level application programs. A compiler for ExpL supplied to you along with the eXpOS package will generate target code compatible with the eXpOS specification. ExpL permits application programs to call the function exposcall() that implements the high level library interface to the OS. Application programs must use this library interface to invoke eXpOS system calls. Certain built-in functions of the ExpL language (Alloc, Free and Initialize - these functions handle ExpL dynamic memory management) are also implemented as ExpL library routines. Note that the only way to invoke an eXpOS system call from a high level ExpL program is to use the exposcall() function. The ExpL library file library.lib supplied to you along with the eXpOS package contains assembly language implementation of the library and occupies two pages of memory. The OS design stipulates that this library code must be pre-loaded to the XSM disk blocks 13 and 14 before OS bootstrap using XFS interface (see disk layout ). Your OS start up code is supposed to load this code into memory pages 63 and 64 from disk blocks 13 and 14. An ExpL program written by a programmer will contain library calls using the exposcall() function. The ExpL compiler will translate these calls to assembly instructions calling the library as specified here (see low level runtime library interface ). The compiler expects that the library will be loaded to the logical address 0 of the address space of the program. The target code generated by the compiler will not contain the code for the library. Instead, the OS is expected to link this code (at physical pages 63 and 64) into logical pages 0 and 1 when the program is loaded for execution. Hence, when the OS loads a program for execution, the library code must be linked to the logical pages 0 and 1 by setting the page table entries for the first two logical pages to 63 and 64. An ExpL program will contain calls to the library and hence the library linkage must be done correctly for ExpL program to run properly. In the previous stages, you wrote and executed application programs in assembly language. Now, you will write application programs in ExpL and compile it to generate the assembly program. This compiled code is loaded into the XSM disk as done in previous stages. 1) Below is the ExpL program to print numbers upto 50. Save this program as numbers.expl in $HOME/myexpos/eXpl/samples. This will be the init program in this stage. int main() { decl int temp,num; enddecl begin num=1; while ( num <= 50 ) do temp = exposcall ( \"Write\" , -2, num ); num = num + 1; endwhile; return 0; end } Refer here for more examples of ExpL programs. 2) Compile this program using the command cd $HOME/myexpos/eXpl ./expl samples/numbers.expl The ExpL compiler will write the target executable code into the file assemblycode.xsm. (You will have to save the file to a different name before compiling the next ExpL program). Note The present version of ExpL compiles <filename>.expl into <filename>.xsm . A copy of this target file is also wriiten into the file assemblycode.xsm for backward compatibility. 3) Load the compiled code as the init program into the XSM disk using XFS Interface. 4) Run the XSM machine. Q1. If your ExpL program contains read() function call, will it work now? Obviously not. The ExpL compiler will generate a call to the library requesting a console read; the library code in turn will generate an INT 6 for console input. Since you haven't written any code for INT 6, the OS will crash in INT 6. It will be an insightful exercise to trace the sequence of calls in debug mode. Assignment 1 Write an ExpL program to print all odd numbers from 1-100 and run the machine with this program loaded as the init. Assignment 2 Write an ExpL program to include a user defined type Student as follows Student { str name; int marks; } Declare a variable of type Student, assign values \"John\", 89 for name and marks respectively and print the values to the terminal. Run the machine with this as an init program. Don't forget to initialize the heap and allocate the memory for a variable before assigning values to its attributes. Assignment 3: Writing your own library Instead of using the library implementation library.lib , write your own library (in assembly language) to support only the write system call to console. Your library code must extract arguments from the stack, check whether the request is for a console write, if so call INT 7 after supplying proper arguments in the stack as done in the previous stage. Upon return from the system call, your library routine must set the return value through the stack (setting return value in the proper location of the stack -see details here ) and return control back to the application.","title":"Stage 11"},{"location":"roadmap/stage-12/","text":"Learning Objectives Familiarise with the idle process. Program the timer interrupt handler to concurrently schedule two processes. This stage introduces you to multi-programming. You will load two processes into memory during OS bootstrap and put them on concurrent execution. For this, you need to modify the timer interrupt handler to switch between the two processes. We will use the the same init process as in stage 11. A second process called an idle process will also be set up in memory for execution during OS startup.The idle process simply contains an infinite loop. You will modify the timer to implement a very primitive scheduler which shares the machine between the two processes. More detailed implementation of the OS scheduler will be taken up in later stages. Idle Program \u00b6 Idle is a user program which is loaded for execution during OS bootstrap. Before OS bootstrap, it must be stored in the disk blocks 11 and 12. The OS bootstrap loader must load this program to memory pages 69 and 70 (See eXpOS Disk and Memory layout for details). The Page Table and Process Table for the idle process must be set up by the bootstrap loader. The PID of the idle process is fixed to be 0. Idle program runs an infinite loop. The algorithm for the idle is as follows. while(1) do endwhile An ExpL program for idle process is given below. int main() { decl int a; enddecl begin while(1==1) do a=1; endwhile; return 0; end } Compile the above code and load it into disk blocks 11 and 12 before system startup, using the command. load --idle <...path to idle...> Modifications to OS Startup Code \u00b6 The eXpOS assigns each process a unique process ID (PID). The eXpOS design stipulates that the PID of idle process is 0. INIT program is assigned PID 1. Our implementation plan in this road map is to store the process table entry for the process with ID=0 in the 16 words starting at memory address PROCESS_TABLE, the process table entry for process with PID=1 in 16 words starting at memory address PROCESS_TABLE+16 and so on. Similarly, the page table for the process with PID=0 will be stored in 20 words starting at address PAGE_TABLE_BASE, page table for PID=1 will start at PAGE_TABLE_BASE+20 and so on. The memory layout design permits space for process/page table entries for a maximum of 16 processes.Thus, the OS can run at most 16 processes concurrently. At present, we will run just two processes - the idle process with PID=0 and the init process with PID=1.Since there are two processes, we need to set up several data structures so that the operating system is able to keep track of the state of each process while in execution. The steps are described below. 1) Load the idle code from disk to memory. loadi(69,11); loadi(70,12); 2) Set the page table entries for idle process. As idle process does not use library functions or dynamic memory allocation, it doesn't need library and heap pages. Therefore, you need to set up entries for only the code and stack pages. As memory requirements of idle are very low,we need to allocate only one physical page for stack. We will allocate page 81 for stack as pages 76-80 will be used by the init process. PTBR=PAGE_TABLE_BASE; //as PID of idle process is 0 //Library [PTBR+0] = -1; [PTBR+1] = \"0000\"; [PTBR+2] = -1; [PTBR+3] = \"0000\"; //Heap [PTBR+4] = -1; [PTBR+5] = \"0000\"; [PTBR+6] = -1; [PTBR+7] = \"0000\"; //Code [PTBR+8] = 69; [PTBR+9] = \"0100\"; [PTBR+10] = 70; [PTBR+11] = \"0100\"; [PTBR+12] = -1; [PTBR+13] = \"0000\"; [PTBR+14] = -1; [PTBR+15] = \"0000\"; //Stack [PTBR+16] = 81; [PTBR+17] = \"0110\"; [PTBR+18] = -1; [PTBR+19] = \"0000\"; 3) We will run the INIT process of stage 11 (to print all numbers below 50) concurrently. Set the Page Table entries for init as done in previous stages with PTBR as PAGE_TABLE_BASE+20. 4) As noted earlier, Process Table entries for idle starts from address PROCESS_TABLE and init from PROCESS_TABLE + 16. Set the PID field in the Process Table entry to 0 for idle and 1 for init. 5) The process being currently scheduled is said to be in RUNNING state.The bootstrap loader will schedule the init process first.Thus, in the OS startup code, set the STATE field in process table entry of the idle process to CREATED and INIT process to RUNNING . The CREATED state indicates that the process had never been scheduled for execution previously. The need for a separate CREATED state will be explained later. Subsequent \"re-scheduling\" will be done by the timer interrupt handler. According to process table, STATE field occupies 2 words. In case of RUNNING and CREATED states, second word is not required. See process states . 6) We will allocate the next free page, 82 as the User Area Page for the idle process. Set the User Area Page number field in the Process Table entry of idle to 82. 7) Set the UPTR field in the Process Table entry for idle to 8*512 which is the logical address of user SP. (The reasoning behind this step was explained in detail in Stage 7). 8) Set the KPTR field of the process table for idle to 0. The User Area Page Number field of a process table entry stores the page number of the user area page allocated to the process. The KPTR field must store the offset of the kernel stack pointer within this page. The UPTR points to the top of the current value of user stack pointer. Some explanation is of the order here. When a process is executing in user mode, the active stack will be the user stack (logical pages 8-9 of the process). When the process switches to kernel mode, the first action by the kernel code will be to save the SP value to UPTR and set the SP register to the physical address of the top of the kernel stack. When a process enters the kernel mode from user mode, the kernel stack will always be empty. Hence, SP must be set to value (User Area Page Number * 512 - 1) whenever kernel mode is entered from the user mode. Similarly, before a process executes IRET instruction and switch from kernel mode to user mode, the SP register must be set to previously stored value in UPTR field of the process table. The kernel stack will be empty when a process returns to user mode as there is no kernel context to be remembered. 9) Set the PTBR field to PAGE_TABLE_BASE and PTLR field to 10 in the Process Table entry of idle process. 10) Set the entry point IP value from the header of idle process to top of the user stack of the idle process as done in the previous stage. [81 * 512] = [69*512 + 1]; The values of PTBR, PTLR, User Area Page Number, UPTR, KPTR etc. stored in the process table entry for a process will be used to set up the values of the hardware registers just before the process is scheduled for execution. We will not be scheduling the idle process immediately. Hence, the hardware registers will not be set based on the above values now. Instead, we will schedule the INIT process from the OS startup code. Hence your OS startup code must contain code to set up registers to schedule the INIT process, as outlined below: 11) Set User Area Page number, UPTR, KPTR, PTBR and PTLR fields in the Process Table entry for init. 12) Initialise the machine's PTBR and PTLR registers for scheduling the INIT process. (You have alreay gone through the steps in Stage 7). 13) Set the Entry point address for INIT process in the beginning of Stack page of INIT. Also set the SP register accordingly. 14) Set the current PID field in system status table to 1, as PID for INIT is 1. 15) Transfer control to INIT using ireturn instruction. Note You must be clear with XSM unprivileged mode execution to understand the description that follows. Modifications to timer interrupt handler \u00b6 In the previous stage you made the timer interrupt display \"TIMER\" at fixed intervals. However, the actual function of timer interrupt routine is to preempt the current running process and to transfer execution to another ready processes. In this stage, you will write a sample scheduler which will schedule just two processes. The scheduler will be implemented in the timer interrupt handler. After saving the context of the currently executing process in its kernel stack, the scheduler must switch to the kernel stack to that of the next process to be scheduled. The context of the next process has to be loaded to the registers and then control of execution can be transferred to the process. Detailed intructions for scheduling are given below. 1) Switch from the user stack to kernel stack of the currently executing process and save the register context using the backup instruction as done in stage 9. 2) Obtain the PID of currently executing process from System Status Table . alias currentPID R0; currentPID = [SYSTEM_STATUS_TABLE+1]; 3) The Process table entry of the current process can be computed as PROCESS_TABLE + currentPID*16. Save the KPTR, PTBR and PTLR values to the Process Table entry of the current process. Set the state of the process as READY. alias process_table_entry R1; process_table_entry = PROCESS_TABLE + currentPID * 16; [process_table_entry + 12] = SP % 512; [process_table_entry + 14] = PTBR; [process_table_entry + 15] = PTLR; [process_table_entry + 4] = READY; Note that instead of saving the actual value of KPTR, we are saving KPTR%512. This is because the OS design stipulates that KPTR must contain the offset of the kernel stack pointer within the User Area Page. This is done so as to allow the OS to relocate the User Area Page if necessary. 4) As we have only two processes to schedule, the scheduling algorithm we are going to use will just toggle between the two processes. alias newPID R2; if(currentPID == 0) then newPID = 1; else newPID = 0; endif; 5) Restore the SP, PTBR and PTLR values from the Process Table entry for the new process. alias new_process_table R3; new_process_table = PROCESS_TABLE + newPID * 16; //Set back Kernel SP, PTBR , PTLR SP = [new_process_table + 11] * 512 + [new_process_table + 12] ; PTBR = [new_process_table + 14]; PTLR = [new_process_table + 15]; 6) Set the PID field of the System Status Table as newPID. [SYSTEM_STATUS_TABLE + 1] = newPID; 7) Our scheduler must distinguish between two cases when a process is scheduled for execution. If a process is in CREATED state, the process had never been scheduled for execution earlier. Such a process will have no \"history\" to remember, and thus no \"user context\" to be restored before being scheduled. On the other hand, a process in READY state is one which had been in RUNNING state in the past. Such a process will have an associated (saved user context) which the scheduler would have saved in the kernel stack when it was scheduled out earlier. This context has to be restored before the process is scheduled again for correct resumption of execution. Check if the newly found process is in CREATED state. If so, set SP to top of its user stack and return to user mode. if([new_process_table + 4] == CREATED) then [new_process_table + 4] = RUNNING; SP = [new_process_table + 13]; ireturn; endif; Note In this stage, the only situation where the timer finds the next process in CREATED state is when the IDLE process is to be scheduled for the first time. Since INIT is scheduled directly from the OS startup code, the INIT process never goes through the CREATED state. 8) Set the state of the newly found process as RUNNING. [new_process_table + 4] = RUNNING; 9) Restore the register context of the new process from its kernel stack and change the stack to user stack as done in previous stages. Note that if this is the case, then the process would have been in RUNNING state before. Making Things Work \u00b6 1) Compile and load the modified OS statup code and Timer Interrupt handler to XSM disk. 2) Compile and load the idle program into the XSM disk 3) Run the machine with timer enabled. What is the significance of the idle process? The main purpose of the idle process is to run as a background process in an infinite loop. The idle process does nothing except running an infinite loop. This is demanded by the OS so that the scheduler will always have atleast one \"READY\" process to schedule. It is to be scheduled only when no other process is available for scheduling. However, in this stage we have scheduled idle just like any other process. Assignment 1 Load a program to print numbers from 1-100 as the INIT program, and modify IDLE to print numbers from 101-200. (You will have to link the library to address space of IDLE for the Write function call to work.) Assignment 2 Set two breakpoints (see SPL breakpoint instruction ) in the timer interrupt routine, the first one immediately upon entering the timer routine and the second one just before return from the timer routine. Dump the process table entry and page table entries of current process (see XSM debugger for various printing options).","title":"Stage 12"},{"location":"roadmap/stage-12/#idle-program","text":"Idle is a user program which is loaded for execution during OS bootstrap. Before OS bootstrap, it must be stored in the disk blocks 11 and 12. The OS bootstrap loader must load this program to memory pages 69 and 70 (See eXpOS Disk and Memory layout for details). The Page Table and Process Table for the idle process must be set up by the bootstrap loader. The PID of the idle process is fixed to be 0. Idle program runs an infinite loop. The algorithm for the idle is as follows. while(1) do endwhile An ExpL program for idle process is given below. int main() { decl int a; enddecl begin while(1==1) do a=1; endwhile; return 0; end } Compile the above code and load it into disk blocks 11 and 12 before system startup, using the command. load --idle <...path to idle...>","title":"Idle Program"},{"location":"roadmap/stage-12/#modifications-to-os-startup-code","text":"The eXpOS assigns each process a unique process ID (PID). The eXpOS design stipulates that the PID of idle process is 0. INIT program is assigned PID 1. Our implementation plan in this road map is to store the process table entry for the process with ID=0 in the 16 words starting at memory address PROCESS_TABLE, the process table entry for process with PID=1 in 16 words starting at memory address PROCESS_TABLE+16 and so on. Similarly, the page table for the process with PID=0 will be stored in 20 words starting at address PAGE_TABLE_BASE, page table for PID=1 will start at PAGE_TABLE_BASE+20 and so on. The memory layout design permits space for process/page table entries for a maximum of 16 processes.Thus, the OS can run at most 16 processes concurrently. At present, we will run just two processes - the idle process with PID=0 and the init process with PID=1.Since there are two processes, we need to set up several data structures so that the operating system is able to keep track of the state of each process while in execution. The steps are described below. 1) Load the idle code from disk to memory. loadi(69,11); loadi(70,12); 2) Set the page table entries for idle process. As idle process does not use library functions or dynamic memory allocation, it doesn't need library and heap pages. Therefore, you need to set up entries for only the code and stack pages. As memory requirements of idle are very low,we need to allocate only one physical page for stack. We will allocate page 81 for stack as pages 76-80 will be used by the init process. PTBR=PAGE_TABLE_BASE; //as PID of idle process is 0 //Library [PTBR+0] = -1; [PTBR+1] = \"0000\"; [PTBR+2] = -1; [PTBR+3] = \"0000\"; //Heap [PTBR+4] = -1; [PTBR+5] = \"0000\"; [PTBR+6] = -1; [PTBR+7] = \"0000\"; //Code [PTBR+8] = 69; [PTBR+9] = \"0100\"; [PTBR+10] = 70; [PTBR+11] = \"0100\"; [PTBR+12] = -1; [PTBR+13] = \"0000\"; [PTBR+14] = -1; [PTBR+15] = \"0000\"; //Stack [PTBR+16] = 81; [PTBR+17] = \"0110\"; [PTBR+18] = -1; [PTBR+19] = \"0000\"; 3) We will run the INIT process of stage 11 (to print all numbers below 50) concurrently. Set the Page Table entries for init as done in previous stages with PTBR as PAGE_TABLE_BASE+20. 4) As noted earlier, Process Table entries for idle starts from address PROCESS_TABLE and init from PROCESS_TABLE + 16. Set the PID field in the Process Table entry to 0 for idle and 1 for init. 5) The process being currently scheduled is said to be in RUNNING state.The bootstrap loader will schedule the init process first.Thus, in the OS startup code, set the STATE field in process table entry of the idle process to CREATED and INIT process to RUNNING . The CREATED state indicates that the process had never been scheduled for execution previously. The need for a separate CREATED state will be explained later. Subsequent \"re-scheduling\" will be done by the timer interrupt handler. According to process table, STATE field occupies 2 words. In case of RUNNING and CREATED states, second word is not required. See process states . 6) We will allocate the next free page, 82 as the User Area Page for the idle process. Set the User Area Page number field in the Process Table entry of idle to 82. 7) Set the UPTR field in the Process Table entry for idle to 8*512 which is the logical address of user SP. (The reasoning behind this step was explained in detail in Stage 7). 8) Set the KPTR field of the process table for idle to 0. The User Area Page Number field of a process table entry stores the page number of the user area page allocated to the process. The KPTR field must store the offset of the kernel stack pointer within this page. The UPTR points to the top of the current value of user stack pointer. Some explanation is of the order here. When a process is executing in user mode, the active stack will be the user stack (logical pages 8-9 of the process). When the process switches to kernel mode, the first action by the kernel code will be to save the SP value to UPTR and set the SP register to the physical address of the top of the kernel stack. When a process enters the kernel mode from user mode, the kernel stack will always be empty. Hence, SP must be set to value (User Area Page Number * 512 - 1) whenever kernel mode is entered from the user mode. Similarly, before a process executes IRET instruction and switch from kernel mode to user mode, the SP register must be set to previously stored value in UPTR field of the process table. The kernel stack will be empty when a process returns to user mode as there is no kernel context to be remembered. 9) Set the PTBR field to PAGE_TABLE_BASE and PTLR field to 10 in the Process Table entry of idle process. 10) Set the entry point IP value from the header of idle process to top of the user stack of the idle process as done in the previous stage. [81 * 512] = [69*512 + 1]; The values of PTBR, PTLR, User Area Page Number, UPTR, KPTR etc. stored in the process table entry for a process will be used to set up the values of the hardware registers just before the process is scheduled for execution. We will not be scheduling the idle process immediately. Hence, the hardware registers will not be set based on the above values now. Instead, we will schedule the INIT process from the OS startup code. Hence your OS startup code must contain code to set up registers to schedule the INIT process, as outlined below: 11) Set User Area Page number, UPTR, KPTR, PTBR and PTLR fields in the Process Table entry for init. 12) Initialise the machine's PTBR and PTLR registers for scheduling the INIT process. (You have alreay gone through the steps in Stage 7). 13) Set the Entry point address for INIT process in the beginning of Stack page of INIT. Also set the SP register accordingly. 14) Set the current PID field in system status table to 1, as PID for INIT is 1. 15) Transfer control to INIT using ireturn instruction. Note You must be clear with XSM unprivileged mode execution to understand the description that follows.","title":"Modifications to OS Startup Code"},{"location":"roadmap/stage-12/#modifications-to-timer-interrupt-handler","text":"In the previous stage you made the timer interrupt display \"TIMER\" at fixed intervals. However, the actual function of timer interrupt routine is to preempt the current running process and to transfer execution to another ready processes. In this stage, you will write a sample scheduler which will schedule just two processes. The scheduler will be implemented in the timer interrupt handler. After saving the context of the currently executing process in its kernel stack, the scheduler must switch to the kernel stack to that of the next process to be scheduled. The context of the next process has to be loaded to the registers and then control of execution can be transferred to the process. Detailed intructions for scheduling are given below. 1) Switch from the user stack to kernel stack of the currently executing process and save the register context using the backup instruction as done in stage 9. 2) Obtain the PID of currently executing process from System Status Table . alias currentPID R0; currentPID = [SYSTEM_STATUS_TABLE+1]; 3) The Process table entry of the current process can be computed as PROCESS_TABLE + currentPID*16. Save the KPTR, PTBR and PTLR values to the Process Table entry of the current process. Set the state of the process as READY. alias process_table_entry R1; process_table_entry = PROCESS_TABLE + currentPID * 16; [process_table_entry + 12] = SP % 512; [process_table_entry + 14] = PTBR; [process_table_entry + 15] = PTLR; [process_table_entry + 4] = READY; Note that instead of saving the actual value of KPTR, we are saving KPTR%512. This is because the OS design stipulates that KPTR must contain the offset of the kernel stack pointer within the User Area Page. This is done so as to allow the OS to relocate the User Area Page if necessary. 4) As we have only two processes to schedule, the scheduling algorithm we are going to use will just toggle between the two processes. alias newPID R2; if(currentPID == 0) then newPID = 1; else newPID = 0; endif; 5) Restore the SP, PTBR and PTLR values from the Process Table entry for the new process. alias new_process_table R3; new_process_table = PROCESS_TABLE + newPID * 16; //Set back Kernel SP, PTBR , PTLR SP = [new_process_table + 11] * 512 + [new_process_table + 12] ; PTBR = [new_process_table + 14]; PTLR = [new_process_table + 15]; 6) Set the PID field of the System Status Table as newPID. [SYSTEM_STATUS_TABLE + 1] = newPID; 7) Our scheduler must distinguish between two cases when a process is scheduled for execution. If a process is in CREATED state, the process had never been scheduled for execution earlier. Such a process will have no \"history\" to remember, and thus no \"user context\" to be restored before being scheduled. On the other hand, a process in READY state is one which had been in RUNNING state in the past. Such a process will have an associated (saved user context) which the scheduler would have saved in the kernel stack when it was scheduled out earlier. This context has to be restored before the process is scheduled again for correct resumption of execution. Check if the newly found process is in CREATED state. If so, set SP to top of its user stack and return to user mode. if([new_process_table + 4] == CREATED) then [new_process_table + 4] = RUNNING; SP = [new_process_table + 13]; ireturn; endif; Note In this stage, the only situation where the timer finds the next process in CREATED state is when the IDLE process is to be scheduled for the first time. Since INIT is scheduled directly from the OS startup code, the INIT process never goes through the CREATED state. 8) Set the state of the newly found process as RUNNING. [new_process_table + 4] = RUNNING; 9) Restore the register context of the new process from its kernel stack and change the stack to user stack as done in previous stages. Note that if this is the case, then the process would have been in RUNNING state before.","title":"Modifications to timer interrupt handler"},{"location":"roadmap/stage-12/#making-things-work","text":"1) Compile and load the modified OS statup code and Timer Interrupt handler to XSM disk. 2) Compile and load the idle program into the XSM disk 3) Run the machine with timer enabled. What is the significance of the idle process? The main purpose of the idle process is to run as a background process in an infinite loop. The idle process does nothing except running an infinite loop. This is demanded by the OS so that the scheduler will always have atleast one \"READY\" process to schedule. It is to be scheduled only when no other process is available for scheduling. However, in this stage we have scheduled idle just like any other process. Assignment 1 Load a program to print numbers from 1-100 as the INIT program, and modify IDLE to print numbers from 101-200. (You will have to link the library to address space of IDLE for the Write function call to work.) Assignment 2 Set two breakpoints (see SPL breakpoint instruction ) in the timer interrupt routine, the first one immediately upon entering the timer routine and the second one just before return from the timer routine. Dump the process table entry and page table entries of current process (see XSM debugger for various printing options).","title":"Making Things Work"},{"location":"roadmap/stage-13/","text":"Learning Objectives Introduction to XSM Module Programming. Implementation of Boot Module. Modules in eXpOS are used to perform certain logical tasks, which are performed frequently. eXpOS modules serve various purposes like scheduling new process, acquiring and releasing resources etc. These modules run in kernel mode and are invoked only from the kernel mode. A user program can never invoke a module directly. Modules can be invoked from interrupt routines, other modules or the OS startup code. As modules execute in kernel mode, the kernel stack of the currently scheduled process is used as the caller-stack for module invocation. XSM supports eight modules - MOD_0 to MOD_7 - which can be invoked using the CALL MOD_n / CALL <module_name> instruction (see SPL constants ).While switching to module, the CALL instruction pushes the IP address of the instruction following the CALL instruction on the top of the kernel stack and starts execution of the corresponding module. A module returns to the caller using the RET instruction (return statement in SPL) which restores the IP value present on the top of the kernel stack, pushed earlier by the CALL instruction. Note that we use the return statement, instead of the ireturn statement, to return to the caller. The IRET instruction (ireturn statement) changes mode from kernel to user as it assumes that SP contains a logical address. The RET instruction (return statement) on the other hand just returns to the caller in kernel mode, using the IP value pointed by SP. Read about kernel stack management during kernel module calls here . A module in eXpOS may implement several functions, each for a particular task ( eg- resource manager module -module 0).Some modules may perform a single task (eg- scheduler, boot module). For a module with several functions, each function is given a function number to distinguish them within the module. This function number should be passed as argument in the register R1 along with other arguments in R2, R3 etc. Register R0 is reserved for return value. See SPL module calling conventions for details.For details about the OS functions implemented in various eXpOS modules, see here . According to the memory organization of eXpOS, the OS startup code is provided with only one memory page (page numer 1). However, the code for OS startup may exceed one page due to initialization of several OS data structures. So we design a module for the purpose of OS initialization. This module will be called the Boot module (module 7). The Boot module is invoked from the OS startup code. The OS startup code hand-creates the idle process, initializes the SP register to the kernel stack of the idle process, loads module 7 in memory and then invokes the boot module (using the stack of the IDLE process). Upon return from the boot module, the OS startup code initiates user mode execution of the idle process. Note that in the previous stage, we had scheduled the INIT process first, before executing the IDLE pocess. Starting from the present stage, the idle process will be scheduled first. All further scheduling of processes will be controlled by the timer interrupt routine and a scheduler module, which will be discussed in the next stage. The Boot module is responsible for initialization of all eXpOS data structures, user processes and also loading of all interrupt routines and modules. You will not modify the OS startup code written in this stage in subsequent stages. However, you will add more code to the boot module as you go through various stages of the roadmap. The idle process is run first to ensure that this process is scheduled at least once, so that its context gets initialized. This useful because in later stages, certain kernel operations (like disk swap) are performed from the context of the IDLE process. For now, we skip over this matter. Modifications to OS startup code \u00b6 1) Load module 7 from disk blocks 67 and 68 to memory pages 54 and 55 respectively, also load idle process from the disk to the corresponding memory pages . 2) Set SP to (user area page number) * 512 -1. The user area page number for the idle process is 82 (as decided in the previous stage). This sets up a stack for calling the boot module. 3) Call module 7 (boot module) using call statement in SPL. call BOOT_MODULE; / The following code is executed after return from the boot module / 4) Setup the page table entries for the idle process as was done in the previous stage. Also set up PTBR to the page table base of the idle process. (The SPL constant PAGE_TABLE_BASE will point to the start of the page table of the idle process - figure out why.) Initialize PTLR (all user process in eXpOS must have PTLR=10). 5) Initialize PID, UPTR, KPTR, PTBR, PTLR and user area page number fields in the Process Table entry for the idle process as was done in the previous stage. 6) As the idle process is scheduled first, initialize the STATE field in the process table entry of the idle process as RUNNING and current PID field in the System Status Table to 0 (PID of the idle process). 7) Transfer the entry point value from the header of the idle process to the top of the user stack of the idle process, as was done in the previous stage. 8)Set the SP to the logical address of the user stack (8*512). 9) Switch to the user mode using the ireturn statement. Boot module \u00b6 Load all the required interrupts routines, eXpOS library, exception handler and the INIT process from the disk to the memory as was done in the OS startup code of the previous stage. Set the page table entries for INIT process as was done in the previous stage. Initialize the process table entry for the INIT process (setting PID, UPTR, KPTR, PTLR, PTBR, user area page number etc.) as was done in the previous stage. Set the STATE field in the process table entry of INIT to CREATED. (INIT will not be scheduled immedietely, as the idle process is going to be scheduled first.) Transfer the entry point value from the header of the INIT process to the top of the user stack of the INIT process, as was done in the previous stage. Return from module to OS startup code using return statement in SPL. Making things work \u00b6 Compile and load module 7 and the modified OS startup code to the disk using XFS interface. Run the XSM machine with timer enabled. Assignment 1 Write ExpL programs to print even and odd numbers below 100. Modify the boot module code and the timer interrupt handler to schedule the two processes along with the idle process concurrently using the Round Robin scheduling algorithm. Assignment 2 In the program of the previous assignment, add a breakpoint immediately upon entering the timer interrupt handler and print out in debug mode the contents of the page table entry and the process table entry of the current process (that is, the process from which timer was entered). You need to use use p and pt options of xsm debugger. Add another breakpoint just before return from the timer interrupt handler to print out the same contents.","title":"Stage 13"},{"location":"roadmap/stage-13/#modifications-to-os-startup-code","text":"1) Load module 7 from disk blocks 67 and 68 to memory pages 54 and 55 respectively, also load idle process from the disk to the corresponding memory pages . 2) Set SP to (user area page number) * 512 -1. The user area page number for the idle process is 82 (as decided in the previous stage). This sets up a stack for calling the boot module. 3) Call module 7 (boot module) using call statement in SPL. call BOOT_MODULE; / The following code is executed after return from the boot module / 4) Setup the page table entries for the idle process as was done in the previous stage. Also set up PTBR to the page table base of the idle process. (The SPL constant PAGE_TABLE_BASE will point to the start of the page table of the idle process - figure out why.) Initialize PTLR (all user process in eXpOS must have PTLR=10). 5) Initialize PID, UPTR, KPTR, PTBR, PTLR and user area page number fields in the Process Table entry for the idle process as was done in the previous stage. 6) As the idle process is scheduled first, initialize the STATE field in the process table entry of the idle process as RUNNING and current PID field in the System Status Table to 0 (PID of the idle process). 7) Transfer the entry point value from the header of the idle process to the top of the user stack of the idle process, as was done in the previous stage. 8)Set the SP to the logical address of the user stack (8*512). 9) Switch to the user mode using the ireturn statement.","title":"Modifications to OS startup code"},{"location":"roadmap/stage-13/#boot-module","text":"Load all the required interrupts routines, eXpOS library, exception handler and the INIT process from the disk to the memory as was done in the OS startup code of the previous stage. Set the page table entries for INIT process as was done in the previous stage. Initialize the process table entry for the INIT process (setting PID, UPTR, KPTR, PTLR, PTBR, user area page number etc.) as was done in the previous stage. Set the STATE field in the process table entry of INIT to CREATED. (INIT will not be scheduled immedietely, as the idle process is going to be scheduled first.) Transfer the entry point value from the header of the INIT process to the top of the user stack of the INIT process, as was done in the previous stage. Return from module to OS startup code using return statement in SPL.","title":"Boot module"},{"location":"roadmap/stage-13/#making-things-work","text":"Compile and load module 7 and the modified OS startup code to the disk using XFS interface. Run the XSM machine with timer enabled. Assignment 1 Write ExpL programs to print even and odd numbers below 100. Modify the boot module code and the timer interrupt handler to schedule the two processes along with the idle process concurrently using the Round Robin scheduling algorithm. Assignment 2 In the program of the previous assignment, add a breakpoint immediately upon entering the timer interrupt handler and print out in debug mode the contents of the page table entry and the process table entry of the current process (that is, the process from which timer was entered). You need to use use p and pt options of xsm debugger. Add another breakpoint just before return from the timer interrupt handler to print out the same contents.","title":"Making things work"},{"location":"roadmap/stage-14/","text":"Learning Objectives Implement a preliminary version of the Round Robin scheduling algorithm as an eXpOS module. Multiprogramming refers to running more than one process simultaneously. In this stage, you will implement an initial version of the Round Robin scheduler used in eXpOS. You will hand create another user process (apart from idle and init) and schedule its execution using the timer interrupt. 1) Write an ExpL program to print the odd numbers from 1-100. Load this odd program as init. load --init <path to odd.xsm>; Using the --exec option of XFS interface, you can load an executable program into the XFS disk. XFS interface will load the executable into the disk and create Inode table entry for the file. XFS interface will also create a root entry for the loaded file. From the Inode Table Entry, you will be able to find out the disk blocks where the contents of the file are loaded by XFS interface. Recall that these were discussed in detail in Stage 2 : Understanding the File System ) 2) Write an ExpL program to print the even numbers from 1-100. Load this even program as an executable. load --exec <path to even.xsm>; Dump the inode table using dump --inodeusertable command in xfs-interface. Check the disk address of code blocks of even.xsm. Modifications to the boot module code \u00b6 1) Load the code pages of the even program from disk to memory. 2) Set the Process Table entry and PageTable entries for setting up a process for the even program. You should set up the PTBR, PTLR, UPTR, KPTR, User Area Page Number etc. and also initialize the process state as CREATED in the process table entry for the even process. Set the PID field in the process table entry to 2. Make sure that you do not allot memory pages that are already allotted to some other process or reserved for the operating system. 3) Set the starting IP of the new process on top of its user stack. 4) We will implement the scheduler as a seperate module that can be invoked from the timer ISR (Interrupt Service Routine). The eXpOS design stipulates that the scheduler is implemented as MODULE_5, and loaded in disk blocks 63 and 64 of the XFS disk. The boot module must load this module from disk to memory pages 50 and 51. (We will take up the implementation of the module soon below). loadi(50,63); loadi(51,64); 1) First 3 process table entries are occupied. Initialize STATE field of all other process table entries to TERMINATED. This will be useful while finding the next process to schedule using round robin scheduling algorithm. Note that when the STATE field in the process table entry is marked as TERMINATED, this indicates that the process table entry is free for allocation to new processes. Modifications to Timer Interrupt Routine \u00b6 As we are going to write the scheduler code as a separate module (MOD_5), we will modify the timer interrupt routine so that it calls that module. When the timer ISR calls the scheduler, the active kernel stack will be that of the currently RUNNING process. The scheduler assumes that the timer handler would have saved the user context of the current process (values of R0-R19 and BP registers) into the kernel stack before the call. It also assumes that the state of the process has been changed to READY.However, the machine's SP register will still point to the top of the kernel stack of the currently running process at the time of the call. The scheduler first saves the values of the registers SP, PTBR and PTLR to the process table entry of the current process. Next, it must decide which process to run next. This is done using the Round Robin Scheduling algorithm . Having decided on the new process, the scheduler loads new values into SP, PTBR and PTLR registers from the process table entry of the new process. It also updates the system status table to store PID of new process. If the state of the new process is READY, then the scheduler changes the state to RUNNING. Now, the scheduler returns using the return instruction. The control flow at this point is tricky and must be carefully understood. The key point to note here is that although the scheduler module was called by one process (from the timer ISR), since the stack was changed inside the scheduler, the return is to a program instruction in some other process! (determined by the value on top of the kernel stack of the newly scheduled process) . The return is to that instruction which immediately follows the call scheduler instruction in the newly selected process. (why? - ensure that you understand this point clearly.) An exception to this rule happens only when the newly selected process to be scheduled is in the CREATED state. Here, the process was never run and hence there is no return address in the kernel stack. Hence, the scheduler directly kick-starts execution of the process by initiating user mode execution of the process (using the ireturn instruction). The design of eXpOS guarantees that a process can invoke the scheduler module only from the kernel mode. Consequently, the return address will be always stored on top of the kernel stack of the process. The round robin scheduling algorithm generally schedules the \"next process\" in the process table that is in CREATED/READY state. (There are exceptions to this rule, which we will encounter in later stages.) Moreover, in the present stage, a process will invoke the scheduler only from the timer interrupt. We will see other situations in later stages. As noted above, the timer resumes execution from the return address stored on the top of the kernel stack of the new process. The timer will restore the user context of the new process from the stack and return to the user mode, resulting in the new process being executed. If the scheduler finds that the new process is in state CREATED and not READY, then as noted above, the timer ISR would not have set any return address in its kernel stack previously. In this case, the scheduler will set the state of the process to RUNNING and initialize machine registers PTLR and PTBR. Now, the scheduler proceeds to run the process in user mode.Hence, SP is set to the top of the user stack. The scheduler then starts the execution of the new process by transferring control to user mode using the IRET instruction. The scheduler expects that when a process is in the CREATED state, the following values have been already set in the process table. (In the present stage, the OS startup code/Boot module is responsible for setting up these values.) The state of the process has been set to CREATED. The UPTR field of the process table entry has been set to the top of the user stack (and the stack-top contains the address of the instruction to be fetched next when the process is run in the user mode). PTBR, PTLR, User Area Page Number and KPTR fields in the process table entry has been set up. It is absolutely necessary to be clear about Kernel Stack Management during Module calls and Kernel Stack Management during Context Switch before proceeding further. Modify the timer interrupt routine as explained above using the algorithm given here . (Ignore the part relating to the swapping operation as it will be dealt in a later stage.) Context Switch Module (Scheduler Module) \u00b6 The scheduler module (module 5) saves the values of SP, PTBR and PTLR registers of the current process in its process table entry. It finds a new process to schedule which is in READY or CREATED state and has a valid PID (PID not equal to -1). Initialize the registers SP, PTBR, PTLR according to the values present in the process table entry of the new process selected for scheduling. Also update the System status table. Write an SPL program for the scheduler module (module 5) as given below: Obtain the PID of the current process from the System Status Table . Push the BP of the current process on top of the kernel stack. (See the box below) Obtain the Process Table entry corresponding to the current PID. Save SP % 512 in the kernel stack pointer field, also PTBR and PTLR into the corresponding fields in the Process Table entry. Iterate through the Process Table entries, starting from the succeeding entry of the current process to find a process in READY or CREATED state. If no such process can be found, select the idle process as the new process to be scheduled. Save PID of new process to be scheduled as newPID. Obtain User Area Page number and kernel stack pointer value from Process Table entry of the new process and set SP as (User Area Page number) * 512 + (Kernel Stack pointer value). Restore PTBR and PTLR from the corresponding fields in the Process Table entry of the new process. Set the PID of the new process in the current PID field of the System Status Table. If the new process is in CREATED state, then do the following steps. Set SP to the value in the UPTR field of the process table entry. Set state of the newly scheduled process as RUNNING. Store 0 in the MODE FLAG field in the process table of the process. Switch to the user mode using the ireturn statement. Set the state of the new process as RUNNING. Restore the BP of the new process from the top of it's kernel stack. Return using return statement. Note In later stages you will modify the scheduler module to the final form given here . In the present stage, the scheduler module is called only from the time interrupt handler. The timer interrupt handler already contains the instruction to backup the register context of the current process. Hence, the scheduler does not have to worry about having to save the user register context (including the value of the BP register) of the current process. What then is the need for the scheduler to push the BP register? The reason is that, in later stages, the scheduler may be called from kernel modules other than the timer interrupt routine. Such calls typically happen when an application invokes a system call and the system call routine invokes a kernel module which in turn invokes the scheduler. Whenever this is the case, the OS kernel expects that the application saves all the user mode registers except the BP register before making the system call. For instance, if the application is written in ExpL and compiled using the ExpL compiler given to you, the compiler saves all the user registers except BP before making the system call. The ExpL compiler expects that the OS will save the value of the BP register before scheduling another application process. This explains why the scheduler needs to save the BP register before a context switch. Modifications to INT 10 handler \u00b6 The ExpL compiler sets every user program to execute the INT 10 instruction (exit system call) at the end of execution to terminate the process gracefully. In previous stages, we wrote an INT 10 routine containing just a halt instruction. Hence, if any process invoked INT 10 upon exit, the machine would halt and no other process would execute further. However, to allow multiple processes to run till completion, INT 10 must terminate only the process which invoked it, and schedule other surviving processes. (INT 10 shall set the state of the dying process to TERMINATED). If all processes except idle are in TERMINATED state, then INT 10 routine can halt the system. Write INT 10 program in SPL following below steps : Change the state of the invoking process to TERMINATED . Find out whether all processes except idle are terminated. In that case, halt the system.Otherwise invoke the scheduler There will be no return to this process as the scheduler will never schedule this process again. Making things work \u00b6 Compile and load the Boot module code, timer interrupt routine, scheduler module (module 5) and interrupt 10 routine into disk using XFS interface. Run XSM machine with timer enabled. When does the OS kernel invoke the scheduler from some routine other than the timer interrupt handler? In later stages, if a process gets blocked inside a kernel module (waiting for some resource), then the process will set its state to \"WAITING\" and will invoke the scheduler. Later when the process is back in READY state (as the resource becomes free) and the scheduler selects the process for running, execution returns to the instruction following the call to the scheduler in the kernel module. Assignment 1 Write ExpL programs to print odd numbers, even numbers and prime numbers between 1 and 100. Modify the boot module code accordingly and run the machine with these 3 processes along with idle process.","title":"Stage 14"},{"location":"roadmap/stage-14/#modifications-to-the-boot-module-code","text":"1) Load the code pages of the even program from disk to memory. 2) Set the Process Table entry and PageTable entries for setting up a process for the even program. You should set up the PTBR, PTLR, UPTR, KPTR, User Area Page Number etc. and also initialize the process state as CREATED in the process table entry for the even process. Set the PID field in the process table entry to 2. Make sure that you do not allot memory pages that are already allotted to some other process or reserved for the operating system. 3) Set the starting IP of the new process on top of its user stack. 4) We will implement the scheduler as a seperate module that can be invoked from the timer ISR (Interrupt Service Routine). The eXpOS design stipulates that the scheduler is implemented as MODULE_5, and loaded in disk blocks 63 and 64 of the XFS disk. The boot module must load this module from disk to memory pages 50 and 51. (We will take up the implementation of the module soon below). loadi(50,63); loadi(51,64); 1) First 3 process table entries are occupied. Initialize STATE field of all other process table entries to TERMINATED. This will be useful while finding the next process to schedule using round robin scheduling algorithm. Note that when the STATE field in the process table entry is marked as TERMINATED, this indicates that the process table entry is free for allocation to new processes.","title":"Modifications to the boot module code"},{"location":"roadmap/stage-14/#modifications-to-timer-interrupt-routine","text":"As we are going to write the scheduler code as a separate module (MOD_5), we will modify the timer interrupt routine so that it calls that module. When the timer ISR calls the scheduler, the active kernel stack will be that of the currently RUNNING process. The scheduler assumes that the timer handler would have saved the user context of the current process (values of R0-R19 and BP registers) into the kernel stack before the call. It also assumes that the state of the process has been changed to READY.However, the machine's SP register will still point to the top of the kernel stack of the currently running process at the time of the call. The scheduler first saves the values of the registers SP, PTBR and PTLR to the process table entry of the current process. Next, it must decide which process to run next. This is done using the Round Robin Scheduling algorithm . Having decided on the new process, the scheduler loads new values into SP, PTBR and PTLR registers from the process table entry of the new process. It also updates the system status table to store PID of new process. If the state of the new process is READY, then the scheduler changes the state to RUNNING. Now, the scheduler returns using the return instruction. The control flow at this point is tricky and must be carefully understood. The key point to note here is that although the scheduler module was called by one process (from the timer ISR), since the stack was changed inside the scheduler, the return is to a program instruction in some other process! (determined by the value on top of the kernel stack of the newly scheduled process) . The return is to that instruction which immediately follows the call scheduler instruction in the newly selected process. (why? - ensure that you understand this point clearly.) An exception to this rule happens only when the newly selected process to be scheduled is in the CREATED state. Here, the process was never run and hence there is no return address in the kernel stack. Hence, the scheduler directly kick-starts execution of the process by initiating user mode execution of the process (using the ireturn instruction). The design of eXpOS guarantees that a process can invoke the scheduler module only from the kernel mode. Consequently, the return address will be always stored on top of the kernel stack of the process. The round robin scheduling algorithm generally schedules the \"next process\" in the process table that is in CREATED/READY state. (There are exceptions to this rule, which we will encounter in later stages.) Moreover, in the present stage, a process will invoke the scheduler only from the timer interrupt. We will see other situations in later stages. As noted above, the timer resumes execution from the return address stored on the top of the kernel stack of the new process. The timer will restore the user context of the new process from the stack and return to the user mode, resulting in the new process being executed. If the scheduler finds that the new process is in state CREATED and not READY, then as noted above, the timer ISR would not have set any return address in its kernel stack previously. In this case, the scheduler will set the state of the process to RUNNING and initialize machine registers PTLR and PTBR. Now, the scheduler proceeds to run the process in user mode.Hence, SP is set to the top of the user stack. The scheduler then starts the execution of the new process by transferring control to user mode using the IRET instruction. The scheduler expects that when a process is in the CREATED state, the following values have been already set in the process table. (In the present stage, the OS startup code/Boot module is responsible for setting up these values.) The state of the process has been set to CREATED. The UPTR field of the process table entry has been set to the top of the user stack (and the stack-top contains the address of the instruction to be fetched next when the process is run in the user mode). PTBR, PTLR, User Area Page Number and KPTR fields in the process table entry has been set up. It is absolutely necessary to be clear about Kernel Stack Management during Module calls and Kernel Stack Management during Context Switch before proceeding further. Modify the timer interrupt routine as explained above using the algorithm given here . (Ignore the part relating to the swapping operation as it will be dealt in a later stage.)","title":"Modifications to Timer Interrupt Routine"},{"location":"roadmap/stage-14/#context-switch-module-scheduler-module","text":"The scheduler module (module 5) saves the values of SP, PTBR and PTLR registers of the current process in its process table entry. It finds a new process to schedule which is in READY or CREATED state and has a valid PID (PID not equal to -1). Initialize the registers SP, PTBR, PTLR according to the values present in the process table entry of the new process selected for scheduling. Also update the System status table. Write an SPL program for the scheduler module (module 5) as given below: Obtain the PID of the current process from the System Status Table . Push the BP of the current process on top of the kernel stack. (See the box below) Obtain the Process Table entry corresponding to the current PID. Save SP % 512 in the kernel stack pointer field, also PTBR and PTLR into the corresponding fields in the Process Table entry. Iterate through the Process Table entries, starting from the succeeding entry of the current process to find a process in READY or CREATED state. If no such process can be found, select the idle process as the new process to be scheduled. Save PID of new process to be scheduled as newPID. Obtain User Area Page number and kernel stack pointer value from Process Table entry of the new process and set SP as (User Area Page number) * 512 + (Kernel Stack pointer value). Restore PTBR and PTLR from the corresponding fields in the Process Table entry of the new process. Set the PID of the new process in the current PID field of the System Status Table. If the new process is in CREATED state, then do the following steps. Set SP to the value in the UPTR field of the process table entry. Set state of the newly scheduled process as RUNNING. Store 0 in the MODE FLAG field in the process table of the process. Switch to the user mode using the ireturn statement. Set the state of the new process as RUNNING. Restore the BP of the new process from the top of it's kernel stack. Return using return statement. Note In later stages you will modify the scheduler module to the final form given here . In the present stage, the scheduler module is called only from the time interrupt handler. The timer interrupt handler already contains the instruction to backup the register context of the current process. Hence, the scheduler does not have to worry about having to save the user register context (including the value of the BP register) of the current process. What then is the need for the scheduler to push the BP register? The reason is that, in later stages, the scheduler may be called from kernel modules other than the timer interrupt routine. Such calls typically happen when an application invokes a system call and the system call routine invokes a kernel module which in turn invokes the scheduler. Whenever this is the case, the OS kernel expects that the application saves all the user mode registers except the BP register before making the system call. For instance, if the application is written in ExpL and compiled using the ExpL compiler given to you, the compiler saves all the user registers except BP before making the system call. The ExpL compiler expects that the OS will save the value of the BP register before scheduling another application process. This explains why the scheduler needs to save the BP register before a context switch.","title":"Context Switch Module (Scheduler Module)"},{"location":"roadmap/stage-14/#modifications-to-int-10-handler","text":"The ExpL compiler sets every user program to execute the INT 10 instruction (exit system call) at the end of execution to terminate the process gracefully. In previous stages, we wrote an INT 10 routine containing just a halt instruction. Hence, if any process invoked INT 10 upon exit, the machine would halt and no other process would execute further. However, to allow multiple processes to run till completion, INT 10 must terminate only the process which invoked it, and schedule other surviving processes. (INT 10 shall set the state of the dying process to TERMINATED). If all processes except idle are in TERMINATED state, then INT 10 routine can halt the system. Write INT 10 program in SPL following below steps : Change the state of the invoking process to TERMINATED . Find out whether all processes except idle are terminated. In that case, halt the system.Otherwise invoke the scheduler There will be no return to this process as the scheduler will never schedule this process again.","title":"Modifications to INT 10 handler"},{"location":"roadmap/stage-14/#making-things-work","text":"Compile and load the Boot module code, timer interrupt routine, scheduler module (module 5) and interrupt 10 routine into disk using XFS interface. Run XSM machine with timer enabled. When does the OS kernel invoke the scheduler from some routine other than the timer interrupt handler? In later stages, if a process gets blocked inside a kernel module (waiting for some resource), then the process will set its state to \"WAITING\" and will invoke the scheduler. Later when the process is back in READY state (as the resource becomes free) and the scheduler selects the process for running, execution returns to the instruction following the call to the scheduler in the kernel module. Assignment 1 Write ExpL programs to print odd numbers, even numbers and prime numbers between 1 and 100. Modify the boot module code accordingly and run the machine with these 3 processes along with idle process.","title":"Making things work"},{"location":"roadmap/stage-15/","text":"Learning Objectives Familiarise with passing of parameters to modules. Implement Resource Manager and Device Manager modules for terminal output handling. Processes in eXpOS require various resources like terminal, disk, inode etc. To manage these resources among different processes eXpOS implements a resource manager module (Module 0). Before the use of a resource, a process has to first acquire the required resource by invoking the resource manager. A process can acquire a resource if the resource is not already acquired by some other process. If the resource requested by a process is not available, then that process has to be blocked until the resource becomes free. In the meanwhile, other processes may be scheduled. A blocked process must wake up when the requested resource is released by the process which had acquired the resource. For this, when a process releases a resource, the state of other processes waiting for the resource must be set to READY The resource manager module handles acquisition and release of system resources. A process must invoke the resource manager to acquire or release any system resource. The resource manager implements two functions for each resource - one to acquire the resource and the other to release the resource by a process. Details about different functions implemented in resource manager module are given here . In this stage, you will learn how the terminal is shared by the processes for writing. The OS maintains a data structure called the Terminal Status Table . The Terminal Status table contains details ofthe process that has acquired the terminal. (Since there is only one terminal in the system, only one process is allowed to acquire the terminal at a time.) A flag named STATUS in the terminal status table indicates whether the terminal is available or not. When a process acquires the terminal, the PID of the process is updated in the terminal status table. There are two functions related to terminal management in module 0. These are the Acquire Terminal and the Release Terminal functions. Each function has a function number to identify the function within the module. In the Resource Manager module, Acquire Terminal and Release Terminal have function numbers 8 and 9 respectively . When a module function is invoked, the function number (identifying the particular function within the module) is stored in register R1 and passed as argument to the module. The other arguments are passed through registers R2, R3 etc. See SPL module calling convention . For both Acquire Terminal and Release Terminal, PID of the currently running process needs to be passed as an argument through the register R2. Acquire Terminal and Release Terminal are not directly invoked from the write system call. Write system call invokes a function called Terminal Write present in device manager module (Module 4). Terminal Write function acts as anabstract layer between the write system call and terminal handling functions in resource manager module. The function number for Terminal Write is 3 which is stored in register R1. The other arguments are PID of the current process and the word to be printed which are passed through registers R2 and R3 respectively. Terminal Write first acquires the terminal by calling Acquire Terminal. It prints the word (present in R3) passed as an argument. It then frees the terminal by invoking Release Terminal. Since the invoked module will be modifying the contents of the machine registers during its execution, The invoker must save the registers in use into the (kernel) stack of the process before invoking the module. The module sets its return value in register R0 before returning to the caller. The invoker must extract the return value, pop back the saved registers and resume execution. SPL provides the facility to push and pop multiple registers in one statement using multipush and mutlipop respectively. Refer to the usage of multipush and multipop statements in SPL before proceeding further. There is one important conceptual point to be explained here relating to resource acquisition. The Acquire Terminal function described above waits in a loop, in which it repeatedly invokes the scheduler if the terminal is not free. This kind of a waiting loop is called a busy loop or busy wait . Why can't the process wait just once for a resource and simply proceed to acquire the resource when it is scheduled? In other words, what is the need for a wait in a loop? Pause to think before you read the explanation below. You will encounter such busy loops several times in this project, inside various module functions described in later stages. When a process invokes the scheduler waiting for a resource, the scheduler runs the process again only after the resource becomes free. However, the process may find that the resource is locked again when it tries to acquire the resource when it resumes execution. This happens because when a resource is released, all processes waiting for the resource are woken up by the OS. Only the one that get scheduled first will be able to lock the resource successfully. Other processes will have to wait for the resource repeatedly before finally acquiring the resource. A better solution to the problem that avoids a busy loop is to have the resource manager maintain a request queue associated with each resource. When a process requests a resource, it registers itself into a resource queue and goes into wait state. When the resource is released, the release resource function can wake up only the process which is at head of the queue. This avoids unnecessary scheduling of all the waiting processes. Real systems implement resource queues for system resources that also maintains the priorities of various requesting processes. In eXpOS, we avoid using resource queues to make the implementation easier. Note We haven't saved any registers into the stack while invoking the boot module from the OS startup code or the scheduler module from the timer interrupt routine as there was no register context to be saved. However, to invoke scheduler module from other modules or interrupt routines, it is necessary to save the register context into the stack for proper resumption of execution. Control flow for Write system call Modifying INT 7 routine \u00b6 Interrupt routine 7 implemented in stage 10 is modified as given below to invoke Terminal Write function present in Device Manager module. Instead of print statement, write code to invoke Terminal Write function. Rest of the code remains intact. 1) Push all registers used till now in this interrupt routine using multipush statement in SPL. multipush(R0, R1, R2, R3,...); // number of registers will depend on your code 2) Store the function number of Terminal Write in register R1, PID of the current process in register R2 and word to be printed to the terminal in register R3. 3) Call module 4 using call statement . 4) Ignore the value present in R0 as Terminal Write does not have any return value. 5) Use multipop statement to restore the registers pushed. Specify the same order of registers used in multipush as registers are popped in the reverse order in which they are specified in the multipop statement. multipop(R0, R1, R2, R3,...); Implementation of Module 4 (Device Manager Module) \u00b6 In this stage, we will implement only Terminal Write function in this module. 1) Function number and current PID are stored in registers R1 and R2. Give meaningful names to these arguments. alias functionNum R1; alias currentPID R2; 2) Terminal write function has a function number 3. If the functionNum is 3, implement the following steps else return using return statement. Calling Acquire Terminal :- 3) Push all the registers used till now in this module using the multipush statement in SPL as done earlier. 4) Store the function number 8 in register R1 and PID of the current process from the System Status table in register R2 (Can use currentPID, as it already contain current PID value). 5) Call module 0. 6) Ignore the value present in R0 as Acquire Terminal does not have any return value. 7) Use the multipop statement to restore the registers as done earlier. 8) Print the word in register R3, using the print statement. Calling Release Terminal :- 9) Push all the registers used till now using the multipush statement as done earlier. 10) Store the function number 9 in register R1 and PID of the current process from the System Status table in register R2 (Can use currentPID, as it already contain current PID value). 11) Call module 0. 12) Return value will be stored in R0 by module 0. Save this return value in any other register if needed. 13) Restore the registers using the multipop statement. 14) Return using the return statement. Implementation of Module 0 code for terminal handling \u00b6 1) Function number is present in R1 and PID passed as an argument is stored in R2. Give meaningful names to these registers to use them further. alias functionNum R1; alias currentPID R2; 2) In Module 0, for the Acquire Terminal function (functionNum = 8) implement the following steps. The current process should wait in a loop until the terminal is free . Repeat the following steps if STATUS field in the Terminal Status table is 1(terminal is allocated to other process). Change the state of the current process in its process table entry to WAIT_TERMINAL. Push the registers used till now using the multipush statement. Call the scheduler to schedule other process as this process is waiting for terminal. Pop the registers pushed before. (Note that this code will be executed only after the scheduler schedules the process again, which in turn occurs only after the terminal was released by the holding process by invoking the release terminal function.) Change the STATUS field to 1 and PID field to currentPID in the Terminal Status Table. Return using the return statement. 3) For the Release Terminal function (functionNum = 9) implement the following steps. currentPID and PID stored in the Terminal Status table should be same. If these are not same, then process is trying to release the terminal without acquiring it. If this case occurs, store -1 as the return value in register R0 and return from the module. Change the STATUS field in the Terminal Status table to 0, indicating terminal is released. Update the STATE to READY for all processes (with valid PID) which have STATE as WAIT_TERMINAL. Save 0 in register R0 indicating success. Return to the caller. Modifying Boot Module code \u00b6 Load Module 0 from disk pages 53 and 54 to memory pages 40 and 41. Load Module 4 from disk pages 61 and 62 to memory pages 48 and 49. Initialize the STATUS field in the Terminal Status table as 0. This will indicate that the terminal is free before scheduling the first process. Making things work \u00b6 Compile and load boot module code, module 0, module 4, modified INT 7 routine using XFS-interface. Run the machine with two programs one printing even numbers and another printing odd numbers from 1 to 100 along with the idle process. According to eXpOS resource management system introduced here, will Deadlock occur? If yes, explain it with a situation. If no, which of the four conditions of Deadlock are not satisfied? Deadlock will not occur according to the resource management system implemented here. As hold and wait, circular wait conditions are not satisfied (there is only one resource - the terminal - now). Info See link for a set of neccessary conditions for deadlock. Assignment 1 Set a breakpoint (see SPL breakpoint instruction ) just before return from the Acquire Terminal and the Release Terminal functions in the Resource Manager module to dump the Terminal Status Table (see XSM debugger for various printing options).","title":"Stage 15"},{"location":"roadmap/stage-15/#modifying-int-7-routine","text":"Interrupt routine 7 implemented in stage 10 is modified as given below to invoke Terminal Write function present in Device Manager module. Instead of print statement, write code to invoke Terminal Write function. Rest of the code remains intact. 1) Push all registers used till now in this interrupt routine using multipush statement in SPL. multipush(R0, R1, R2, R3,...); // number of registers will depend on your code 2) Store the function number of Terminal Write in register R1, PID of the current process in register R2 and word to be printed to the terminal in register R3. 3) Call module 4 using call statement . 4) Ignore the value present in R0 as Terminal Write does not have any return value. 5) Use multipop statement to restore the registers pushed. Specify the same order of registers used in multipush as registers are popped in the reverse order in which they are specified in the multipop statement. multipop(R0, R1, R2, R3,...);","title":"Modifying INT 7 routine"},{"location":"roadmap/stage-15/#implementation-of-module-4-device-manager-module","text":"In this stage, we will implement only Terminal Write function in this module. 1) Function number and current PID are stored in registers R1 and R2. Give meaningful names to these arguments. alias functionNum R1; alias currentPID R2; 2) Terminal write function has a function number 3. If the functionNum is 3, implement the following steps else return using return statement. Calling Acquire Terminal :- 3) Push all the registers used till now in this module using the multipush statement in SPL as done earlier. 4) Store the function number 8 in register R1 and PID of the current process from the System Status table in register R2 (Can use currentPID, as it already contain current PID value). 5) Call module 0. 6) Ignore the value present in R0 as Acquire Terminal does not have any return value. 7) Use the multipop statement to restore the registers as done earlier. 8) Print the word in register R3, using the print statement. Calling Release Terminal :- 9) Push all the registers used till now using the multipush statement as done earlier. 10) Store the function number 9 in register R1 and PID of the current process from the System Status table in register R2 (Can use currentPID, as it already contain current PID value). 11) Call module 0. 12) Return value will be stored in R0 by module 0. Save this return value in any other register if needed. 13) Restore the registers using the multipop statement. 14) Return using the return statement.","title":"Implementation of Module 4 (Device Manager Module)"},{"location":"roadmap/stage-15/#implementation-of-module-0-code-for-terminal-handling","text":"1) Function number is present in R1 and PID passed as an argument is stored in R2. Give meaningful names to these registers to use them further. alias functionNum R1; alias currentPID R2; 2) In Module 0, for the Acquire Terminal function (functionNum = 8) implement the following steps. The current process should wait in a loop until the terminal is free . Repeat the following steps if STATUS field in the Terminal Status table is 1(terminal is allocated to other process). Change the state of the current process in its process table entry to WAIT_TERMINAL. Push the registers used till now using the multipush statement. Call the scheduler to schedule other process as this process is waiting for terminal. Pop the registers pushed before. (Note that this code will be executed only after the scheduler schedules the process again, which in turn occurs only after the terminal was released by the holding process by invoking the release terminal function.) Change the STATUS field to 1 and PID field to currentPID in the Terminal Status Table. Return using the return statement. 3) For the Release Terminal function (functionNum = 9) implement the following steps. currentPID and PID stored in the Terminal Status table should be same. If these are not same, then process is trying to release the terminal without acquiring it. If this case occurs, store -1 as the return value in register R0 and return from the module. Change the STATUS field in the Terminal Status table to 0, indicating terminal is released. Update the STATE to READY for all processes (with valid PID) which have STATE as WAIT_TERMINAL. Save 0 in register R0 indicating success. Return to the caller.","title":"Implementation of Module 0 code for terminal handling"},{"location":"roadmap/stage-15/#modifying-boot-module-code","text":"Load Module 0 from disk pages 53 and 54 to memory pages 40 and 41. Load Module 4 from disk pages 61 and 62 to memory pages 48 and 49. Initialize the STATUS field in the Terminal Status table as 0. This will indicate that the terminal is free before scheduling the first process.","title":"Modifying Boot Module code"},{"location":"roadmap/stage-15/#making-things-work","text":"Compile and load boot module code, module 0, module 4, modified INT 7 routine using XFS-interface. Run the machine with two programs one printing even numbers and another printing odd numbers from 1 to 100 along with the idle process. According to eXpOS resource management system introduced here, will Deadlock occur? If yes, explain it with a situation. If no, which of the four conditions of Deadlock are not satisfied? Deadlock will not occur according to the resource management system implemented here. As hold and wait, circular wait conditions are not satisfied (there is only one resource - the terminal - now). Info See link for a set of neccessary conditions for deadlock. Assignment 1 Set a breakpoint (see SPL breakpoint instruction ) just before return from the Acquire Terminal and the Release Terminal functions in the Resource Manager module to dump the Terminal Status Table (see XSM debugger for various printing options).","title":"Making things work"},{"location":"roadmap/stage-16/","text":"Learning Objectives Familiarise with the Console Interrupt handling in XSM. Implementation of console input using the read system call. Introduction to input buffer. Pre-requisite Reading Read and understand the XSM tutorial on Interrupts and Exception handling before proceeding further. (Read only the console and disk interrupt part.) In this stage, we will introduce you to XSM console interrupt handling. A process must use the XSM instruction IN to read data from the console into the input port P0 . IN is a privileged instruction and can be executed only inside a system call/module. Hence, to read data from the console, a user process invokes the read system call . The read system call invokes the Terminal Read function present in Device Manager module (Module 4). The IN instruction will be executed within this Terminal Read function. The most important fact about the IN instruction is that it will not wait for the data to arrive in P0 . Instead, the XSM machine continues advancing the instruction pointer and executing the next instruction. Hence there must be some hardware mechanism provided by XSM to detect arrival of data in P0. When does data arrive in P0? This happens when some string/number is entered from the key-board and ENTER is pressed. At this time, the XSM machine will raise the console interrupt . Thus the console interrupt is the hardware mechanism that helps the OS to infer that the execution of the IN instruction is complete. As noted above, the IN instruction is typically executed from the Terminal Read function. Since it is not useful for the process that invoked the Terminal Read function to continue execution till data arrives in P0, a process executing the IN instruction will sets its state to WAIT_TERMINAL and invoke the scheduler . The process must resume execution only after the XSM machine sends an interrupt upon data arrival. When the console interrupt occurs, the machine interrupts the current process (note that some other process would be running) and executes the console interrupt handler. (The interrupt mechanism is similar to the timer interrupt. The current value of IP+2 is pushed into the stack and control transfers to the interrupt handler - see XSM machine execution tutorial for details).It is the responsiblity of the console interrupt handler to transfer the data arrived in port P0 to the process which is waiting for the data . This is done by copying the value present in port P0 into the input buffer field of the process table entry of the process which has requested for the input. Console interrupt handler also wakes up the process in WAIT_TERMINAL by setting its state to READY . (Other processes in WAIT_TERMINAL state are also set to READY by the console interrupt handler.) Each process maintains an input buffer which stores the last data read by the process from the console. On the occurance of a terminal interrupt, the interrupt handler uses the PID field of the terminal status table to identify the correct process that had acquired the terminal for a read operation. The handler transfer the data from the input port to the input buffer of the process. User programs can invoke the read system call using the library interface. For a terminal read, the file descriptor (-1 for terminal input) is passed as the first argument. The second argument is a variable to store number/string from console. Refer to the read system call calling convention here .ExpL library converts exposcall to low level system call interface for read system call, to invoke interrupt 6. The read system call (Interrupt 6) invokes the Terminal Read function present in the Device manager Module . Reading from the terminal and storing the number/string (read from console) in the address provided is done by the Terminal Read function. Function number for the Terminal Read function, current PID and address where the word has to be stored are sent as arguments through registers R1, R2 and R3 respectively. After coming back from Terminal Read function, it is expected that the word address (passed as argument to read system call) contains the number/string entered in the terminal. The OS maintains a global data structure called the terminal status table that stores information about the current state of the terminal. A process can acquire the terminal by invoking the Acquire Terminal function of the resource manager module . When the Acquire Terminal function assigns the terminal to a process, it enters the PID of the process into the PID field of the terminal status table . The Terminal Read function must perform the following 1) Acquire the terminal 2) Issue an IN instruction (SPL read statement translates to XSM instruction IN) 3) Set its state as WAIT_TERMINAL 4) Invoke the scheduler and 5) After console interrupt wakes up this process, transfer data present in the input buffer field of the process table into the word address (passed as an argument). Read about XSM interrupts before proceeding further. Control flow for Read system call Implementation of read system call (interrupt 6 routine) \u00b6 1) Set the MODE FLAG in the process table of the current process to the system call number which is 7 for read system call. 2) Save the value of register SP as userSP. alias userSP R0; userSP=SP; 3) Store the value of register SP in the UPTR field of the process table entry of the current process. 4) Initialize SP (kernel stack pointer) to (user area page number)*512 -1. 5) Retrieve the file descriptor from the user stack, stored at userSP-4. 6) If the file descriptor is not -1 Store -1 as the return value in the user stack (at position userSP-1). 7) If the file descriptor is -1, implement below steps. Retrieve the word address sent as an argument from the user stack (userSP-3). Push all the registers used till now in this interrupt. Save the function number of the Terminal Read function in the register R1. Save PID of the current process and the word address obtained above in registers R2 and R3 respectively. Call device manager module. (There is no return value for terminal Read.) Restore the registers. Store 0 as return value in the user stack indicating success. 8) Reset the MODE FLAG in the process table to 0. 9) Change SP back to user stack and return to the user mode. Modification to Device manager Module \u00b6 In previous stage we implemented Terminal Write function in module 4, now we will add Terminal Read function. 1) If function number in R1 corresponds to Terminal Read, then implement below steps. Calling Acquire Terminal function :- 2) Push all the registers used till now using multipush. 3) Initialize registers R1, R2 with function number of Acquire Terminal and PID of current process respectively. 4) Call resource manager module. 5) Restore the registers using the multipop statement. 6) Use read statement, for requesting to read from the terminal. read; 7) Change the state of the current process to WAIT_TERMINAL. Invoking the Context Switch Module :- 8) Push all the registers used till now. 9) Invoke the scheduler. Following steps are executed after return from the scheduler 10) Restore the registers using the multipop statement. 11) The logical address of the word where the data has to be stored is in R3. Convert this logical address to physical address. 12) Store the value present in input buffer field of process table to the obtained physical address of the word. 13) Return to the caller. Implementation of Console Interrupt Handler \u00b6 > The console interrupt handler is entered while some other process is executing in the user mode. The handler must switch to the kernel stack of that process, do the interrupt handling, restore the user stack of the process that was running and return control back to the process 1) Store the SP value in the UPTR field in the process table entry of the currently running process. 2) Initialize SP (kernel stack pointer) to (user area page number)*512 -1. //Switch to the kernel stack. 3) Backup the user context of the currently running process in the kernel stack as done in timer interrupt routine. 4) Get the PID of the process that has aqcuired the terminal from the terminal status table , Save this as reqPID. 5) Using the reqPID obtained in the above step, get the corresponding process table entry. 6) The input entered in the console is saved in port P0 by the XSM machine. Copy the value present in P0 into the input buffer field of the process table entry obtained in the above step. / next release the terminal / 7) Push the registers used in this interrupt. 8) Initialize register R1 with function number for release terminal, R2 with reqPID (The current process did not acquire the terminal. The process with reqPID as PID is holding the terminal.) 9) Call resource manager module. 10) Ignore the return value and restore the registers pushed before. 11) Restore the user context from the kernel stack as done in the timer interrupt routine. 12) Change SP to UPTR field from the process table entry of the currently running process and return to the user mode. //Switch back to us er stack Modification to Boot Module \u00b6 Load console interrupt handler and interrupt 6 from disk to memory. Remove the initialization of the third process, as we will run only idle and init processes in this stage. Making things work \u00b6 Compile and load boot module code, console interrupt and interrupt 6 using XFS interface. Write an ExpL program which reads two numbers from console and finds the GCD using Euclidean's algorithm and print the GCD. Load this program as init program. Q1. Is it possible that, the running process interrupted by the console interrupt be the same process that had acquired the terminal for reading? No, The process which has acquired the terminal will be in WAIT_TERMINAL state after issuing a terminal read until the console interrupt occurs. Hence, this process will not be scheduled until console interrupt changes it's state to READY. Assignment 1 Write an ExpL program to read N numbers in an array, sort using bubble sort and print the sorted array to the terminal. Load this program as init program and run the machine. Assignment 2 Use the XSM debugger to print out the contents of the Terminal Status Table and the input buffer (by dumping process table entry of the process to which read was performed) before and after reading data from the input port to the input buffer of the process, inside the terminal interrupt handler.","title":"Stage 16"},{"location":"roadmap/stage-16/#implementation-of-read-system-call-interrupt-6-routine","text":"1) Set the MODE FLAG in the process table of the current process to the system call number which is 7 for read system call. 2) Save the value of register SP as userSP. alias userSP R0; userSP=SP; 3) Store the value of register SP in the UPTR field of the process table entry of the current process. 4) Initialize SP (kernel stack pointer) to (user area page number)*512 -1. 5) Retrieve the file descriptor from the user stack, stored at userSP-4. 6) If the file descriptor is not -1 Store -1 as the return value in the user stack (at position userSP-1). 7) If the file descriptor is -1, implement below steps. Retrieve the word address sent as an argument from the user stack (userSP-3). Push all the registers used till now in this interrupt. Save the function number of the Terminal Read function in the register R1. Save PID of the current process and the word address obtained above in registers R2 and R3 respectively. Call device manager module. (There is no return value for terminal Read.) Restore the registers. Store 0 as return value in the user stack indicating success. 8) Reset the MODE FLAG in the process table to 0. 9) Change SP back to user stack and return to the user mode.","title":"Implementation of read system call (interrupt 6 routine)"},{"location":"roadmap/stage-16/#modification-to-device-manager-module","text":"In previous stage we implemented Terminal Write function in module 4, now we will add Terminal Read function. 1) If function number in R1 corresponds to Terminal Read, then implement below steps. Calling Acquire Terminal function :- 2) Push all the registers used till now using multipush. 3) Initialize registers R1, R2 with function number of Acquire Terminal and PID of current process respectively. 4) Call resource manager module. 5) Restore the registers using the multipop statement. 6) Use read statement, for requesting to read from the terminal. read; 7) Change the state of the current process to WAIT_TERMINAL. Invoking the Context Switch Module :- 8) Push all the registers used till now. 9) Invoke the scheduler. Following steps are executed after return from the scheduler 10) Restore the registers using the multipop statement. 11) The logical address of the word where the data has to be stored is in R3. Convert this logical address to physical address. 12) Store the value present in input buffer field of process table to the obtained physical address of the word. 13) Return to the caller.","title":"Modification to Device manager Module"},{"location":"roadmap/stage-16/#implementation-of-console-interrupt-handler","text":"> The console interrupt handler is entered while some other process is executing in the user mode. The handler must switch to the kernel stack of that process, do the interrupt handling, restore the user stack of the process that was running and return control back to the process 1) Store the SP value in the UPTR field in the process table entry of the currently running process. 2) Initialize SP (kernel stack pointer) to (user area page number)*512 -1. //Switch to the kernel stack. 3) Backup the user context of the currently running process in the kernel stack as done in timer interrupt routine. 4) Get the PID of the process that has aqcuired the terminal from the terminal status table , Save this as reqPID. 5) Using the reqPID obtained in the above step, get the corresponding process table entry. 6) The input entered in the console is saved in port P0 by the XSM machine. Copy the value present in P0 into the input buffer field of the process table entry obtained in the above step. / next release the terminal / 7) Push the registers used in this interrupt. 8) Initialize register R1 with function number for release terminal, R2 with reqPID (The current process did not acquire the terminal. The process with reqPID as PID is holding the terminal.) 9) Call resource manager module. 10) Ignore the return value and restore the registers pushed before. 11) Restore the user context from the kernel stack as done in the timer interrupt routine. 12) Change SP to UPTR field from the process table entry of the currently running process and return to the user mode. //Switch back to us er stack","title":"Implementation of Console Interrupt Handler"},{"location":"roadmap/stage-16/#modification-to-boot-module","text":"Load console interrupt handler and interrupt 6 from disk to memory. Remove the initialization of the third process, as we will run only idle and init processes in this stage.","title":"Modification to Boot Module"},{"location":"roadmap/stage-16/#making-things-work","text":"Compile and load boot module code, console interrupt and interrupt 6 using XFS interface. Write an ExpL program which reads two numbers from console and finds the GCD using Euclidean's algorithm and print the GCD. Load this program as init program. Q1. Is it possible that, the running process interrupted by the console interrupt be the same process that had acquired the terminal for reading? No, The process which has acquired the terminal will be in WAIT_TERMINAL state after issuing a terminal read until the console interrupt occurs. Hence, this process will not be scheduled until console interrupt changes it's state to READY. Assignment 1 Write an ExpL program to read N numbers in an array, sort using bubble sort and print the sorted array to the terminal. Load this program as init program and run the machine. Assignment 2 Use the XSM debugger to print out the contents of the Terminal Status Table and the input buffer (by dumping process table entry of the process to which read was performed) before and after reading data from the input port to the input buffer of the process, inside the terminal interrupt handler.","title":"Making things work"},{"location":"roadmap/stage-17/","text":"Learning Objectives Familiarize with Process manager and Memory Manager modules. Enable the OS to load and execute application programs from the disk (exec system call). Pre-requisite Reading Before proceeding futher review the XEXE file format and the address space model of a process from the eXpOS ABI documentation . Make sure to be thorough with the SPL module calling conventions. In this stage, you will be working on the implementation of the exec system call. Exec is the \"program loader\" of eXpOS. Exec takes as input a filename. It first checks whether the file is a valid eXpOS executable stored in the XSM disk, adhering to the XEXE format . If so, Exec destroys the invoking process, loads the executable file from the disk, and sets up the program for execution as a process. A successful exec operation results in the termination of the invoking process and hence never returns to it. Name of the executable file is the only input to the exec system call. This file should be present in the disk before starting the machine. The inode index of this file can be obtained by going through the memory copy of the inode table . Note From here onwards whenever the inode table is referred, it is implied that memory copy of the inode table is referred (unless mentioned otherwise). Inode table is loaded from the disk to the memory in Boot Module. Exec first deallocates all pages the invoking process is using. These include two heap pages, two user stack pages, code pages occupied by the process and the user area page. It also invalidates the entries of the page table of the invoking process. Note that the newly scheduled process will have the same PID as that of the invoking process. Hence the same process table entry and page table of the invoking process will be used by the newly loaded process. Exec calls the Exit Process function in the process manager module (module 1) to deallocate the pages and to terminate the current process. As mentioned earlier, Exit Process function releases the user area page of the current process. Since Exec system call runs in kernel mode and needs a kernel stack for its own execution, after coming back from Exit process function, exec reclaims the same user area page for the new process. Further, exec acquires two heap, two stack and the required number of code pages (number of disk blocks in the inode entry of the file in the inode table) for the new process. New pages will be acquired by invoking the Get Free Page function present in the memory manager module (module 2). Page table is updated according to the new pages acquired. Code blocks for the new process are loaded from the disk to the memory pages obtained. For loading blocks into the memory pages, we use immediate load ( loadi statement in SPL). Finally, exec initializes the IP value of new process on top of its user stack and initiates execution of the newly loaded process in the user mode. eXpOS maintains a data structure called memory free list in page 57 of the memory . Each Page can be shared by zero or more processes. There are 128 entries in the memory free list corresponding to each page of memory. For each page, the corresponding entry in the list stores the number of processes sharing the page. The constant MEMORY_FREE_LIST gives the starting address of the memory free list. Now we will understand the working of the module functions that exec uses during its execution. Before proceeding further have a careful look of the diagram to understand the overall working of the exec system call. 1. Exit Process (function number = 3, process manager module ) \u00b6 The first function invoked in the exec system call is the Exit Process function. Exit Process function takes PID of a process as an argument (In this stage, PID of the current process is passed). Exit process deallocates all the pages of the invoked process. It deallocates the pages present in the page table by invoking another function called Free Page Table present in the same module. Further, The Exit Process deallocates the user area page by invoking Free User Area Page in the same module. The state of the process (corresponding to the given PID) is set to TERMINATED. This is not the final Exit process function. There will be minor modifications to this function in the later stages. 2. Free Page Table (function number = 4, process manager module ) \u00b6 The Free Page Table function takes PID of a process as an argument (In this stage, PID of the current process is passed). In the function Free Page Table , for every valid entry in the page table of the process, the corresponding page is freed by invoking the Release Page function present in the memory manager module . Since the library pages are shared by all the processes, do not invoke the Release Page function for the library pages. Free Page Table function invalidates all the page table entries of the process with given PID. The part of the Free Page Table function involving updates to the Disk Map Table will be taken care in subsequent stages. 3. Free User Area Page (function number = 2, process manager module ) \u00b6 The function Free User Area Page takes PID of a process (In this stage, PID of the current process is passed) as an argument. The user area page number of the process is obtained from the process table entry corresponding to the PID. This user area page is freed by invoking the Release Page function from the memory manager module. However, since we are using Free User Area Page to release the user area page of the current process one needs to be careful here. The user area page holds the kernel stack of the current process. Hence, releasing this page means that the page holding the return address for the call to Free User Area Page function itself has been released! Neverthless the return address and the saved context of the calling process will not be lost. This is because Release Page function is non blocking and hence the page will never be allocated to another process before control transfers back to the caller. (Free User Area Page function also releases the resourses like files and semaphores acquired by the process. We will look into it in later stages.) 4. Release Page (function number = 2, memory manager module ) \u00b6 The Release Page function takes the page number to be released as an argument. The Release Page function decrements the value in the memory free list corresponding to the page number given as an argument. Note that we don't tamper with the content of the page as the page may be shared by other processes. The system status table keeps track of number of free memory pages available to use in the MEM_FREE_COUNT field. When the memory free list entry of the page becomes zero, no process is currently using the page. In this case, increment the value of MEM_FREE_COUNT in the system status table indicating that the page has become free for fresh allocation. Finally, Release page function must check whether there are processes in WAIT_MEM state (these are processes blocked, waiting for memory to become available). If so, these processes have to be set to READY state as memory has become available now. At present, the OS does not set any process to WAIT_MEM state and this check is superfluous. However, in later stages, the OS will set processes to WAIT_MEM state when memory is temporarily unavailable, and hence when memory is released by some process, the waiting processes have to be set to READY state. 5. Get Free Page (function number = 1, memory manager module ) \u00b6 To acquire the pages for the new process, exec calls the module function Get Free Page. The function returns the page number of the page allocated. Fundamentally, Get Free page searches through the memory free list to find a free page for the allocation. If a free page is found, memory free list entry corresponding to that page is incremented and number of the page found is returned. If no memory page is free (MEM_FREE_COUNT in the system status table is 0), then state of the process is changed to WAIT_MEM and the scheduler is invoked. This process is scheduled again, when the memory is available (state of this process is changed to READY by some other process). The field WAIT_MEM_COUNT in the system status table stores the number of processes waiting to acquire a memory page. The Get Free Page function increments the WAIT_MEM_COUNT before changing state to WAIT_MEM. The process waits in the WAIT_MEM state until any memory page is available for use. Upon waking up, the Get Free Page function allocates the free memory page and updates the WAIT_MEM_COUNT and MEM_FREE_COUNT in the system status table. Control flow for Exec system call Implementation of Exec system call \u00b6 Exec has system call number as 9 and it is implemented in interrupt routine 9. Follow steps below to implement interrupt routine 9. Save user stack value for later use, set up the kernel stack.(see kernel stack management during system calls .) Set the MODE FLAG in the process table to system call number of exec. Get the argument (name of the file) from user stack. Search the memory copy of the inode table for the file, If the file is not present or file is not in XEXE format return to user mode with return value -1 indicating failure (after setting up MODE FLAG and the user stack). If the file is present, save the inode index of the file into a register for future use. Call the Exit Process function in process manager module to deallocate the resources and pages of the current process. Get the user area page number from the process table of the current process. This page has been deallocated by the Exit Process function. Reclaim the same page by incrementing the memory free list entry of user area page and decrementing the MEM_FREE_COUNT field in the system status table . (same user area page is reclaimed - why?) Set the SP to the start of the user area page to intialize the kernel stack of the new process. New process uses the PID of the terminated process. Update the STATE field to RUNNING and store inode index obtained above in the inode index field in the process table. Allocate new pages and set the page table entries for the new process. Set the library page entries in the page table. (must be set to read only-why? Note that library page need not be allocated.) Invoke the Get Free Page function to allocate 2 stack and 2 heap pages. Also validate the corresponding entries in page table. Find out the number of blocks occupied by the file from inode table . Allocate same number of code pages by invoking the GetFree Page function and update the page table entries. Load the code blocks from the disk to the memory pages using loadi statement .(We will change this step in the next stage.) Store the entry point IP (present in the header of first code page) value on top of the user stack. Change SP to user stack, change the MODE FLAG back to user mode and return to user mode. Note The implementation of some of the module functions given below are primitive versions of their final versions. The present versions are just sufficient for the purposes of this stage. These functions may require modifications in later stages. The required modifications will be explained at appropriate points in the roadmap. Implementation of Process Manager Module (Module 1) \u00b6 According to the function number value present in R1, implement different functions in module 1. If the function number corresponds to Free User Area Page , follow steps below Obtain the user area page number from the process table entry corresponding to the PID given as an argument. Free the user area page by invoking the Release Page function. Return to the caller. If the function number corresponds to Exit Process , follow steps below Extract PID of the invoking process from the corresponding register. Invoke the Free Page Table function with same PID to deallocate the page table entries. Invoke the Free user Area Page function with the same PID to free the user area page. Set the state of the process as TERMINATED and return to the caller. If the function number corresponds to Free Page Table , follow steps below Invalidate the page table entries for the library pages by setting page number as -1 and auxiliary data as \"0000\" for each entry. For each valid entry in the page table, release the page by invoking the Release Page function and invalidate the entry. Return to the Caller. Note The implementation of above three functions of process manager module are not final versions. They will be updated as required in later stages. Implementation of Memory Manager Module (Module 2) \u00b6 According to the function number value present in R1, implement different functions in module 2. If the function number corresponds to Get Free Page , follow steps below Increment WAIT_MEM_COUNT field in the system status table. //Do not increment the WAIT_MEM_COUNT in busy loop (an important step ) While memory is full (MEM_FREE_COUNT will be 0), do following. Set the state of the invoked process as WAIT_MEM. Schedule other process by invoking the context switch module . // blocking the process Decrement the WAIT_MEM_COUNT field and MEM_FREE_COUNT field in the system status table. Note the sequence - increment WAIT_MEM_COUNT, waiting for the memory, decrement WAIT_MEM_COUNT. Find a free page using memory free list and set the corresponding entry as 1. Make sure to store the obtained free page number in R0 as return value. Return to the caller. If the function number corresponds to Release Page , follow steps below The Page number to be released is present in R2. Decrement the corresponding entry in the memory free list. If that entry in the memory free list becomes zero, then the page is free. So increment the MEM_FREE_COUNT in the system status table. Update the STATUS to READY for all processes (with valid PID) which have STATUS as WAIT_MEM. Return to the caller. Note The Get Free Page and Release Page functions implemented above are final versions according to the algorithm given in memory manager module . Modifications to the Boot Module. \u00b6 Load interrupt routine 9, module 1, module 2 and inode table from the disk to the memory. Refer to disk and memory organization here . Initialize the memory free list with value 1 for pages used and 0 for free pages. Initialize the fields WAIT_MEM_COUNT to 0 and MEM_FREE_COUNT to number of free pages in the system status table. ExpOS memory layout for the XSM machine sets pages 76-127 as free pages and the remaining are reserved for OS modules, OS data structures, interrupts, system calls, code region of special processes (INIT, shell), the OS library etc. Hence, the initial setting of the memory free list should mark pages 76-127 as free (value 0) and the rest as allocated (value 1). The memory manager shall be doing allocation and deallocation only from the free pool (76-127). The boot module/OS startup code further allocates space for the user-area page and stack pages for INIT and IDLE processes from this free pool. The INIT process require two additional pages for the heap. The pages allocated to INIT process are- stack-76, 77, heap-78, 79, user area page-80 and for IDLE process- stack-81, user area page-82. Hence, the effective free pool (MEM_FREE_COUNT value) at the end of OS initialization process starts from memory page 83. Making things work \u00b6 Compile and load interrupt routine 9, module 1 and module 2 using XFS-interface. Run the machine. Q1 Why does exec reclaim the same user area page for the new process? (As done in step 7 of exec system call implementation.) Since the page storing the kernel context has been de-allocated, before making any function call, a stack page has to be allocated to store parameters, return address etc. It is unsafe to invoke the Get Free Page function of the memory manager module before allocating a stack page (why?). Q2 Why should the OS set the WRITE PERMISSION BIT for library and code pages in each page table entry to 0, denying permission for the process to write to these pages? ExpOS does not expect processess to modify the code page during execution. Hence, during a fork() system call (to be seen in later stages), the code pages are shared between several processes. Similarly, the library pages are shared by all processes. If a process is allowed to write into a code/library page, the shared program/library will get modified and will alter the execution behaviour of other processes, which violates the basic virtual address space model offered by the OS. Assignment 1 : Shell version-1 Write an ExpL program to read the name of program from the console and execute that program using exec system call. Load this program as INIT program and run the odd.expl (printing odd numbers between 1-100) program using the shell. Assignment 2 Use the XSM debugger to print out the contents of the System Status Table and the Memory Free List after Get Free Page and Release Page functions, inside the Memory Manager module.","title":"Stage 17"},{"location":"roadmap/stage-17/#1-exit-process-function-number-3process-manager-module","text":"The first function invoked in the exec system call is the Exit Process function. Exit Process function takes PID of a process as an argument (In this stage, PID of the current process is passed). Exit process deallocates all the pages of the invoked process. It deallocates the pages present in the page table by invoking another function called Free Page Table present in the same module. Further, The Exit Process deallocates the user area page by invoking Free User Area Page in the same module. The state of the process (corresponding to the given PID) is set to TERMINATED. This is not the final Exit process function. There will be minor modifications to this function in the later stages.","title":"1. Exit Process (function number = 3,process manager module)"},{"location":"roadmap/stage-17/#2-free-page-table-function-number-4-process-manager-module","text":"The Free Page Table function takes PID of a process as an argument (In this stage, PID of the current process is passed). In the function Free Page Table , for every valid entry in the page table of the process, the corresponding page is freed by invoking the Release Page function present in the memory manager module . Since the library pages are shared by all the processes, do not invoke the Release Page function for the library pages. Free Page Table function invalidates all the page table entries of the process with given PID. The part of the Free Page Table function involving updates to the Disk Map Table will be taken care in subsequent stages.","title":"2. Free Page Table (function number = 4, process manager module)"},{"location":"roadmap/stage-17/#3-free-user-area-page-function-number-2process-manager-module","text":"The function Free User Area Page takes PID of a process (In this stage, PID of the current process is passed) as an argument. The user area page number of the process is obtained from the process table entry corresponding to the PID. This user area page is freed by invoking the Release Page function from the memory manager module. However, since we are using Free User Area Page to release the user area page of the current process one needs to be careful here. The user area page holds the kernel stack of the current process. Hence, releasing this page means that the page holding the return address for the call to Free User Area Page function itself has been released! Neverthless the return address and the saved context of the calling process will not be lost. This is because Release Page function is non blocking and hence the page will never be allocated to another process before control transfers back to the caller. (Free User Area Page function also releases the resourses like files and semaphores acquired by the process. We will look into it in later stages.)","title":"3. Free User Area Page (function number = 2,process manager module)"},{"location":"roadmap/stage-17/#4-release-page-function-number-2memory-manager-module","text":"The Release Page function takes the page number to be released as an argument. The Release Page function decrements the value in the memory free list corresponding to the page number given as an argument. Note that we don't tamper with the content of the page as the page may be shared by other processes. The system status table keeps track of number of free memory pages available to use in the MEM_FREE_COUNT field. When the memory free list entry of the page becomes zero, no process is currently using the page. In this case, increment the value of MEM_FREE_COUNT in the system status table indicating that the page has become free for fresh allocation. Finally, Release page function must check whether there are processes in WAIT_MEM state (these are processes blocked, waiting for memory to become available). If so, these processes have to be set to READY state as memory has become available now. At present, the OS does not set any process to WAIT_MEM state and this check is superfluous. However, in later stages, the OS will set processes to WAIT_MEM state when memory is temporarily unavailable, and hence when memory is released by some process, the waiting processes have to be set to READY state.","title":"4. Release Page (function number = 2,memory manager module)"},{"location":"roadmap/stage-17/#5-get-free-page-function-number-1memory-manager-module","text":"To acquire the pages for the new process, exec calls the module function Get Free Page. The function returns the page number of the page allocated. Fundamentally, Get Free page searches through the memory free list to find a free page for the allocation. If a free page is found, memory free list entry corresponding to that page is incremented and number of the page found is returned. If no memory page is free (MEM_FREE_COUNT in the system status table is 0), then state of the process is changed to WAIT_MEM and the scheduler is invoked. This process is scheduled again, when the memory is available (state of this process is changed to READY by some other process). The field WAIT_MEM_COUNT in the system status table stores the number of processes waiting to acquire a memory page. The Get Free Page function increments the WAIT_MEM_COUNT before changing state to WAIT_MEM. The process waits in the WAIT_MEM state until any memory page is available for use. Upon waking up, the Get Free Page function allocates the free memory page and updates the WAIT_MEM_COUNT and MEM_FREE_COUNT in the system status table. Control flow for Exec system call","title":"5. Get Free Page (function number = 1,memory manager module)"},{"location":"roadmap/stage-17/#implementation-of-exec-system-call","text":"Exec has system call number as 9 and it is implemented in interrupt routine 9. Follow steps below to implement interrupt routine 9. Save user stack value for later use, set up the kernel stack.(see kernel stack management during system calls .) Set the MODE FLAG in the process table to system call number of exec. Get the argument (name of the file) from user stack. Search the memory copy of the inode table for the file, If the file is not present or file is not in XEXE format return to user mode with return value -1 indicating failure (after setting up MODE FLAG and the user stack). If the file is present, save the inode index of the file into a register for future use. Call the Exit Process function in process manager module to deallocate the resources and pages of the current process. Get the user area page number from the process table of the current process. This page has been deallocated by the Exit Process function. Reclaim the same page by incrementing the memory free list entry of user area page and decrementing the MEM_FREE_COUNT field in the system status table . (same user area page is reclaimed - why?) Set the SP to the start of the user area page to intialize the kernel stack of the new process. New process uses the PID of the terminated process. Update the STATE field to RUNNING and store inode index obtained above in the inode index field in the process table. Allocate new pages and set the page table entries for the new process. Set the library page entries in the page table. (must be set to read only-why? Note that library page need not be allocated.) Invoke the Get Free Page function to allocate 2 stack and 2 heap pages. Also validate the corresponding entries in page table. Find out the number of blocks occupied by the file from inode table . Allocate same number of code pages by invoking the GetFree Page function and update the page table entries. Load the code blocks from the disk to the memory pages using loadi statement .(We will change this step in the next stage.) Store the entry point IP (present in the header of first code page) value on top of the user stack. Change SP to user stack, change the MODE FLAG back to user mode and return to user mode. Note The implementation of some of the module functions given below are primitive versions of their final versions. The present versions are just sufficient for the purposes of this stage. These functions may require modifications in later stages. The required modifications will be explained at appropriate points in the roadmap.","title":"Implementation of Exec system call"},{"location":"roadmap/stage-17/#implementation-of-process-manager-module-module-1","text":"According to the function number value present in R1, implement different functions in module 1. If the function number corresponds to Free User Area Page , follow steps below Obtain the user area page number from the process table entry corresponding to the PID given as an argument. Free the user area page by invoking the Release Page function. Return to the caller. If the function number corresponds to Exit Process , follow steps below Extract PID of the invoking process from the corresponding register. Invoke the Free Page Table function with same PID to deallocate the page table entries. Invoke the Free user Area Page function with the same PID to free the user area page. Set the state of the process as TERMINATED and return to the caller. If the function number corresponds to Free Page Table , follow steps below Invalidate the page table entries for the library pages by setting page number as -1 and auxiliary data as \"0000\" for each entry. For each valid entry in the page table, release the page by invoking the Release Page function and invalidate the entry. Return to the Caller. Note The implementation of above three functions of process manager module are not final versions. They will be updated as required in later stages.","title":"Implementation of Process Manager Module (Module 1)"},{"location":"roadmap/stage-17/#implementation-of-memory-manager-module-module-2","text":"According to the function number value present in R1, implement different functions in module 2. If the function number corresponds to Get Free Page , follow steps below Increment WAIT_MEM_COUNT field in the system status table. //Do not increment the WAIT_MEM_COUNT in busy loop (an important step ) While memory is full (MEM_FREE_COUNT will be 0), do following. Set the state of the invoked process as WAIT_MEM. Schedule other process by invoking the context switch module . // blocking the process Decrement the WAIT_MEM_COUNT field and MEM_FREE_COUNT field in the system status table. Note the sequence - increment WAIT_MEM_COUNT, waiting for the memory, decrement WAIT_MEM_COUNT. Find a free page using memory free list and set the corresponding entry as 1. Make sure to store the obtained free page number in R0 as return value. Return to the caller. If the function number corresponds to Release Page , follow steps below The Page number to be released is present in R2. Decrement the corresponding entry in the memory free list. If that entry in the memory free list becomes zero, then the page is free. So increment the MEM_FREE_COUNT in the system status table. Update the STATUS to READY for all processes (with valid PID) which have STATUS as WAIT_MEM. Return to the caller. Note The Get Free Page and Release Page functions implemented above are final versions according to the algorithm given in memory manager module .","title":"Implementation of Memory Manager Module (Module 2)"},{"location":"roadmap/stage-17/#modifications-to-the-boot-module","text":"Load interrupt routine 9, module 1, module 2 and inode table from the disk to the memory. Refer to disk and memory organization here . Initialize the memory free list with value 1 for pages used and 0 for free pages. Initialize the fields WAIT_MEM_COUNT to 0 and MEM_FREE_COUNT to number of free pages in the system status table. ExpOS memory layout for the XSM machine sets pages 76-127 as free pages and the remaining are reserved for OS modules, OS data structures, interrupts, system calls, code region of special processes (INIT, shell), the OS library etc. Hence, the initial setting of the memory free list should mark pages 76-127 as free (value 0) and the rest as allocated (value 1). The memory manager shall be doing allocation and deallocation only from the free pool (76-127). The boot module/OS startup code further allocates space for the user-area page and stack pages for INIT and IDLE processes from this free pool. The INIT process require two additional pages for the heap. The pages allocated to INIT process are- stack-76, 77, heap-78, 79, user area page-80 and for IDLE process- stack-81, user area page-82. Hence, the effective free pool (MEM_FREE_COUNT value) at the end of OS initialization process starts from memory page 83.","title":"Modifications to the Boot Module."},{"location":"roadmap/stage-17/#making-things-work","text":"Compile and load interrupt routine 9, module 1 and module 2 using XFS-interface. Run the machine. Q1 Why does exec reclaim the same user area page for the new process? (As done in step 7 of exec system call implementation.) Since the page storing the kernel context has been de-allocated, before making any function call, a stack page has to be allocated to store parameters, return address etc. It is unsafe to invoke the Get Free Page function of the memory manager module before allocating a stack page (why?). Q2 Why should the OS set the WRITE PERMISSION BIT for library and code pages in each page table entry to 0, denying permission for the process to write to these pages? ExpOS does not expect processess to modify the code page during execution. Hence, during a fork() system call (to be seen in later stages), the code pages are shared between several processes. Similarly, the library pages are shared by all processes. If a process is allowed to write into a code/library page, the shared program/library will get modified and will alter the execution behaviour of other processes, which violates the basic virtual address space model offered by the OS. Assignment 1 : Shell version-1 Write an ExpL program to read the name of program from the console and execute that program using exec system call. Load this program as INIT program and run the odd.expl (printing odd numbers between 1-100) program using the shell. Assignment 2 Use the XSM debugger to print out the contents of the System Status Table and the Memory Free List after Get Free Page and Release Page functions, inside the Memory Manager module.","title":"Making things work"},{"location":"roadmap/stage-18/","text":"Learning Objectives Familiarize with disk interrupt handling in XSM. Modify the Exec system call to handle disk interrupt. Pre-requisite Reading Read and understand the XSM tutorial on Interrupts and Exception handling before proceeding further. Revise the console and disk interrupt part. In this stage, we will introduce disk interrupt handling in XSM. In the previous stage, we used the loadi statement to load a disk block into a memory page. When the loadi statement (immediate load) is used for loading, the machine will execute the next instruction only after the block transfer is complete by the disk controller . A process can use the load statement instead of loadi to load a disk block to a memory page. The load statement in SPL translates to LOAD instruction in XSM . The LOAD instruction takes two arguments, a page number and a block number. The LOAD instruction initiates the transfer of data from the specified disk block to the memory page. The XSM machine doesn't wait for the block transfer to complete , it continues with the execution of the next instruction. Instead, the XSM machine provides a hardware mechanism to detect the completion of data transfer. XSM machine raises the disk interrupt when the disk operation is complete. In real operating systems, the OS maintains a software module called the disk device driver module for handling disk access. This module is responsible for programming the disk controller hardware for handling disk operations. When the OS initiates a disk read/write operation from the context of a process, the device driver module is invoked with appropriate arguments. In our present context, the device manager module integrates a common \"driver software\" for all devices of XSM. The load and store instructions actually are high level \"macro operations\" given to you that abstract away the low level details of the device specific code to program the disk controller hardware. The loadi instruction abstracts disk I/O using the method of polling whereas the load instruction abstracts interrupt based disk I/O. To initiate the disk transfer using the load statement, first the process has to acquire the disk. This ensures that no other process uses the disk while the process which has acquired the disk is loading the disk block to the memory page. eXpOS maintains a data structure called Disk Status Table to keep track of these disk-memory transfers. The disk status table stores the status of the disk indicating whether the disk is busy or free. The disk status table has a LOAD/STORE bit indicating whether the disk operation is a load or store. The table also stores the page number and the block number involved in the transfer. To keep track of the process that has currently acquired the disk, the PID of the process is also stored in the disk status table. The SPL constant DISK_STATUS_TABLE gives the starting address of the Disk Status Table in the XSM memory . After the current process has acquired the disk for loading, it initializes the Disk Status Table according to the operation to be perfromed (read/write). The process then issues the load statement to initiate the loading of the disk block to the memory page. As mentioned earlier, the XSM machine does not wait for the transfer to complete. It continues with the execution of the next instruction. However, virtually in any situation in eXpOS, the process has to wait till the data transfer is complete before proceeding (why?). Hence, the process suspends its execution by changing its state to WAIT_DISK and invokes the scheduler, allowing other concurrent processes to run. (At present, the only concurrent process for the OS to schedule is the IDLE process. However, in subsequent stages we will see that the OS will have more meaningful processes to run.) When the load/store transfer is complete, XSM machine raises the hardware interrupt called the disk interrupt . This interrupt mechanism is similar to the console interrupt. Note that when disk interrupt occurs, XSM machine stops the execution of the currently running process. The currently running process is not the one that has acquired the disk (why?). The disk interrupt handler releases the disk by changing the STATUS field in the Disk Status table to 0. It then wakes up all the processes waiting for the disk (by changing the STATE from WAIT_DISK to READY) which also includes the process which is waiting for the disk-transfer to complete. Then returns to the process which was interrupted by disk controller. XSM machine disables interrupts when executing in the kernel mode. Hence, the disk controller can raise an interrupt only when the machine is executing in the user mode. Hence the OS has to schedule \"some process\" even if all processess are waiting for disk/terminal interrupt - for otherwise, the device concerned will never be able to interrupt the processor. The IDLE process is precisely designed to take care of this and other similar situations. Control flow for Exec system call In this stage, you have to modify the exec system call by replacing the loadi statement by a call to the Disk Load function. The Disk Load function (in device manager module), the Acquire Disk function (in resource manager module) and the disk interrupt handler must also be implemented in this stage. Minor modifications are also required for the boot module. 1.Disk Load (function number = 2, device manager module ) \u00b6 The Disk Load function takes the PID of a process, a page number and a block number as input and performs the following tasks : Acquires the disk by invoking the Acquire Disk function in the resource manager module (module 0) Set the Disk Status table entries as mentioned in the algorithm (specified in the above link). Issue the load statement to initiate a disk block to memory page DMA transfer. Set the state of the process (with given PID) to WAIT_DISK and invoke the scheduler. 2.Acquire Disk (function number = 3, resource manager module ) \u00b6 The Acquire Disk function in the resource manager module takes the PID of a process as an argument. The Acquire disk function performs the following tasks : While the disk is busy (STATUS field in the Disk Status Table is 1), set the state of the process to WAIT_DISK and invoke the scheduler. When the disk is finally free, the process is woken up by the disk interrupt handler. Lock the disk by setting the STATUS and the PID fields in the Disk Status Table to 1 and PID of the process respectively. Note Both Disk Load and Acquire Disk module functions implemented above are final versions according to the algorithm given in respective modules. 3. Implementation of Disk Interrupt handler \u00b6 When the disk-memory transfer is complete, XSM raises the disk interrupt. The disk interrupt handler then performs the following tasks : Switch to the kernel stack and back up the register context. Set the STATUS field in the Disk Status table to 0 indicating that disk is no longer busy. Go through all the process table entries, and change the state of the process to READY, which is in WAIT_DISK state. Restore the register context and return to user mode using the ireturn statement. Note There is no Release Disk function to release the disk instead the disk interrupt handler completes the task of the Release Disk function. 4. Modification to exec system call (interrupt 9 routine) \u00b6 Instead of the loadi statement used to load the disk block to the memory page, invoke the Disk Load function present in the device manager module . We will initialize another data strucutre as well in this stage. This is the per-process resource table . (This step can be deferred to later stages, but since the work involved is simple, we will finish it here). The per-process resource table stores the information about the files and semaphores which a process is currently using. For each process, per-process resource table is stored in the user area page of the process. This table has 8 entries with 2 words each, in total it occupies 16 words. We will reserve the last 16 words of the User Area Page to store the per-process Resource Table of the process. In exec, after reacquiring the user area page for the new process, per-process resource table should be initialized in this user area page. Since the newly created process has not opened any files or semaphores, each entry in the per-process table is initialized to -1. 5. Modifications to boot module \u00b6 Following modifications are done in boot module : Load the disk interrupt routine from the disk to the memory. Initialize the STATUS field in the Disk Status Table to 0. Initialize the per-process resource table of init process. Compile and load the modified and newly written files into the disk using XFS-interface. Run the Shell version-I with any program to check for errors. Q1. Can we use the load statement in the boot module code instead of the loadi statement? Why? No. The modules needed for the execution of load, need to be present in the memory first. And even if they are present, at the time of execution of the boot module, no process or data structures are initialized (like Disk Status Table). Q2. Why does the disk interrupt handler has to backup the register context? Disk interrupt handler is a hardware interrupt. When disk interrupt occurs, the XSM machine just pushes IP+2 value on stack and transfers control to disk interrupt. Occurance of a hardware interrupt is unexpected. When the disk interrupt is raised, the process will not have control over it so the process (curently running) cannot backup the registers. That's why interrupt handler must back up the context of the process (currently running) before modifying the machine registers. The interrupt handler also needs to restore the context before returning to user mode. Q3. Why doesn't system calls backup the register context? The process currently running is in full control over calling the interrupt (software interrupt) corresponding to a system call. This allows a process to back up the registers used till that point (not all registers). Note that instead of process, the software interrupt can also back up the registers. But, the software interrupt will not know how many registers are used by the process so it has to back up all the registers. Backing up the registers by a process saves space and time. Q4. Does the XSM terminal input provide polling based input? Yes, readi statement provided in SPL gives polling based terminal I/O. But readi statement only works in debug mode. Write operation is always asynchronous. Assignment 1 Use the XSM debugger to print out the contents of the Disk Status Table after entry and before return from the disk interrupt handler.","title":"Stage 18"},{"location":"roadmap/stage-18/#1disk-load-function-number-2device-manager-module","text":"The Disk Load function takes the PID of a process, a page number and a block number as input and performs the following tasks : Acquires the disk by invoking the Acquire Disk function in the resource manager module (module 0) Set the Disk Status table entries as mentioned in the algorithm (specified in the above link). Issue the load statement to initiate a disk block to memory page DMA transfer. Set the state of the process (with given PID) to WAIT_DISK and invoke the scheduler.","title":"1.Disk Load (function number = 2,device manager module)"},{"location":"roadmap/stage-18/#2acquire-disk-function-number-3-resource-manager-module","text":"The Acquire Disk function in the resource manager module takes the PID of a process as an argument. The Acquire disk function performs the following tasks : While the disk is busy (STATUS field in the Disk Status Table is 1), set the state of the process to WAIT_DISK and invoke the scheduler. When the disk is finally free, the process is woken up by the disk interrupt handler. Lock the disk by setting the STATUS and the PID fields in the Disk Status Table to 1 and PID of the process respectively. Note Both Disk Load and Acquire Disk module functions implemented above are final versions according to the algorithm given in respective modules.","title":"2.Acquire Disk (function number = 3, resource manager module)"},{"location":"roadmap/stage-18/#3-implementation-of-disk-interrupt-handler","text":"When the disk-memory transfer is complete, XSM raises the disk interrupt. The disk interrupt handler then performs the following tasks : Switch to the kernel stack and back up the register context. Set the STATUS field in the Disk Status table to 0 indicating that disk is no longer busy. Go through all the process table entries, and change the state of the process to READY, which is in WAIT_DISK state. Restore the register context and return to user mode using the ireturn statement. Note There is no Release Disk function to release the disk instead the disk interrupt handler completes the task of the Release Disk function.","title":"3. Implementation of Disk Interrupt handler"},{"location":"roadmap/stage-18/#4-modification-to-exec-system-call-interrupt-9-routine","text":"Instead of the loadi statement used to load the disk block to the memory page, invoke the Disk Load function present in the device manager module . We will initialize another data strucutre as well in this stage. This is the per-process resource table . (This step can be deferred to later stages, but since the work involved is simple, we will finish it here). The per-process resource table stores the information about the files and semaphores which a process is currently using. For each process, per-process resource table is stored in the user area page of the process. This table has 8 entries with 2 words each, in total it occupies 16 words. We will reserve the last 16 words of the User Area Page to store the per-process Resource Table of the process. In exec, after reacquiring the user area page for the new process, per-process resource table should be initialized in this user area page. Since the newly created process has not opened any files or semaphores, each entry in the per-process table is initialized to -1.","title":"4. Modification to exec system call (interrupt 9 routine)"},{"location":"roadmap/stage-18/#5-modifications-to-boot-module","text":"Following modifications are done in boot module : Load the disk interrupt routine from the disk to the memory. Initialize the STATUS field in the Disk Status Table to 0. Initialize the per-process resource table of init process. Compile and load the modified and newly written files into the disk using XFS-interface. Run the Shell version-I with any program to check for errors. Q1. Can we use the load statement in the boot module code instead of the loadi statement? Why? No. The modules needed for the execution of load, need to be present in the memory first. And even if they are present, at the time of execution of the boot module, no process or data structures are initialized (like Disk Status Table). Q2. Why does the disk interrupt handler has to backup the register context? Disk interrupt handler is a hardware interrupt. When disk interrupt occurs, the XSM machine just pushes IP+2 value on stack and transfers control to disk interrupt. Occurance of a hardware interrupt is unexpected. When the disk interrupt is raised, the process will not have control over it so the process (curently running) cannot backup the registers. That's why interrupt handler must back up the context of the process (currently running) before modifying the machine registers. The interrupt handler also needs to restore the context before returning to user mode. Q3. Why doesn't system calls backup the register context? The process currently running is in full control over calling the interrupt (software interrupt) corresponding to a system call. This allows a process to back up the registers used till that point (not all registers). Note that instead of process, the software interrupt can also back up the registers. But, the software interrupt will not know how many registers are used by the process so it has to back up all the registers. Backing up the registers by a process saves space and time. Q4. Does the XSM terminal input provide polling based input? Yes, readi statement provided in SPL gives polling based terminal I/O. But readi statement only works in debug mode. Write operation is always asynchronous. Assignment 1 Use the XSM debugger to print out the contents of the Disk Status Table after entry and before return from the disk interrupt handler.","title":"5. Modifications to boot module"},{"location":"roadmap/stage-19/","text":"Learning Objectives Familiarize with page fault exception in XSM. Implementation of Exception handler. Modify the exec system call to load code pages of a process on demand . Pre-requisite Reading It is absolutely necessary to have clear understanding about Exception handling in XSM before proceeding further. This stage introduces you to exception handling in eXpOS. There are four events that result in generation of an exception in XSM. These events are a) illegal memory access, b) illegal instruction, c) arithmetic exception and d) page fault. When one of this events occur, the XSM machine raises an exception and control is transferred to the exception handler. The exception handler code used in previous stages contains only halt instruction which halts the system in the case of an exception. Clearly it is inappropriate to halt the system (all the processes are terminated) for exception occured in one process. In this stage, we implement the exception handler which takes appropriate action for each exception. The exception handler occupies page 2 and 3 in the memory and blocks 15 and 16 in the disk . See disk and memory organization here . There are 4 special registers in XSM which are used to obtain the cause of the exception and the information related to the exception. These registers are EC, EIP, EPN and EMA . The cause of the exception is obtained from the value present in the EC register. Exception handler mechanism gives a facility to resume the execution of the process after the corresponding exception has been taken care of. It is not always possible to resume the execution of the process, as some events which cause the exception cannot be corrected. In this case, the proper action is to halt the process gracefully. For the events 1) illegal memory access (EC=2) 2) illegal instruction (EC=1) and 3) arithmetic exception (EC=3), the exception handler just prints the cause of the exception. These cases occur because the last instruction executed (in the currently running user process) resulted in the corresponding error condition. As the OS is not reponsible for correcting these conditions (why?), the exception handler halts the process gracefully and then invokes the scheduler to run other processes. The page fault exception (EC=0) occurs when the last instruction in the currently running application tried to either - Access/modify data from a legal address within its address space, but the page was set to invalid in the page table or fetch an instruction from a legal address within its address space, whose page table entry is invalid. In either case, the exception occured not because of any error from the side of the application, but because the OS had not loaded the page and set the page tables. In such case, the exception handler resumes the execution of the process after allocating the required page(s) for the process and attaching the page(s) to the process (by setting page table entries appropriately). If the faulted page is a code page, the OS needs to load the page from the disk to the newly allocated memory. But why should the OS not allocate all the pages required for a process when the process is initialized by the Exec system call, as we were doing in the previous two stages? The reason is that this method of pre-allocation allows fewer concurrent processes to run than with the present strategy of \"lazy allocation\" to be described now. The strategy followed in this stage is to start executing a process with just one page of code and two pages of stack allocated initially. When the process, during execution, tries to access a page that was not loaded, an exception is generated and the execption handler will allocate the required page. If the required page is a code page, the page will be transferred from the disk to the allocated memory. Since pages are allocated only on demand, memory utilization is better (on the average) with this approach. In previous stage, exec system call allocated 2 memory pages each for the heap and the stack. It also allocated and loaded all the code pages of the process. We will modify exec to allocate memory pages for only stack (2 pages). No memory pages will be allocated to heap. Consequently, the entries in the page table corresponding to heap are set to invalid. For code blocks, only a single memory page is allocated and the first code block is loaded into that memory page. In previous stage, the job of allocating a new memory page and loading a code block into that memory page is done by Get Free Page and Disk Load functions respectively. Now, we will write new module function Get Code Page in the memory manager module for simultaneously allocating a memory page and loading a code block. This function will be invoked from exec to allocate one memory page and load the first code block into that memory page. Note that only the first code page entry in the page table is set to valid, while remaining 3 entries are set to invalid. Each process has a data structure called Per-process Disk map table . The disk map table stores the disk block numbers corresponding to the memory pages used by the process. Each disk map table has 10 words of which one is for user area page, two for heap, four for code and two for stack pages. Remaining one word is unused. Whenever the copy of the memory page of a process is present in some disk block, that disk block number is stored in the per-process Disk Map Table entry corresponding to that memory page. This is done to keep track of the disk copy of memory pages. The SPL constant DISK_MAP_TABLE gives the starting address of the Disk Map Table of process with PID as 0. The disk map table for any process is obtained by adding PID*10 to DISK_MAP_TABLE. In this stage we will modify the exec system call to initialize the disk map table for the newly created process. The code page entries of the process's Disk Map Table are filled with the disk block numbers of the executable file being loaded from the inode table. Remaining entries are set to invalid (-1). (In later stages, when we swap out the process to disk, we will fill the stack and the heap entries with the disk block numbers used for swapping. More about this will be discussed in later stages). TheGet Code Page function takes as input the block number of a single code block, and loads that block into a memory page. Code pages are shared by the processes running the same program. The purpose of this function is to find out if the current code block is already in use by some other process. This is done by going through the disk map table entries of all the processes checking for the code block (block number provided as argument). If found, then the Get Code Page checks if the code block is loaded into a memory page (entry in the corresponding page table should be valid). If the code block is already present in some memory page, then Get Code Page function just returns that memory page number. If not, a new memory page is allocated by invoking the Get Free Page function of the memory manager module . This is followed by loading the code block intothe newly allocated memory page using the Disk Load function of the device manager module . The Get Code Page function finally returns the memory page number. The exception handler first switches to the kernel stack and backs up the register context as done by any other hardware interrupt routine. The exception handler then uses EC register to find out the cause of the exception. If the cause of the exception is other than page fault, exception handler should print the appropriate error message to notify the user about the termination of the process. As these exceptions cannot be corrected, exception handler must terminate the process by invoking the Exit Process function of process manager module and invoke the scheduler to schedule other processes. The register EIP saves the logical IP value of the instruction which has raised the exception. The register EPN stores the logical page number of the address that has caused the page fault. Note that eXpOS is designed such that, page fault exception can only occur for heap and code pages. Library pages are shared by all processes so they are always present in the memory. Stack pages are neccessary to run a process and are accessed more frequently. So both library and stack pages for a process should be present in the memory. Based on the value present in Exception Page Number (EPN) register, the exception handler finds out whether page fault has caused for heap or code page. When page fault has occured for heap page (EPN value 2 or 3), exception handler allocates 2 new memory pages by invoking the GetFree Page function in memory manager module . If the page fault has occured for a code page, then the exception handler invokes the Get Code Page function in memory manager module. The page table of the process is updated to store the page number obtained from Get Code Page or Get Free Page functions. After handling the page fault exception, the exception handler restores the register context, switches to user stack and returns to user mode. Note When page fault occurs for one heap page, the current eXpOS design allocates two pages for the heap. This can be optimized further to make the allocation lazier by allocating just one heap page and deferring allocation of a second page till a page fault occurs again for the second page. However, the lazier strategy causes some complications in the implementation of the Fork system call in the next stage. Here, we have chosen to keep the design simple by allocating both the heap pages when only one is demanded. Upon return to user mode, the instruction in the application that caused the exception must be re-executed. This indeed is the correct execution semantics as the machine had failed to execute the instruction that generated the exception. The XSM hardware sets the address of the instruction in the EIP register at the time of entering the exception.After completing the actions of the exception handler, the OS must place this address on the top of the application program's stack before returning control back to user mode.An OS can implement Demand Paging , as we will be doing here, only if the underlying machine hardware supports re-execution of the instruction that caused a page fault. The Free Page Table function of the process manager module decrements the memory reference count (in the memory free list ) of the memory pages acquired by a process. If some stack/heap page is swapped in the disk, the reference count of the corresponding disk block is decremented in the disk free list . Note that in the present stage, we allocate the stack/heap pages of a process in memory and never allocate any disk block to store stack/heap pages. Thus, the disk free list decrement is a vaccous step in the present stage. However this will be useful for later stages. Hence we design the module function in advance to meet the future requirements. The following is a brief explanation on why this step can be useful later. As already seen in Stage 2, eXpOS maintains the disk free list to keep track of disk block allocation. In later stages, the OS will allocate certain disk blocks to a process temporarily. This is done to swap out the heap/stack pages of a process when the OS finds shortage of memory space to run all the processes. If a heap/stack page of a process is swapped out into some disk block, the page can be released to some other process. In such cases, the page table entry for the swapped out page will be set to invalid, but the entry corresponding to the page in the disk map table will contain the disk block number to which the page has been swapped out. The disk free list entry for the block will be greater than zero as the block is no longer free. (It can happen that multiple processes share the block. The disk free list entry for the block will indicate the count of the number of processes sharing the disk block.) When the page table entries of a process are invalidated using the Free Page Table function of the process manager module, (either when a process exits or when the exec system call replaces the current process with a new one) it is necessary to ensure that any temporary disk blocks allocated to the process are also released. Hence the free page table function checks whether the disk map table entry of a stack/heap page contains a valid disk block number, and if so decrements its disk free list entry by invoking the Release Block function of the memory manager module. Control flow for Exec system call Modifications of exec system call \u00b6 Don't allocate memory pages for heap. Instead, invalidate page table entries for heap. Change the page allocation for code pages from previous stage. Invoke the Get Code Page function for the first code block and update the page table entry for this first code page.Invalidate rest of the code pages entries in the page table. Initialize the disk map table of the process. The code page entries are set to the disk block numbers from inode table of the program (program given as argument to exec). Initialize rest of the entries to -1. With these modifications, You have completed the final implementation of Exec system call. The full algorithm is provided here . Get Code Page (function number = 5, memorymanager module ) \u00b6 Check the disk map table entries of all the processes , if the given block number is present in any entry and the corresponding page table entry is valid then return the memory page number.Also increment the memory free list entry of that page. Memory Free list entry is incrementedas page is being shared by another process. If the code page is not in memory, then invoke Get Free Page function in the memory manager module to allocate a new page. Load the disk block to the newly acquired memory page by invoking the Disk Load function of the device manager module . Return the memory page number to which the code block has been loaded. Modification to the Free Page Table (function number = 4, process manager module ) \u00b6 Go through the heap and stack entries in the disk map table of the process with given PID. If any valid entries are found, invoke the Release Block function in the memory manager module . Invalidate all the entries of the disk map table. Release Block (function number = 4, Memory Manager Module ) \u00b6 Decrement the count of the disk block number in the memory copy of the Disk Free List. Return to the caller. Note Get Code Page , Free Page Table and Release Block functions implemented above are final versions. They will not require modification in later stages. Implementation of Exception Handler \u00b6 Control flow for Exception handler Set the MODE FLAG to -1 in the process table of the current process, indicating in exception handler. Switch to the kernel stack and backup the register context and push EIP onto the stack. If the cause of the exception is other than page fault (EC is not equal to 0) or if the user stack is full (when userSP is PTLR 512-1, the return address can't be pushed onto the stack), then print a meaningful error message. Then invoke the Exit Process * function to halt the process and invoke the scheduler. If page fault is caused due to a code page, then get the code block number to be loaded from the disk map table . For this block, invoke the Get Code Page function present in the memory manager module . Update the page table entry for this code page,set the page number to memory page obtained from Get Code Page function and auxiliary information to \"1100\". If page fault is caused due to a heap page, then invoke the Get Free Page function of the memory manager module twice to allocate two memory pages for the heap. Update the page table entry for these heap pages, set the page numbers to the memory pages obtained from Get Free Page function and set auxiliary information to \"1110\". Reset the MODE FLAG to 0. Pop EIP from the stack and restore the register context. Change to the user stack. Increment the stack pointer, store the EIP value onto the location pointed to by SP and return to the user mode. (Address translations needs to be done on the SP to find the stack address to which EIP is to be stored) The Exception handler implementation given above is final. The full algorithm is given here . Modification to the Boot Module \u00b6 Initialize the disk map table entries for the INIT process. Load the Disk Free List from the disk block 2 to the memory page 61. (See disk and memory organization here .) Making things work \u00b6 Compile and load the modified and newly written files into the disk using the XFS-interface. Q1. Does EPN always equal to the logical page number of EIP? No. Page fault can occur in two situations. One possibility is during insturction fetch - if the instruction pointer points to an invalid page. In this case, the missing virtual page number (EPN) corresponds to the logical page number of the EIP. The second possibility is during instruction execution when an operand fetch/memory write accesses a page that is not loaded. In this case EPN will indicate the page number of the missing page, and not the logical page number corresponding to EIP value. Q2. Why does the exception handler terminate the process when the userSP value is PTLR*512-1 ? The XSM machine doesn't push the return address into the user stack when the exception occurs, instead it stores the address in the EIP register. Hence, for the exception handler to return to the instruction which caused the exception, the EIP register value must be pushed onto the top of the user stack of the program. However, when the application's stack is full (userSP = PTLR*512-1), there is no stack space left to place the return address and the only sensible action for the OS is to terminate the process. Q3. Why does the exception handler save the contents of the EIP register immediately into the kernel stack upon entry into the exception handler? The execption handler may block for a disk read and invoke the scheduler during it's course of execution. The value of the EIP register must be stored before scheduling other processes as the current value will be overwritten by the machine if an exception occurs in another application that is scheduled in this way. Assignment 1 Write an ExpL program to implement a linked list. Your program should first read an integer N, then read N intergers from console and store them in the linked list and print the linked list to the console. Run this program using shell version-I of stage 17. Assignment 2 Use the XSM debugger to dump the contents of the Exception Flag registers upon entry into the Exception Handler. Also, print out the contents of the Disk Map Table and the Page Table after the Get Code Page function (inside the Memory Manager module).","title":"Stage 19"},{"location":"roadmap/stage-19/#modifications-of-exec-system-call","text":"Don't allocate memory pages for heap. Instead, invalidate page table entries for heap. Change the page allocation for code pages from previous stage. Invoke the Get Code Page function for the first code block and update the page table entry for this first code page.Invalidate rest of the code pages entries in the page table. Initialize the disk map table of the process. The code page entries are set to the disk block numbers from inode table of the program (program given as argument to exec). Initialize rest of the entries to -1. With these modifications, You have completed the final implementation of Exec system call. The full algorithm is provided here .","title":"Modifications of exec system call"},{"location":"roadmap/stage-19/#get-code-page-function-number-5memorymanager-module","text":"Check the disk map table entries of all the processes , if the given block number is present in any entry and the corresponding page table entry is valid then return the memory page number.Also increment the memory free list entry of that page. Memory Free list entry is incrementedas page is being shared by another process. If the code page is not in memory, then invoke Get Free Page function in the memory manager module to allocate a new page. Load the disk block to the newly acquired memory page by invoking the Disk Load function of the device manager module . Return the memory page number to which the code block has been loaded.","title":"Get Code Page (function number = 5,memorymanager module)"},{"location":"roadmap/stage-19/#modification-to-the-free-page-table-function-number-4process-manager-module","text":"Go through the heap and stack entries in the disk map table of the process with given PID. If any valid entries are found, invoke the Release Block function in the memory manager module . Invalidate all the entries of the disk map table.","title":"Modification to the Free Page Table (function number = 4,process manager module)"},{"location":"roadmap/stage-19/#release-block-function-number-4memory-manager-module","text":"Decrement the count of the disk block number in the memory copy of the Disk Free List. Return to the caller. Note Get Code Page , Free Page Table and Release Block functions implemented above are final versions. They will not require modification in later stages.","title":"Release Block (function number = 4,Memory Manager Module)"},{"location":"roadmap/stage-19/#implementation-of-exception-handler","text":"Control flow for Exception handler Set the MODE FLAG to -1 in the process table of the current process, indicating in exception handler. Switch to the kernel stack and backup the register context and push EIP onto the stack. If the cause of the exception is other than page fault (EC is not equal to 0) or if the user stack is full (when userSP is PTLR 512-1, the return address can't be pushed onto the stack), then print a meaningful error message. Then invoke the Exit Process * function to halt the process and invoke the scheduler. If page fault is caused due to a code page, then get the code block number to be loaded from the disk map table . For this block, invoke the Get Code Page function present in the memory manager module . Update the page table entry for this code page,set the page number to memory page obtained from Get Code Page function and auxiliary information to \"1100\". If page fault is caused due to a heap page, then invoke the Get Free Page function of the memory manager module twice to allocate two memory pages for the heap. Update the page table entry for these heap pages, set the page numbers to the memory pages obtained from Get Free Page function and set auxiliary information to \"1110\". Reset the MODE FLAG to 0. Pop EIP from the stack and restore the register context. Change to the user stack. Increment the stack pointer, store the EIP value onto the location pointed to by SP and return to the user mode. (Address translations needs to be done on the SP to find the stack address to which EIP is to be stored) The Exception handler implementation given above is final. The full algorithm is given here .","title":"Implementation of Exception Handler"},{"location":"roadmap/stage-19/#modification-to-the-boot-module","text":"Initialize the disk map table entries for the INIT process. Load the Disk Free List from the disk block 2 to the memory page 61. (See disk and memory organization here .)","title":"Modification to the Boot Module"},{"location":"roadmap/stage-19/#making-things-work","text":"Compile and load the modified and newly written files into the disk using the XFS-interface. Q1. Does EPN always equal to the logical page number of EIP? No. Page fault can occur in two situations. One possibility is during insturction fetch - if the instruction pointer points to an invalid page. In this case, the missing virtual page number (EPN) corresponds to the logical page number of the EIP. The second possibility is during instruction execution when an operand fetch/memory write accesses a page that is not loaded. In this case EPN will indicate the page number of the missing page, and not the logical page number corresponding to EIP value. Q2. Why does the exception handler terminate the process when the userSP value is PTLR*512-1 ? The XSM machine doesn't push the return address into the user stack when the exception occurs, instead it stores the address in the EIP register. Hence, for the exception handler to return to the instruction which caused the exception, the EIP register value must be pushed onto the top of the user stack of the program. However, when the application's stack is full (userSP = PTLR*512-1), there is no stack space left to place the return address and the only sensible action for the OS is to terminate the process. Q3. Why does the exception handler save the contents of the EIP register immediately into the kernel stack upon entry into the exception handler? The execption handler may block for a disk read and invoke the scheduler during it's course of execution. The value of the EIP register must be stored before scheduling other processes as the current value will be overwritten by the machine if an exception occurs in another application that is scheduled in this way. Assignment 1 Write an ExpL program to implement a linked list. Your program should first read an integer N, then read N intergers from console and store them in the linked list and print the linked list to the console. Run this program using shell version-I of stage 17. Assignment 2 Use the XSM debugger to dump the contents of the Exception Flag registers upon entry into the Exception Handler. Also, print out the contents of the Disk Map Table and the Page Table after the Get Code Page function (inside the Memory Manager module).","title":"Making things work"},{"location":"roadmap/stage-20/","text":"Learning Objectives Understanding the process creation mechanism in eXpOS. Implementation of fork and exit system calls. Pre-requisite Reading Read and understand eXpOS process abstraction and eXpOS process model documentation before proceeding further. In this stage, you will learn how to create a new process using the fork system call and how to terminate a process using the exit system call. Fork System Call \u00b6 The Fork system call spawns a new process. The new process and the process which invoked fork have a child-parent relationship. The child process will be allocated a different PID and a new address space . Hence, the child process will have a different process table and page table. However, the child and the parent will share the code and heap regions of the address space. The child will be allocated two new stack pages and a new user area page. The process table of the child is initialized with the same values of the parent except for the values of TICK, PID, PPID, USER AREA PAGE NUMBER, KERNEL STACK POINTER, INPUT BUFFER, MODE FLAG, PTBR and PTLR.The contents of the stack of the parent are copied into the new stack pages allocated for the child. The contents of the per process resource table in the user area page of the parent process is copied to the child process. However, the contents of the parent's kernel stack are not copied to the child, and the kernel stack of the child is set to empty (that is, KPTR field in the process table entry of the child is set to 0.) Fork system call returns to the the parent process. The parent resumes execution from the next instruction following the INT instruction invoking fork. Upon successful completion, fork returns the PID of the child process to parent process. After completion of fork, the child process will be ready for execution and will be in the CREATED state. When the child process is scheduled (by the scheduler) to run for the first time, it will start its execution from the immediate instruction after the call to fork. The return value of fork to the child process is zero. We have already noted that the child process shares the heap and code pages with the parent process, whereas new memory pages are allocated for user stack of the child. The contents of the parent's user stack pages are copied to the user stack of the child process. ExpL compiler allocates local variables, global variables and arrays of primitive data types (int, string) of a process in the stack. Since the parent and child processes have different memory pages for the user stack, they resume after fork with separate private copies of these variables, with the same values. Since the stack page is not shared between the parent and the child, subsequent modifications to these variables by either parent or the child will not be visible to the other. The Alloc() function of eXpOS library allocates memory from the heap region of a process. Hence memory allocated by Alloc() to store objects referenced by variables of user defined types in an ExpL program will be allocated in the heap. As heap pages are shared by the parent and the child, both processes share the memory allocated using Alloc() . Thus, if the parent had allocated memory using the Alloc() function and attached it to a variable of some user defined type before fork, the copies of the variables in both the parent and the child store the address of the same shared memory. Since the Parent and child processes can concurrently access/modify the heap pages, they need support from the OS to synchronize access to the shared heap memory. eXpOS provides support for such synchronization through systems calls for semaphores and signal handling . These will be discussed in later stages. Even though, code and library pages are shared among parent and child processes, synchronization is not required for these pages as their access is read only. Note There is a subtility to be noted here. It can happen that the kernel has not allocated any heap pages for the parent process at the time when it invoked Fork. This is because heap pages are allocated inside the exception handler when a process generates a page fault exeception while trying to access the heap. Thus a process could invoke fork before any heap pages were allocated to it. However, the eXpOS sharing semantics requires that the parent and the child shares their heap pages. Hence, to satisfy the heap sharing semantics, the OS needs to ensure during Fork that the parent is allocated its heap pages and these pages are shared with the child. Control flow for Fork system call High level ExpL programs can invoke fork system call using the library interface function exposcall . Fork has system call number 8 and it is implemented in the interrupt routine 8. Fork does not take any arguments. Follow the description below to implement the fork system call. Read the description of various entries of process table before proceeding further. The first action to perform in the fork system call is to set the MODE FLAG to the system call number and switch to the kernel stack. To get a new PID for the child process, invoke the Get Pcb Entry function from the process manager module . Get Pcb Entry returns the index of the new process table allocated for the child. This index is saved as the PID of the child. As there are only 16 process tables present in the memory, maximum 16 processes can run simultaneously. If a free process table is not available, Get Pcb Entry returns -1. In such case, store -1 as the return value in the stack, reset the MODE FLAG (to 0), switch to user stack and return to the user mode from the fork system call. When PID is available, proceed with the fork system call. If the heap pages are not allocated for the parent process, allocate heap pages by invoking the Get Free Page function of the memory manager module and set the page table entries for the heap pages of the parent process to the pages acquired. - The child process requires new memory pages for stack (two) and user area page (one). To allocate a memory page, invoke the Get Free Page function of the memory manager module . The next step in the fork system call is initialization of the process table for the child process. Copy the USERID field from the process table of the parent to the child process, as the user (currently logged in) will be same for both child and parent. (We will discuss USERID later when we add multi-user support to eXpOS.) Similarly, copy the SWAP FLAG and the USER AREA SWAP STATUS fields. (These fields will be discussed later, when we discuss swapping out processes from memory to the disk.) INODE INDEX for the child and the parent processes will be same, as both of them run the same program. UPTR field should also be copied from the parent process. As mentioned earlier, content of the user stack is same for both of them, so when both of the processes resume execution in user mode, the value of SP must be the same. Set the MODE FLAG, KPTR and TICK fields of the child process to 0. MODE FLAG, KPTR are set to zero as the child process starts its execution from the user mode. The TICK field keep track of how long a process has been running in memory and should be initialized to 0, when a process is created. (The TICK field will be used later to decide which process must be swapped out of memory when memory is short. The strategy will be to swap out that process which had been in memory for the longest time). PID of the parent is stored in the PPID field of the process table of the child. STATE of the child process is set to CREATED . Store the new memory page number obtained for user area page in the USER AREA PAGE NUMBER field in the process table of the child proces. PID, PTBR and PTLR fields of the child process are already initialized in the Get Pcb Entry function. It is not required to initialize INPUT BUFFER . The per-process resource table has details about the open instances of the files and the semaphores currently acquired by the process. Child process shares the files and the semaphores opened by the parent process. Hence we need to copy the entries of the per-process resource table of the parent to the child. We will discuss files and semaphores in later stages. (There is a little bit more book keeping work associated with files and semaphores. Since we have not added files or semaphores so far to the OS, we will skip this work for the time being and complete the pending tasks in later stages). Copy the per-process disk map table of the parent to the child. This will ensure that the disk block numbers of the code pages of the parent process are copied to the child.Further, if the parent has swapped out heap pages, those will be shared by the child. (This will be explained in detail in a later stage). The eXpOS design guarentees that the stack pages and the user area page of a process will not be swapped at the time when it invokes the fork system call. Hence the disk map table entries of the parent process corresponding to the stack and user area pages will be invalid, and these entries of the child too must be set to invalid. Initialize the page table of the child process. As heap, code and library pages are shared by the parent process and the child process, copy these entries (page number and auxiliary information) form the page table of the parent to the child. For each page shared, increment the corresponding share count in the memory free list (why do we do need to do this?). Initialize the stack page entries in the page table with the new memory page numbers obtained earlier. Note that the auxiliary information for the stack pages is same for both parent and child (why?). Copy content of the user stack pages of the parent to the user stack pages of the child word by word. Store the value in the BP register on top of the kernel stack of child process. This value will be used to initialize the BP register of the child process by the scheduler when the child is scheduled for the first time. Set up return values in the user stacks of the parent and the child processes. Store the PID of the child process as return value to the parent and 0 as the return values to the child. Reset the MODE FLAG of the parent process. Switch to the user stack of the parent process and return to the user mode. The complete version of the algorithm for the fork system call is provided here . Get Pcb Entry (function number = 1, Process Manager Module ) \u00b6 The Get Pcb Entry function in the process manager, finds out a free process table entry and returns the index of it to the caller. If no process table entry is free, it returns -1. A free process table entry ( STATE field is set to TERMINATED ) can be found out by looping through all process table entries. Initialize the PID to the index of the free entry. Set the STATE to ALLOCATED . Initialize PTBR to the starting address of the page table for that process (obtained using index) and PTLR to 10. Return the index to the caller. Note The implementation of above Get Pcb Entry module function is final version. Modifications to Scheduler module \u00b6 The context-switch (scheduler) module is modified in this stage. The BP register of the child has to be initiazed by the scheduler for the first time as child is in created state. Refer to the detailed schedular algorithm here . When the process is in created state, add folllowing steps before switching to user stack. Store the value in the first word of the kernel stack to the BP register. Exit System Call \u00b6 At the end of every process, exit system call is invoked to terminate the process. In the previous stages, we had already implemented the exit system call. Now, we will change the exit system call to invoke the module function Exit Process to terminate the process. Exit system call has to update/clear the OS data structures of the terminating process and detach the memory pages allocated to the process from its address space. The page table entries are invalidated. There may be other processes waiting for this process to terminate. Exit system call must wake up these processes. (Currently, processes do not wait, we will see this in the next stage.) Exit has to close the files and release the semaphores acquired by the process. Per-process resource table has to be invalidated. Finally, Exit has to set the state of the process to TERMINATED. These tasks are done by invoking the ExitProcess function of the process manager module . Control flow for Exit system call Exit system call has a system call number 10 and is implemented in the interrupt routine 10. Follow the description given below to implement the exit system call. Exit system call first sets the MODE FLAG to the system call number and switches to the kernal stack. It then invokes the Exit Process function present in the process manager module. Finally, Exit system call invokes the scheduler to schedule other processes. Note With above changes implementation of exit system call is complete. The algorithm for exit system call is given here . Modifications to the Boot module \u00b6 Load interrupt routine 8 from disk to memory. Making things work \u00b6 Compile and load interrupt routine 8, interrupt routine 10, module 2, module 5 into the disk using the XFS-interface. Q1. How does eXpOS prevent a program running in user mode from writing to the library and code pages? In the page table of every process, pages of a process have auxiliary information associated with them. Auxiliary information consists of 4 bits of which third bit is write bit. If write bit is set to 1 for a page, then the process (to which the page belongs) has permission to write to the corresponding page. When write bit is set to 0, the page has read only access. So the process can not modify the content of the page. For every process, write bit is set to 0 for library and code pages while initializing page table. When a process tries to write to a page for which write bit is 0, XSM machine raises illegal memory access exception. Refer about auxiliary information here . Q2. Where does ExpL allocate memory for variables of user defined data type? Variables of user defined data type are allocated memory in stack, same as any variable of primitive data type. Every variable in ExpL is allocated one word memory in stack. Variable of primitive data type saves actual data in the word that is allocated to it, but variables of user defined data type stores the starting address of the object. Alloc() library function allocates memory for an object in heap and returns the starting address. This return address is stored in the stack for corresponding variable. Q3. Upon completion of the fork system call, the parent and the child will contain the same return IP address on the top of the user stack. The value of the user stack pointer (UPTR) will also be the same for both the processes. When the fork sytem call returns to user mode (using the IRET instruction) which process executes first - parent or child? why? Fork system call returns to the parent process. IRET sets the value of IP register to the return address at the top of the stack, pointed to by the SP register. The machine translates the logical SP to physical SP using the page table pointed to by the PTBR register, which points to the page table of the parent. Subsequent instruction fetch cycles continue to proceed by translating the value of IP using the PTBR value, which points to the page table of the parent process. The parent process continues execution till a context switch occurs. Q4. What would go wrong if the Get Pcb Entry function sets the state of a newly allocated PCB entry to CREATED instead of ALLOCATED? The fork system call which invokes the Get Pcb Entry function for the child process might block before completing process creation (if the Get Free Page function finds no free page in memory and invokes the scheduler). In such case, the scheduler must not try to run the new process as its creation is not complete. Q5. When there is a page fault for a heap page, the exception handler which you have completed in stage 19 allocates both the heap pages for the process. Suppose you modify the exception handler to allocate only one heap page corresponding to the page requested (deferring the allocation of the second page till another exception occurs), what modification would be needed to your Fork system call code? eXpOS semantics requires that the parent and the child share the heap. Hence, if the parent did not have two heap pages already allocated before Fork, the pages must be allocated at the time of Fork and shared with the child. An alternate approach would be to share only the presently allocated heap page (if any) of the parent with the child and wait for a page fault in either of the processes to allocate the other page. However, in this case, care must be taken to ensure that the same page is shared between the parent and the child when one of them is allocated a heap page. Note When all processes except IDLE are TERMINATED, our present OS will repeatedly schedule IDLE and thus will be in an infinite loop. Hence you will have to Use Ctrl+C to terminate the machine. We will ensure graceful shutdown from the next stage. Assignment 1 Write two ExpL programs even.expl and odd.expl to print the first 100 even and odd numbers respectively. Write another ExpL program that first creates a child process using Fork. Then, the parent process shall use the exec system call to execute even.xsm and the child shall execute odd.xsm. Load this program as the init program. Assignment 2 Write an ExpL program which creates linked list of the first 100 numbers. The program then forks to create a child so that the parent and the child has separate pointers to the head of the shared linked list. Now, the child prints the 1st, 3rd, 5th, 7th... etc. entries of the list whereas the parent prints the 2nd, 4th, 6th, 8th....etc. entries of the list. Eventually all numbers will be printed, but in some arbitrary order (why?). The program is given here . Try to read and understand the program before running it. Run the program as the INIT program. In the next stages, we will see how to use the sychronization primitives of the OS to modify the above program so that the numbers are printed out in sequential order.","title":"Stage 20"},{"location":"roadmap/stage-20/#fork-system-call","text":"The Fork system call spawns a new process. The new process and the process which invoked fork have a child-parent relationship. The child process will be allocated a different PID and a new address space . Hence, the child process will have a different process table and page table. However, the child and the parent will share the code and heap regions of the address space. The child will be allocated two new stack pages and a new user area page. The process table of the child is initialized with the same values of the parent except for the values of TICK, PID, PPID, USER AREA PAGE NUMBER, KERNEL STACK POINTER, INPUT BUFFER, MODE FLAG, PTBR and PTLR.The contents of the stack of the parent are copied into the new stack pages allocated for the child. The contents of the per process resource table in the user area page of the parent process is copied to the child process. However, the contents of the parent's kernel stack are not copied to the child, and the kernel stack of the child is set to empty (that is, KPTR field in the process table entry of the child is set to 0.) Fork system call returns to the the parent process. The parent resumes execution from the next instruction following the INT instruction invoking fork. Upon successful completion, fork returns the PID of the child process to parent process. After completion of fork, the child process will be ready for execution and will be in the CREATED state. When the child process is scheduled (by the scheduler) to run for the first time, it will start its execution from the immediate instruction after the call to fork. The return value of fork to the child process is zero. We have already noted that the child process shares the heap and code pages with the parent process, whereas new memory pages are allocated for user stack of the child. The contents of the parent's user stack pages are copied to the user stack of the child process. ExpL compiler allocates local variables, global variables and arrays of primitive data types (int, string) of a process in the stack. Since the parent and child processes have different memory pages for the user stack, they resume after fork with separate private copies of these variables, with the same values. Since the stack page is not shared between the parent and the child, subsequent modifications to these variables by either parent or the child will not be visible to the other. The Alloc() function of eXpOS library allocates memory from the heap region of a process. Hence memory allocated by Alloc() to store objects referenced by variables of user defined types in an ExpL program will be allocated in the heap. As heap pages are shared by the parent and the child, both processes share the memory allocated using Alloc() . Thus, if the parent had allocated memory using the Alloc() function and attached it to a variable of some user defined type before fork, the copies of the variables in both the parent and the child store the address of the same shared memory. Since the Parent and child processes can concurrently access/modify the heap pages, they need support from the OS to synchronize access to the shared heap memory. eXpOS provides support for such synchronization through systems calls for semaphores and signal handling . These will be discussed in later stages. Even though, code and library pages are shared among parent and child processes, synchronization is not required for these pages as their access is read only. Note There is a subtility to be noted here. It can happen that the kernel has not allocated any heap pages for the parent process at the time when it invoked Fork. This is because heap pages are allocated inside the exception handler when a process generates a page fault exeception while trying to access the heap. Thus a process could invoke fork before any heap pages were allocated to it. However, the eXpOS sharing semantics requires that the parent and the child shares their heap pages. Hence, to satisfy the heap sharing semantics, the OS needs to ensure during Fork that the parent is allocated its heap pages and these pages are shared with the child. Control flow for Fork system call High level ExpL programs can invoke fork system call using the library interface function exposcall . Fork has system call number 8 and it is implemented in the interrupt routine 8. Fork does not take any arguments. Follow the description below to implement the fork system call. Read the description of various entries of process table before proceeding further. The first action to perform in the fork system call is to set the MODE FLAG to the system call number and switch to the kernel stack. To get a new PID for the child process, invoke the Get Pcb Entry function from the process manager module . Get Pcb Entry returns the index of the new process table allocated for the child. This index is saved as the PID of the child. As there are only 16 process tables present in the memory, maximum 16 processes can run simultaneously. If a free process table is not available, Get Pcb Entry returns -1. In such case, store -1 as the return value in the stack, reset the MODE FLAG (to 0), switch to user stack and return to the user mode from the fork system call. When PID is available, proceed with the fork system call. If the heap pages are not allocated for the parent process, allocate heap pages by invoking the Get Free Page function of the memory manager module and set the page table entries for the heap pages of the parent process to the pages acquired. - The child process requires new memory pages for stack (two) and user area page (one). To allocate a memory page, invoke the Get Free Page function of the memory manager module . The next step in the fork system call is initialization of the process table for the child process. Copy the USERID field from the process table of the parent to the child process, as the user (currently logged in) will be same for both child and parent. (We will discuss USERID later when we add multi-user support to eXpOS.) Similarly, copy the SWAP FLAG and the USER AREA SWAP STATUS fields. (These fields will be discussed later, when we discuss swapping out processes from memory to the disk.) INODE INDEX for the child and the parent processes will be same, as both of them run the same program. UPTR field should also be copied from the parent process. As mentioned earlier, content of the user stack is same for both of them, so when both of the processes resume execution in user mode, the value of SP must be the same. Set the MODE FLAG, KPTR and TICK fields of the child process to 0. MODE FLAG, KPTR are set to zero as the child process starts its execution from the user mode. The TICK field keep track of how long a process has been running in memory and should be initialized to 0, when a process is created. (The TICK field will be used later to decide which process must be swapped out of memory when memory is short. The strategy will be to swap out that process which had been in memory for the longest time). PID of the parent is stored in the PPID field of the process table of the child. STATE of the child process is set to CREATED . Store the new memory page number obtained for user area page in the USER AREA PAGE NUMBER field in the process table of the child proces. PID, PTBR and PTLR fields of the child process are already initialized in the Get Pcb Entry function. It is not required to initialize INPUT BUFFER . The per-process resource table has details about the open instances of the files and the semaphores currently acquired by the process. Child process shares the files and the semaphores opened by the parent process. Hence we need to copy the entries of the per-process resource table of the parent to the child. We will discuss files and semaphores in later stages. (There is a little bit more book keeping work associated with files and semaphores. Since we have not added files or semaphores so far to the OS, we will skip this work for the time being and complete the pending tasks in later stages). Copy the per-process disk map table of the parent to the child. This will ensure that the disk block numbers of the code pages of the parent process are copied to the child.Further, if the parent has swapped out heap pages, those will be shared by the child. (This will be explained in detail in a later stage). The eXpOS design guarentees that the stack pages and the user area page of a process will not be swapped at the time when it invokes the fork system call. Hence the disk map table entries of the parent process corresponding to the stack and user area pages will be invalid, and these entries of the child too must be set to invalid. Initialize the page table of the child process. As heap, code and library pages are shared by the parent process and the child process, copy these entries (page number and auxiliary information) form the page table of the parent to the child. For each page shared, increment the corresponding share count in the memory free list (why do we do need to do this?). Initialize the stack page entries in the page table with the new memory page numbers obtained earlier. Note that the auxiliary information for the stack pages is same for both parent and child (why?). Copy content of the user stack pages of the parent to the user stack pages of the child word by word. Store the value in the BP register on top of the kernel stack of child process. This value will be used to initialize the BP register of the child process by the scheduler when the child is scheduled for the first time. Set up return values in the user stacks of the parent and the child processes. Store the PID of the child process as return value to the parent and 0 as the return values to the child. Reset the MODE FLAG of the parent process. Switch to the user stack of the parent process and return to the user mode. The complete version of the algorithm for the fork system call is provided here .","title":"Fork System Call"},{"location":"roadmap/stage-20/#get-pcb-entry-function-number-1-process-manager-module","text":"The Get Pcb Entry function in the process manager, finds out a free process table entry and returns the index of it to the caller. If no process table entry is free, it returns -1. A free process table entry ( STATE field is set to TERMINATED ) can be found out by looping through all process table entries. Initialize the PID to the index of the free entry. Set the STATE to ALLOCATED . Initialize PTBR to the starting address of the page table for that process (obtained using index) and PTLR to 10. Return the index to the caller. Note The implementation of above Get Pcb Entry module function is final version.","title":"Get Pcb Entry (function number = 1, Process Manager Module)"},{"location":"roadmap/stage-20/#modifications-to-scheduler-module","text":"The context-switch (scheduler) module is modified in this stage. The BP register of the child has to be initiazed by the scheduler for the first time as child is in created state. Refer to the detailed schedular algorithm here . When the process is in created state, add folllowing steps before switching to user stack. Store the value in the first word of the kernel stack to the BP register.","title":"Modifications to Scheduler module"},{"location":"roadmap/stage-20/#exit-system-call","text":"At the end of every process, exit system call is invoked to terminate the process. In the previous stages, we had already implemented the exit system call. Now, we will change the exit system call to invoke the module function Exit Process to terminate the process. Exit system call has to update/clear the OS data structures of the terminating process and detach the memory pages allocated to the process from its address space. The page table entries are invalidated. There may be other processes waiting for this process to terminate. Exit system call must wake up these processes. (Currently, processes do not wait, we will see this in the next stage.) Exit has to close the files and release the semaphores acquired by the process. Per-process resource table has to be invalidated. Finally, Exit has to set the state of the process to TERMINATED. These tasks are done by invoking the ExitProcess function of the process manager module . Control flow for Exit system call Exit system call has a system call number 10 and is implemented in the interrupt routine 10. Follow the description given below to implement the exit system call. Exit system call first sets the MODE FLAG to the system call number and switches to the kernal stack. It then invokes the Exit Process function present in the process manager module. Finally, Exit system call invokes the scheduler to schedule other processes. Note With above changes implementation of exit system call is complete. The algorithm for exit system call is given here .","title":"Exit System Call"},{"location":"roadmap/stage-20/#modifications-to-the-boot-module","text":"Load interrupt routine 8 from disk to memory.","title":"Modifications to the Boot module"},{"location":"roadmap/stage-20/#making-things-work","text":"Compile and load interrupt routine 8, interrupt routine 10, module 2, module 5 into the disk using the XFS-interface. Q1. How does eXpOS prevent a program running in user mode from writing to the library and code pages? In the page table of every process, pages of a process have auxiliary information associated with them. Auxiliary information consists of 4 bits of which third bit is write bit. If write bit is set to 1 for a page, then the process (to which the page belongs) has permission to write to the corresponding page. When write bit is set to 0, the page has read only access. So the process can not modify the content of the page. For every process, write bit is set to 0 for library and code pages while initializing page table. When a process tries to write to a page for which write bit is 0, XSM machine raises illegal memory access exception. Refer about auxiliary information here . Q2. Where does ExpL allocate memory for variables of user defined data type? Variables of user defined data type are allocated memory in stack, same as any variable of primitive data type. Every variable in ExpL is allocated one word memory in stack. Variable of primitive data type saves actual data in the word that is allocated to it, but variables of user defined data type stores the starting address of the object. Alloc() library function allocates memory for an object in heap and returns the starting address. This return address is stored in the stack for corresponding variable. Q3. Upon completion of the fork system call, the parent and the child will contain the same return IP address on the top of the user stack. The value of the user stack pointer (UPTR) will also be the same for both the processes. When the fork sytem call returns to user mode (using the IRET instruction) which process executes first - parent or child? why? Fork system call returns to the parent process. IRET sets the value of IP register to the return address at the top of the stack, pointed to by the SP register. The machine translates the logical SP to physical SP using the page table pointed to by the PTBR register, which points to the page table of the parent. Subsequent instruction fetch cycles continue to proceed by translating the value of IP using the PTBR value, which points to the page table of the parent process. The parent process continues execution till a context switch occurs. Q4. What would go wrong if the Get Pcb Entry function sets the state of a newly allocated PCB entry to CREATED instead of ALLOCATED? The fork system call which invokes the Get Pcb Entry function for the child process might block before completing process creation (if the Get Free Page function finds no free page in memory and invokes the scheduler). In such case, the scheduler must not try to run the new process as its creation is not complete. Q5. When there is a page fault for a heap page, the exception handler which you have completed in stage 19 allocates both the heap pages for the process. Suppose you modify the exception handler to allocate only one heap page corresponding to the page requested (deferring the allocation of the second page till another exception occurs), what modification would be needed to your Fork system call code? eXpOS semantics requires that the parent and the child share the heap. Hence, if the parent did not have two heap pages already allocated before Fork, the pages must be allocated at the time of Fork and shared with the child. An alternate approach would be to share only the presently allocated heap page (if any) of the parent with the child and wait for a page fault in either of the processes to allocate the other page. However, in this case, care must be taken to ensure that the same page is shared between the parent and the child when one of them is allocated a heap page. Note When all processes except IDLE are TERMINATED, our present OS will repeatedly schedule IDLE and thus will be in an infinite loop. Hence you will have to Use Ctrl+C to terminate the machine. We will ensure graceful shutdown from the next stage. Assignment 1 Write two ExpL programs even.expl and odd.expl to print the first 100 even and odd numbers respectively. Write another ExpL program that first creates a child process using Fork. Then, the parent process shall use the exec system call to execute even.xsm and the child shall execute odd.xsm. Load this program as the init program. Assignment 2 Write an ExpL program which creates linked list of the first 100 numbers. The program then forks to create a child so that the parent and the child has separate pointers to the head of the shared linked list. Now, the child prints the 1st, 3rd, 5th, 7th... etc. entries of the list whereas the parent prints the 2nd, 4th, 6th, 8th....etc. entries of the list. Eventually all numbers will be printed, but in some arbitrary order (why?). The program is given here . Try to read and understand the program before running it. Run the program as the INIT program. In the next stages, we will see how to use the sychronization primitives of the OS to modify the above program so that the numbers are printed out in sequential order.","title":"Making things work"},{"location":"roadmap/stage-21/","text":"Learning Objectives Familiarize with process synchronization in eXpOS Implementation of Wait and Signal system calls Pre-requisite Reading Read and understand Access control and synchronization and Process synchronization documentations before proceeding further. In this stage, we will add support for process synchronization using Wait and Signal system calls to eXpOS. With the help of these system calls, we will design a more advanced shell program. We will also implement Getpid and Getppid system calls. When a process executes the Wait system call, its execution is suspended till the process whose PID is given as argument to Wait terminates or executes the Signal system call. The process that enters Wait sets its state to WAIT_PROCESS and invokes the scheduler. A process executes the Signal system call to wake up all the processes waiting for it. If a process terminates without invoking Signal , then Exit system call voluntarily wakes up all the processes waiting for it. When several processes running concurrently share a resource (shared memory or file) it is necessary to synchronize access to the shared resource to avoid data inconsistency. Wait and Signal form one pair of primitives that help to achieve synchronization. In general, synchronization primitives help two co-operating processes to ensure that one process stops execution at certain program point, and waits for the other to issue a signal, before continuing execution. To understand how Wait and Signal help for process synchronization, assume that two processes (say A and B) executing concurrently share a resource. When process A issues the Wait system call with the PID of process B, it intends to wait until process B signals or terminates. When process B is done with the resource, it can invoke the Signal system call to wake up process A (and all other processes waiting for process B). Thus, Signal and Wait can ensure that process A is allowed to access the resource only after process B permits process A to do so. In the above example suppose process B had finished using the shared resource and had executed Signal system call before process A executed Wait system call, then process A will wait for process B to issue another signal. Hence if process B does not issue another signal, then process A will resume execution only after process B terminates. The issue here is that, although the OS acts on the occurance of a signal immediately, it never records the occurance of the signal for the future. In other words, Signals are memoryless. A more advanced synchronization primitive that has a state variable associated with it - namely the semaphore - will be added to the OS in the next stage. When a process issues the Exit system call, all processes waiting for it must be awakened. We will modify the Exit Process function in the process manager module to wake up all processes waiting for the terminating process. However, there is one special case to handle here. The Exit Process function is invoked by the Exec system call as well. In this case, the process waiting for the current process must not be woken up (why?). The implementation details will be explained below. Finally, when a process Exits, all its child processes become orphan processes and their PPID field is set to -1 in the module function Exit Process . Here too, if Exit Process in invoked from the Exec system call, the children must not become orphans. Shell Program \u00b6 The Shell is a user program that implements an interactive user interface for the OS. In the present stage, we will run the shell as the INIT program, so that the shell will interact with the user. The shell asks you to enter a string (called a command). If the string entered is \"Shutdown\", the program executes the Shutdown system call to halt the OS. Otherwise, the shell program forks and create a child process. The parent process then waits for the child to exit using the Wait system call. The child process will try to execute the command (that is, execute the file with name command.) If no such file exists, Exec fails and the child prints \"BAD COMMAND\" and exits. Otherwise, the command file will be executed. In either case, upon completion of the child process, the parent process wakes up. The parent then goes on to ask the user for the next command. Implementation of Interrupt routine 11 \u00b6 The system calls Wait , Signal , Getpid and Getppid are all implemented in the interrupt routine 11. Each system call has a different system call number. At the beginning of interrupt routine 11, extract the system call number from the user stack and switch to the kernel stack. Implement system calls according to the system call number extracted from above step. Steps to implement each system call are explained below. Change back to the user stack and return to the user mode. The system call numbers for Getpid, Getppid, Wait and Signal are 11, 12, 13 and 14 respectively. From ExpL program, these system calls are invoked using exposcall function . Wait System Call \u00b6 Wait system call takes PID of a process (for which the given process will wait) as an argument. Change the MODE FLAG in the process table to the system call number. Extract the PID from the user stack. Check the valid conditions for argument. A process should not wait for itself or a TERMINATED process. The argument PID should be in valid range (what is the valid range ?). If any of the above conditons are not satisfying, return to the user mode with -1 stored as return value indicating failure. At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack. If all valid conditions are satisfied then proceed as follows. Change the state of the current process from RUNNING to the tuple (WAIT_PROCESS, argument PID) in the process table. Note that the STATE field in the process table is a tuple (allocated 2 words). Invoke the scheduler to schedule other processes. The following step is executed only when the scheduler runs this process again, which in turn happens only when the state of the process becomes READY again. Reset the MODE FLAG in the process table of the current process. Store 0 in the user stack as return value and return to the calling program. Signal System Call \u00b6 Signal system call does not have any arguments. Set the MODE FLAG in the process table to the signal system call number. Loop through all process table entries, if there is a process with STATE as tuple (WAIT_PROCESS, current process PID) then change the STATE field to READY. Reset the MODE FLAG to 0 in the process table and store 0 as return value in the user stack. Getpid and Getppid System Calls \u00b6 Getpid and Getppid system calls returns the PID of the current process and the PID of the parent process of the current process respectively to the user program. Implement both these system calls in interrupt routine 11. Note The system calls implemented above are final and will not change later. See algorithms for Wait/Signal and Getpid/Getppid Modifications to Exit Process Function (function number = 3, Process Manager Module) \u00b6 Exit Process function is modified so that it wakes up all the processes waiting for the current process. Similarly, the children of the process are set as orphan processes by changing PPID field of child processes to -1. But when the Exit Process function is invoked from Exec system call, the process is actually not terminating as the new program is being overlayed in the same address space and is executed with the same PID. when Exit Process is invoked from Exec system call, it should not wake up the processes waiting for the current process and also should not set the children as orphan processes. Check the MODE FLAG in the process table of the current process to find out from which system call Exit Process function is invoked. If MODE FLAG field in the process table has system call number not equal to 9 (Exec) implement below steps. Loop through the process table of all processes and change the state to READY for the processes whose state is tuple (WAIT_PROCESS, current PID). Also if the PPID of a process is PID of current process, then invalidate PPID field to -1. Note The function implemented above is final and will not change later. Shutdown system call \u00b6 To ensure graceful termination of the system we will write Shutdown system call with just a HALT instruction. Shutdown system call is implemented in interrupt routine 15. Create an xsm file with just the HALT instruction and load this file as interrupt routine 15. From this stage onwards, we will use a new version of Shell as our init program. This Shell version will invoke Shutdown system call to halt the system. In later stages, when a file system is added to the OS, the file system data will be loaded to the memory and modified, while the OS is running. The Shutdown system call will be re-written so that it commits the changes to the file system data to the disk before the machine halts. Modifications to boot module \u00b6 Load interrupt routine 11 and interrupt routine 15 from disk to memory. See disk and memory organization here . Making things work \u00b6 Compile and load the newly written/modified files to the disk using XFS-interface. Q1. Does the eXpOS guarantees that two processes will not wait for each other i.e. circular wait will not happen No. The present eXpOS does not provide any functionality to avoid circular wait. It is the responsiblity of the user program to make sure that such conditions will not occur. Assignment 1: [Shell Version-II] It is recommended to implement the shell program according to the description given earlier on your own. One implementation of shell program is given here . Load this program as the INIT program. Test the shell version by giving different ExpL programs written in previous stages. Remember to load the xsm files of ExpL programs as executables into the disk before trying to execute them using shell. Assignment 2 Write an ExpL program 'pid.expl' which invokes Getpid system call and prints the pid. Write another ExpL program which invokes Fork system call three times back to back. Then, the program shall use Exec system call to execute pid.xsm file. Run this program using the shell.","title":"Stage 21"},{"location":"roadmap/stage-21/#shell-program","text":"The Shell is a user program that implements an interactive user interface for the OS. In the present stage, we will run the shell as the INIT program, so that the shell will interact with the user. The shell asks you to enter a string (called a command). If the string entered is \"Shutdown\", the program executes the Shutdown system call to halt the OS. Otherwise, the shell program forks and create a child process. The parent process then waits for the child to exit using the Wait system call. The child process will try to execute the command (that is, execute the file with name command.) If no such file exists, Exec fails and the child prints \"BAD COMMAND\" and exits. Otherwise, the command file will be executed. In either case, upon completion of the child process, the parent process wakes up. The parent then goes on to ask the user for the next command.","title":"Shell Program"},{"location":"roadmap/stage-21/#implementation-of-interrupt-routine-11","text":"The system calls Wait , Signal , Getpid and Getppid are all implemented in the interrupt routine 11. Each system call has a different system call number. At the beginning of interrupt routine 11, extract the system call number from the user stack and switch to the kernel stack. Implement system calls according to the system call number extracted from above step. Steps to implement each system call are explained below. Change back to the user stack and return to the user mode. The system call numbers for Getpid, Getppid, Wait and Signal are 11, 12, 13 and 14 respectively. From ExpL program, these system calls are invoked using exposcall function .","title":"Implementation of Interrupt routine 11"},{"location":"roadmap/stage-21/#wait-system-call","text":"Wait system call takes PID of a process (for which the given process will wait) as an argument. Change the MODE FLAG in the process table to the system call number. Extract the PID from the user stack. Check the valid conditions for argument. A process should not wait for itself or a TERMINATED process. The argument PID should be in valid range (what is the valid range ?). If any of the above conditons are not satisfying, return to the user mode with -1 stored as return value indicating failure. At any point of return to user, remember to reset the MODE FLAG and change the stack to user stack. If all valid conditions are satisfied then proceed as follows. Change the state of the current process from RUNNING to the tuple (WAIT_PROCESS, argument PID) in the process table. Note that the STATE field in the process table is a tuple (allocated 2 words). Invoke the scheduler to schedule other processes. The following step is executed only when the scheduler runs this process again, which in turn happens only when the state of the process becomes READY again. Reset the MODE FLAG in the process table of the current process. Store 0 in the user stack as return value and return to the calling program.","title":"Wait System Call"},{"location":"roadmap/stage-21/#signal-system-call","text":"Signal system call does not have any arguments. Set the MODE FLAG in the process table to the signal system call number. Loop through all process table entries, if there is a process with STATE as tuple (WAIT_PROCESS, current process PID) then change the STATE field to READY. Reset the MODE FLAG to 0 in the process table and store 0 as return value in the user stack.","title":"Signal System Call"},{"location":"roadmap/stage-21/#getpid-and-getppid-system-calls","text":"Getpid and Getppid system calls returns the PID of the current process and the PID of the parent process of the current process respectively to the user program. Implement both these system calls in interrupt routine 11. Note The system calls implemented above are final and will not change later. See algorithms for Wait/Signal and Getpid/Getppid","title":"Getpid and Getppid System Calls"},{"location":"roadmap/stage-21/#modifications-to-exit-process-function-function-number-3-process-manager-module","text":"Exit Process function is modified so that it wakes up all the processes waiting for the current process. Similarly, the children of the process are set as orphan processes by changing PPID field of child processes to -1. But when the Exit Process function is invoked from Exec system call, the process is actually not terminating as the new program is being overlayed in the same address space and is executed with the same PID. when Exit Process is invoked from Exec system call, it should not wake up the processes waiting for the current process and also should not set the children as orphan processes. Check the MODE FLAG in the process table of the current process to find out from which system call Exit Process function is invoked. If MODE FLAG field in the process table has system call number not equal to 9 (Exec) implement below steps. Loop through the process table of all processes and change the state to READY for the processes whose state is tuple (WAIT_PROCESS, current PID). Also if the PPID of a process is PID of current process, then invalidate PPID field to -1. Note The function implemented above is final and will not change later.","title":"Modifications to Exit Process Function (function number = 3, Process Manager Module)"},{"location":"roadmap/stage-21/#shutdown-system-call","text":"To ensure graceful termination of the system we will write Shutdown system call with just a HALT instruction. Shutdown system call is implemented in interrupt routine 15. Create an xsm file with just the HALT instruction and load this file as interrupt routine 15. From this stage onwards, we will use a new version of Shell as our init program. This Shell version will invoke Shutdown system call to halt the system. In later stages, when a file system is added to the OS, the file system data will be loaded to the memory and modified, while the OS is running. The Shutdown system call will be re-written so that it commits the changes to the file system data to the disk before the machine halts.","title":"Shutdown system call"},{"location":"roadmap/stage-21/#modifications-to-boot-module","text":"Load interrupt routine 11 and interrupt routine 15 from disk to memory. See disk and memory organization here .","title":"Modifications to boot module"},{"location":"roadmap/stage-21/#making-things-work","text":"Compile and load the newly written/modified files to the disk using XFS-interface. Q1. Does the eXpOS guarantees that two processes will not wait for each other i.e. circular wait will not happen No. The present eXpOS does not provide any functionality to avoid circular wait. It is the responsiblity of the user program to make sure that such conditions will not occur. Assignment 1: [Shell Version-II] It is recommended to implement the shell program according to the description given earlier on your own. One implementation of shell program is given here . Load this program as the INIT program. Test the shell version by giving different ExpL programs written in previous stages. Remember to load the xsm files of ExpL programs as executables into the disk before trying to execute them using shell. Assignment 2 Write an ExpL program 'pid.expl' which invokes Getpid system call and prints the pid. Write another ExpL program which invokes Fork system call three times back to back. Then, the program shall use Exec system call to execute pid.xsm file. Run this program using the shell.","title":"Making things work"},{"location":"roadmap/stage-22/","text":"Learning Objectives Understanding how semaphores help to solve the critical section problem. Add support for semaphores to eXpOS. Pre-requisite Reading Read and understand Resource Sharing and Access Control documentations of eXpOS before proceeding further. In this stage, we will add support for semaphores to the OS. Semaphores are primitives that allow concurrent processes to handle the critical section problem. A typical instance of the critical section problem occurs when a set of processes share memory or files. Here it is likely to be necessary to ensure that the processes do not access the shared data (or file) simultaneously to ensure data consistency. eXpOS provides binary semaphores which can be used by user programs (ExpL programs) to synchronize the access to the shared resources so that data inconsistency will not occur. There are four actions related to semaphores that a process can perform. Below are the actions along with the corresponding eXpOS system calls Acquiring a semaphore - Semget system call Releasing a semaphore - Semrelease system call Locking a semaphore - SemLock system call Unlocking a semaphore - SemUnLock system call To use a semaphore, first a process has to acquire a semaphore. When a process forks, the semaphores currently acquired by a process is shared between the child and the parent. A process can lock and unlock a semaphore only after acquiring the semaphore. The process can lock the semaphore when it needs to enter into the critical section. After exiting from the critical section, the process unlocks the semaphore allowing other processes (with which the semaphore is shared) to enter the critical section. After the use of a semaphore is finished, a process can detach the semaphore by releasing the semaphore. A process maintains record of the semaphores acquired by it in its per-process resource table . eXpOS uses the data structure, semaphore table to manage semaphores. Semaphore table is a global data structure which is used to store details of semaphores currently used by all the processes. The Semaphore table has 32 ( MAX_SEM_COUNT ) entries. This means that only 32 semaphores can be used by all the processes in the system at a time. Each entry in the semaphore table occupies four words of which the last two are currently unused. For each semaphore, the PROCESS COUNT field in it's semaphore table entry keeps track of the number of processes currently sharing the semaphore. If a process locks the semaphore, the LOCKING PID field is set to the PID of that process. LOCKING PID is set to -1 when the semaphore is not locked by any process. An invalid semaphore table entry is indicated by PROCESS COUNT equal to 0. The SPL constant SEMAPHORE_TABLE gives the starting address of the semaphore table in the memory . See semaphore table for more details. The per-process resource table of each process keeps track of the resources (semaphores and files) currently used by the process. The per-process resource table is stored in the last 16 words of the user area page of a process. Per-process resource table can store details of at most eight resources at a time. Hence the total number of semaphores and files acquired by a process at a time is at most eight. Each per process resource table entry contains two words. The first field, called the Resource Identifier field, indicates whether the entry corresponds to a file or a semaphore. For representing the resource as a file, the SPL constant FILE (0) is used and for semaphore, the SPL constant SEMAPHORE (1) is used. The second field stores the index of the semaphore table entry if the resource is a semaphore. (If the resource is a file, an index to the open file table entry will be stored - we will see this in later stages.) See the description of per-process resource table for details. Control flow for Semaphore system calls Implementation of Interrupt routine 13 \u00b6 The system calls Semget and Semrelease are implemented in the interrupt routine 13. Semget and Semrelease has system call numbers 17 and 18 respectively. Extract the system call number from the user stack and switch to the kernel stack. Implement system calls Semget and Semrelease according to the system call number extracted from above step. Steps to implement these system calls are explained below. Change back to the user stack and return to the user mode. Semget System Call \u00b6 Semget system call is used to acquire a new semaphore. Semget finds a free entry in the per-process resource table . Semget then creates a new entry in the semaphore table by invoking the Acquire Semaphore function of resource manager module . The index of the semaphore table entry returned by Acquire Semaphore function is stored in the free entry of per-process resource table of the process. Finally, Semget system call returns the index of newly created entry in the per-process resource table as semaphore descriptor (SEMID). Implement Semget system call using the detailed algorithm provided here . Semrelease System Call \u00b6 Semrelease system call takes semaphore desciptor (SEMID) as argument from user program. Semrelease system call is used to detach a semaphore from the process. Semrelease releases the acquired semaphore and wakes up all the processes waiting for the semaphore by invoking the Release Semaphore function of resource manager module . Semrelease also invalidates the per-process resource table entry corresponding to the SEMID given as an argument. Implement Semrelease system call using the detailed algorithm provided here . Note If any semaphore is not released by a process during execution using Semrelease system call, then the semaphore is released at the time of termination of the process in Exit system call. Acquire Semaphore (function number = 6, resource manager module ) \u00b6 Acquire Semaphore function takes PID of the current process as argument. Acquire Semaphore finds a free entry in the semaphore table and sets the PROCESS COUNT to 1 in that entry. Finally, Acquire Semaphore returns the index of that free entry of semaphore table. Implement Acquire Semaphore function using the detailed algorithm provided in resource manager module link above. Release Semaphore (function number = 7, resource manager module ) \u00b6 Release Semaphore function takes a semaphore index (SEMID) and PID of a process as arguments. If the semaphore to be released is locked by current process, then Release Semaphore function unlocks the semaphore and wakes up all the processes waiting for this semaphore. Release Semaphore function finally decrements the PROCESS COUNT of the semaphore in its corresponding semaphore table entry. Implement Release Semaphore function using the detailed algorithm provided in resource manager module link above. Implementation of Interrupt routine 14 \u00b6 The system calls SemLock and SemUnLock are implemented in the interrupt routine 14. SemLock and SemUnLock has system call numbers 19 and 20 respectively. Extract the system call number from the user stack and switch to the kernel stack. Implement system calls SemLock and SemUnLock according to the system call number extracted from above step. Steps to implement these system calls are explained below. Change back to the user stack and return to the user mode. SemLock System Call \u00b6 SemLock system call takes a semaphore desciptor (SEMID) as an argument from user program. A process locks the semaphore it is sharing using the SemLock system call. If the requested semaphore is currently locked by some other process, the current process blocks its execution by changing its STATE to the tuple (WAIT_SEMAPHORE, semaphore table index of requested semaphore) until the requested semaphore is unlocked. When the semaphore is unlocked, then STATE of the current process is made READY (by the process which has unlocked the semaphore).When the current process is scheduled and the semaphore is still unlocked the current process locks the semaphore by changing the LOCKING PID in the semaphore table entry to the PID of the current process. When the process is scheduled but finds that the semaphore is locked by some other process, current process again waits in the busy loop until the requested semaphore is unlocked. Implement SemLock system call using the detailed algorithm provided here . SemUnLock System Call \u00b6 SemUnLock system call takes a semaphore desciptor (SEMID) as argument. A process invokes SemUnLock system call to unlock the semaphore. SemUnLock invalidates the LOCKING PID field (store -1) in the semaphore table entry for the semaphore. All the processes waiting for the semaphore are made READY for execution. Implement SemUnLock system call using the detailed algorithm provided here . Note The implementation of Semget , Semrelease , SemLock , SemUnLock system calls and Acquire Semaphore , Release Semaphore module functions are final. Modifications to Fork system call \u00b6 In this stage, Fork is modified to update the semaphore table for the semaphores acquired by the parent process. When a process forks, the semaphores acquired by the parent process are now shared between parent and child. To reflect this change, PROCESS COUNT field is incremented by one in the semaphore table entry for every semphore shared between parent and child. Refer algorithm for fork system call . While copying the per-process resource table of parent to the child process do following - If the resource is semaphore (check the Resource Identifier field in the per-process resource table ), then using the sempahore table index, increment the PROCESS COUNT field in the semaphore table entry. Modifications to Free User Area Page (function number = 2, process manager module ) \u00b6 The user area page of every process contains the per-process resource table in the last 16 words. When a process terminates, all the semaphores the process has acquired (and haven't released explicitly) have to be released. This is done in the Free User Area Page function. The ReleaseSemaphore function of resource manager module is invoked for every valid semaphore in the per-process resource table of the process. For each entry in the per-process resource table of the process do following - If the resource is valid and is semaphore (check the Resource Identifier field in the per-process resource table ), then invoke Release Semaphore function of resource manager module . Note Fork system call and Free User Area Page function will be further modified in later stages for the file resources Modifications to boot module \u00b6 Initialize the semaphore table by setting PROCESS COUNT to 0 and LOCKING PID to -1 for all entries. Load interrupt routine 13 and 14 from the disk to the memory. See memory organisation . Making things work \u00b6 Compile and load the newly written/modified files to the disk using XFS-interface. Q1. When a process waiting for a sempahore is scheduled again after the sempahore is unlocked, is it possible that the process finds the sempahore still locked? Yes, it is possible. As some other process waiting for the semaphore could be scheduled before the current process and could have locked the semaphore. In this case the present process finds the semaphore locked again and has to wait in a busy loop until the required sempahore is unlocked. Q2. A process first locks a semaphore using SemLock system call and then forks to create a child. As the semaphore is now shared between child and parent, what will be locking status for the semaphore? The sempahore will still be locked by the parent process. In Fork system call, the PROCESS COUNT in the semaphore table is incremented by one but LOCKING PID field is left untouched. Assignment 1 The reader-writer program given here has two writers and one reader. The parent process will create two child processes by invoking fork. The parent and two child processes share a buffer of one word. At a time only one process can read/write to this buffer. To acheive this, these three processes use a shared semaphore. A writer process can write to the buffer if it is empty and the reader process can only read from the buffer if it is full. Before the word in the buffer is overwritten the reader process must read it and print the word to the console. The parent process is the reader process and its two children are writers. One child process writes even numbers from 1 to 100 and other one writes odd numbers from 1 to 100 to the buffer. The parent process reads the numbers and prints them on to the console. Compile the program given in link above and execute the program using the shell. The program must print all numbers from 1 to 100, but not necessarily in sequential order. Assignment 2 The ExpL programs given here describes a parent.expl program and a child.expl program. The parent.xsm program will create 8 child processes by invoking Fork 3 times. Each of the child processes will print the process ID (PID) and then, invokes the Exec system call to execute the program \"child.xsm\". The child.xsm program stores numbers from PID*100 to PID*100 + 9 onto a linked list and prints them to the console (each child process will have a seperate heap as the Exec system call alocates a seperate heap for each process). Compile the programs given in the link above and execute the parent program (parent.xsm) using the shell. The program must print all numbers from PID*100 to PID*100+9, where PID = 2 to 9, but not necessarily in sequential order. Also, calculate the maximum memory usage, number of disk access and number of context switches (by modifying the OS Kernel code). Assignment 3 The two ExpL programs given here perform merge sort in two different ways. The first one is done in a sequential manner and the second one, in a concurrent approach. Values from 1 to 64 are stored in decreasing order in a linked list and are sorted using a recursive merge sort function. In the concurrent approach, the process is forked and the merge sort function is called recursively for the two sub-lists from the two child processes. Compile the programs given in the link above and execute each of them using the shell. The program must print values from 1 to 64 in a sorted manner. Also, calculate the maximum memory usage, number of contexts switches and the number of switches to KERNEL mode.","title":"Stage 22"},{"location":"roadmap/stage-22/#implementation-of-interrupt-routine-13","text":"The system calls Semget and Semrelease are implemented in the interrupt routine 13. Semget and Semrelease has system call numbers 17 and 18 respectively. Extract the system call number from the user stack and switch to the kernel stack. Implement system calls Semget and Semrelease according to the system call number extracted from above step. Steps to implement these system calls are explained below. Change back to the user stack and return to the user mode.","title":"Implementation of Interrupt routine 13"},{"location":"roadmap/stage-22/#semget-system-call","text":"Semget system call is used to acquire a new semaphore. Semget finds a free entry in the per-process resource table . Semget then creates a new entry in the semaphore table by invoking the Acquire Semaphore function of resource manager module . The index of the semaphore table entry returned by Acquire Semaphore function is stored in the free entry of per-process resource table of the process. Finally, Semget system call returns the index of newly created entry in the per-process resource table as semaphore descriptor (SEMID). Implement Semget system call using the detailed algorithm provided here .","title":"Semget System Call"},{"location":"roadmap/stage-22/#semrelease-system-call","text":"Semrelease system call takes semaphore desciptor (SEMID) as argument from user program. Semrelease system call is used to detach a semaphore from the process. Semrelease releases the acquired semaphore and wakes up all the processes waiting for the semaphore by invoking the Release Semaphore function of resource manager module . Semrelease also invalidates the per-process resource table entry corresponding to the SEMID given as an argument. Implement Semrelease system call using the detailed algorithm provided here . Note If any semaphore is not released by a process during execution using Semrelease system call, then the semaphore is released at the time of termination of the process in Exit system call.","title":"Semrelease System Call"},{"location":"roadmap/stage-22/#acquire-semaphore-function-number-6-resource-manager-module","text":"Acquire Semaphore function takes PID of the current process as argument. Acquire Semaphore finds a free entry in the semaphore table and sets the PROCESS COUNT to 1 in that entry. Finally, Acquire Semaphore returns the index of that free entry of semaphore table. Implement Acquire Semaphore function using the detailed algorithm provided in resource manager module link above.","title":"Acquire Semaphore (function number = 6, resource manager module)"},{"location":"roadmap/stage-22/#release-semaphore-function-number-7-resource-manager-module","text":"Release Semaphore function takes a semaphore index (SEMID) and PID of a process as arguments. If the semaphore to be released is locked by current process, then Release Semaphore function unlocks the semaphore and wakes up all the processes waiting for this semaphore. Release Semaphore function finally decrements the PROCESS COUNT of the semaphore in its corresponding semaphore table entry. Implement Release Semaphore function using the detailed algorithm provided in resource manager module link above.","title":"Release Semaphore (function number = 7, resource manager module)"},{"location":"roadmap/stage-22/#implementation-of-interrupt-routine-14","text":"The system calls SemLock and SemUnLock are implemented in the interrupt routine 14. SemLock and SemUnLock has system call numbers 19 and 20 respectively. Extract the system call number from the user stack and switch to the kernel stack. Implement system calls SemLock and SemUnLock according to the system call number extracted from above step. Steps to implement these system calls are explained below. Change back to the user stack and return to the user mode.","title":"Implementation of Interrupt routine 14"},{"location":"roadmap/stage-22/#semlock-system-call","text":"SemLock system call takes a semaphore desciptor (SEMID) as an argument from user program. A process locks the semaphore it is sharing using the SemLock system call. If the requested semaphore is currently locked by some other process, the current process blocks its execution by changing its STATE to the tuple (WAIT_SEMAPHORE, semaphore table index of requested semaphore) until the requested semaphore is unlocked. When the semaphore is unlocked, then STATE of the current process is made READY (by the process which has unlocked the semaphore).When the current process is scheduled and the semaphore is still unlocked the current process locks the semaphore by changing the LOCKING PID in the semaphore table entry to the PID of the current process. When the process is scheduled but finds that the semaphore is locked by some other process, current process again waits in the busy loop until the requested semaphore is unlocked. Implement SemLock system call using the detailed algorithm provided here .","title":"SemLock System Call"},{"location":"roadmap/stage-22/#semunlock-system-call","text":"SemUnLock system call takes a semaphore desciptor (SEMID) as argument. A process invokes SemUnLock system call to unlock the semaphore. SemUnLock invalidates the LOCKING PID field (store -1) in the semaphore table entry for the semaphore. All the processes waiting for the semaphore are made READY for execution. Implement SemUnLock system call using the detailed algorithm provided here . Note The implementation of Semget , Semrelease , SemLock , SemUnLock system calls and Acquire Semaphore , Release Semaphore module functions are final.","title":"SemUnLock System Call"},{"location":"roadmap/stage-22/#modifications-to-fork-system-call","text":"In this stage, Fork is modified to update the semaphore table for the semaphores acquired by the parent process. When a process forks, the semaphores acquired by the parent process are now shared between parent and child. To reflect this change, PROCESS COUNT field is incremented by one in the semaphore table entry for every semphore shared between parent and child. Refer algorithm for fork system call . While copying the per-process resource table of parent to the child process do following - If the resource is semaphore (check the Resource Identifier field in the per-process resource table ), then using the sempahore table index, increment the PROCESS COUNT field in the semaphore table entry.","title":"Modifications to Fork system call"},{"location":"roadmap/stage-22/#modifications-to-free-user-area-page-function-number-2-process-manager-module","text":"The user area page of every process contains the per-process resource table in the last 16 words. When a process terminates, all the semaphores the process has acquired (and haven't released explicitly) have to be released. This is done in the Free User Area Page function. The ReleaseSemaphore function of resource manager module is invoked for every valid semaphore in the per-process resource table of the process. For each entry in the per-process resource table of the process do following - If the resource is valid and is semaphore (check the Resource Identifier field in the per-process resource table ), then invoke Release Semaphore function of resource manager module . Note Fork system call and Free User Area Page function will be further modified in later stages for the file resources","title":"Modifications to Free User Area Page (function number = 2, process manager module)"},{"location":"roadmap/stage-22/#modifications-to-boot-module","text":"Initialize the semaphore table by setting PROCESS COUNT to 0 and LOCKING PID to -1 for all entries. Load interrupt routine 13 and 14 from the disk to the memory. See memory organisation .","title":"Modifications to boot module"},{"location":"roadmap/stage-22/#making-things-work","text":"Compile and load the newly written/modified files to the disk using XFS-interface. Q1. When a process waiting for a sempahore is scheduled again after the sempahore is unlocked, is it possible that the process finds the sempahore still locked? Yes, it is possible. As some other process waiting for the semaphore could be scheduled before the current process and could have locked the semaphore. In this case the present process finds the semaphore locked again and has to wait in a busy loop until the required sempahore is unlocked. Q2. A process first locks a semaphore using SemLock system call and then forks to create a child. As the semaphore is now shared between child and parent, what will be locking status for the semaphore? The sempahore will still be locked by the parent process. In Fork system call, the PROCESS COUNT in the semaphore table is incremented by one but LOCKING PID field is left untouched. Assignment 1 The reader-writer program given here has two writers and one reader. The parent process will create two child processes by invoking fork. The parent and two child processes share a buffer of one word. At a time only one process can read/write to this buffer. To acheive this, these three processes use a shared semaphore. A writer process can write to the buffer if it is empty and the reader process can only read from the buffer if it is full. Before the word in the buffer is overwritten the reader process must read it and print the word to the console. The parent process is the reader process and its two children are writers. One child process writes even numbers from 1 to 100 and other one writes odd numbers from 1 to 100 to the buffer. The parent process reads the numbers and prints them on to the console. Compile the program given in link above and execute the program using the shell. The program must print all numbers from 1 to 100, but not necessarily in sequential order. Assignment 2 The ExpL programs given here describes a parent.expl program and a child.expl program. The parent.xsm program will create 8 child processes by invoking Fork 3 times. Each of the child processes will print the process ID (PID) and then, invokes the Exec system call to execute the program \"child.xsm\". The child.xsm program stores numbers from PID*100 to PID*100 + 9 onto a linked list and prints them to the console (each child process will have a seperate heap as the Exec system call alocates a seperate heap for each process). Compile the programs given in the link above and execute the parent program (parent.xsm) using the shell. The program must print all numbers from PID*100 to PID*100+9, where PID = 2 to 9, but not necessarily in sequential order. Also, calculate the maximum memory usage, number of disk access and number of context switches (by modifying the OS Kernel code). Assignment 3 The two ExpL programs given here perform merge sort in two different ways. The first one is done in a sequential manner and the second one, in a concurrent approach. Values from 1 to 64 are stored in decreasing order in a linked list and are sorted using a recursive merge sort function. In the concurrent approach, the process is forked and the merge sort function is called recursively for the two sub-lists from the two child processes. Compile the programs given in the link above and execute each of them using the shell. The program must print values from 1 to 64 in a sorted manner. Also, calculate the maximum memory usage, number of contexts switches and the number of switches to KERNEL mode.","title":"Making things work"},{"location":"roadmap/stage-23/","text":"Note Familiarize with eXpOS file system and implemtation. Add support for file creation and deletion to the OS by implementing Create and Delete system calls Pre-requisite Reading It is absolutely necessary to read and understand eXpOS FILE SYSTEM and Implementation Tutorial documentation. Description of data structures- Inode Table , Root file , File(inode) status table and buffer table . In this stage, we will discuss how files are created and deleted by the application program with the help of file system calls Create and Delete . Shutdown system call will be modified in this stage. Create system call creates an empty file with the name given as input. Create system call initializes the disk data structures with meta data related to the file. Inode table and root file are the disk data structures used to maintain permanent record of files. Delete system call deletes the record of the file with the given name from inode table and root file. Delete also releases the disk blocks occupied by the file to be deleted. The Shutdown system call is modified to commit the changes made by Create and Delete system calls in the memory copy of the disk data structures back into the disk. Inode table and root file stores details of every eXpOS file stored in the disk. eXpOS allows at most MAX_FILE_NUM (60) files to be stored in the disk. Hence, both inode table and root file has MAX_FILE_NUM entries. The entry for a file in the inode table is identified by an index of its record in the inode table. For each file, the inode table entry and root file entry should have the same index. The disk data structures have to be loaded from the disk to the memory in order to use them while OS is running. The OS maintains the memory copy of the inode table in memory pages 59 and 60. Also the memory copy of root file is present in memory page 62. See memory organization for more details. Interrupt routine 4 \u00b6 Control flow for Create and Delete system calls The system calls Create and Delete are implemented in the interrupt routine 4. Create and Delete have system call numbers 1 and 4 respectively. From ExpL programs, these system calls are called using exposcall function . Create system call \u00b6 Create system call takes filename and permission (integer 0 or 1) as arguments from the user program. As Create allows to create only data file, it is recommended to use .dat as extension for file names. Create finds a free entry (indicated by -1 in the FILE NAME field) in the inode table to store details related to the new file. The fields in the free inode table entry and corresponding root file entry are initialized with the meta-data of the new file. The USERID field in the inode table is initialized to the USERID field from the process table of the current process. Hence, the user executing the Create system call becomes the owner of the file. The USERNAME field in the root file entry is initialized to the username corresponding to the USERID. The username can be obtained from memory copy of the user table with index as USERID. User table in the disk is initialized by the XFS-interface (during disk formatting) to create two users - kernel and root. Implement Create system call using the detailed algorithm provided here . Delete system call \u00b6 Delete system call takes file name as an argument from the user program. A file can not be deleted if it is currently opened by one or more processes. Delete first acquires the lock on the file by invoking Acquire Inode function from resource manager module . Delete then invalidates the record of the file in entries of the inode table and root file. Also, the blocks allocated to the file are released. Finally, Delete releases the lock on file by invoking Release Inode function of the resource manager module. There is one subtility involved in deleting a file. If any of the disk blocks of the deleted file are in the buffer cache, and if the buffer page is marked dirty, the OS will write back the buffer page into the disk block when another disk block needs to be brought into the same buffer page. However, such write back is unnecessary if the file is deleted (and can even be catastrophic- why?). Hence, Delete system call must clear the dirty bit (in the buffer table) of all the buffered disk blocks of the file. Implement Delete system call using the detailed algorithm provided here . Acquire Inode (function number = 4, resource manager module ) \u00b6 Acquire Inode takes an inode index and PID of a process as arguments. To lock the inode (file), Acquire Inode first waits in a busy loop by changing state to (WAIT_FILE, inode index) until the file becomes free. After the inode becomes free and current process resumes execution, acquire inode checks whether the file is deleted from the system. (This check is necessary because, some other process may delete the file while the current process was waiting for the inode to be free.) Acquire Inode then locks the inode by setting LOCKING PID field in the file status table to the given PID. Implement Acquire Inode function using the detailed algorithm given in the resource manager module link above. Release Inode (function number = 5, resource manager module ) \u00b6 Release Inode takes an inode index and PID of a process as arguments. Release Inode frees the inode (file) by invalidating the LOCKING PID field in the file status table . The function then wakes up the processes waiting for the file with given inode index by changing state of those processes to READY. Implement Release Inode function using the detailed algorithm given in the resource manager module link above. Note The implementation of Create , Delete , Acquire Inode and Release Inode are final. Interrupt routine 15 ( Shutdown system call) \u00b6 Create and Delete system calls update the memory copies of Inode table, disk free list and root file. The changed data structures are not committed into the disk by these system calls. The disk update for these data structures are done during system shutdown. Control flow for Shutdown system call Interrupt routine 15 written in stage 21 contains just HALT instruction. In this stage, Shutdown system call is implemented in the interrupt routine 15. Shutdown system call has system call number 21 and it does not have any arguments. Shutdown system call \u00b6 Switch to the kernel stack and set the MODE FLAG in the process table to the system call number. Shutdown system call can be invoked only from the shell process of the root user. If the current process is not shell (PID in the process table is not equal to 1) or the current user is not root user (USERID in the process table is not equal to 1) then store -1 as return value, reset the MODE FLAG, change the stack to user stack and return to user mode. Commit the changes made in the memory copies of the inode table (along with user table), the root file and the disk free list by storing them back to the disk invoking the Disk Store function of device manager module . Refer to disk/memory organization for block and page numbers of these data structures. Finally, halt the system using the SPL statement halt. Note The implementation of the Shutdown system call is not final. Implementation will change in later stages. Disk Store (function number = 1, Device manager module ) \u00b6 Disk Store function takes PID of a process, a page number and a block number as arguments. To store data into the disk, Disk Store first needs to lock the disk by invoking the Acquire Disk function of the resource manager module . After locking the disk, Disk Store updates the disk status table . Finally, Disk Store initiates the store operation for given page number and block number and waits in WAIT_DISK state until the store operation is complete. When store operation is completed, system raises the disk interrupt which makes this process READY again. Implement Disk Store function using the detailed algorithm given in the device manager module link above. Note The implementation of Disk Store function is final. Modifications to boot module \u00b6 Load interrupt routine 4 and root file from the disk to the memory. See the memory organization here . Initialize the file status table by setting LOCKING PID and FILE OPEN COUNT fields of all entries to -1. Initialize the buffer table by setting BLOCK NUMBER and LOCKING PID fields to -1 and DIRTY BIT to 0 in all entries. At present to simplify the implementation, we consider a single user system with only one user called root, USERID of root is 1. Hence, set the USERID field in the process table of INIT to 1. Later when INIT is forked, the USERID field is copied to the process table of the child process. Making things work \u00b6 Compile and load the newly written/modified files to the disk using XFS-interface. Q1. What is the need for Delete system call to lock the file before deleting it? Locking the file in Delete system call makes sure that some other process will not be able to open the file or perform any other operation on the file during the deletion of the file. Assignment 1 Write an ExpL program to take file name(string) and permission(integer) as input from the console and create a file with the provided input. (It is recommended to have .dat as extension for data files.) Run this program using shell. Using XFS-interface check if the entry for the file is created in inode table and root file. Assignment 2 Write an ExpL program to take file name(string) as input from the console and delete a file with provided input. Run the program using shell. Using XFS-interface check if the entry for the file is deleted from inode table and root file. Check the program for different files- like files created using Create system call, files not present in disk and files loaded using XFS-interface having some data (eg- sample.dat used in stage 2).","title":"Stage 23"},{"location":"roadmap/stage-23/#interrupt-routine-4","text":"Control flow for Create and Delete system calls The system calls Create and Delete are implemented in the interrupt routine 4. Create and Delete have system call numbers 1 and 4 respectively. From ExpL programs, these system calls are called using exposcall function .","title":"Interrupt routine 4"},{"location":"roadmap/stage-23/#create-system-call","text":"Create system call takes filename and permission (integer 0 or 1) as arguments from the user program. As Create allows to create only data file, it is recommended to use .dat as extension for file names. Create finds a free entry (indicated by -1 in the FILE NAME field) in the inode table to store details related to the new file. The fields in the free inode table entry and corresponding root file entry are initialized with the meta-data of the new file. The USERID field in the inode table is initialized to the USERID field from the process table of the current process. Hence, the user executing the Create system call becomes the owner of the file. The USERNAME field in the root file entry is initialized to the username corresponding to the USERID. The username can be obtained from memory copy of the user table with index as USERID. User table in the disk is initialized by the XFS-interface (during disk formatting) to create two users - kernel and root. Implement Create system call using the detailed algorithm provided here .","title":"Create system call"},{"location":"roadmap/stage-23/#delete-system-call","text":"Delete system call takes file name as an argument from the user program. A file can not be deleted if it is currently opened by one or more processes. Delete first acquires the lock on the file by invoking Acquire Inode function from resource manager module . Delete then invalidates the record of the file in entries of the inode table and root file. Also, the blocks allocated to the file are released. Finally, Delete releases the lock on file by invoking Release Inode function of the resource manager module. There is one subtility involved in deleting a file. If any of the disk blocks of the deleted file are in the buffer cache, and if the buffer page is marked dirty, the OS will write back the buffer page into the disk block when another disk block needs to be brought into the same buffer page. However, such write back is unnecessary if the file is deleted (and can even be catastrophic- why?). Hence, Delete system call must clear the dirty bit (in the buffer table) of all the buffered disk blocks of the file. Implement Delete system call using the detailed algorithm provided here .","title":"Delete system call"},{"location":"roadmap/stage-23/#acquire-inode-function-number-4-resource-manager-module","text":"Acquire Inode takes an inode index and PID of a process as arguments. To lock the inode (file), Acquire Inode first waits in a busy loop by changing state to (WAIT_FILE, inode index) until the file becomes free. After the inode becomes free and current process resumes execution, acquire inode checks whether the file is deleted from the system. (This check is necessary because, some other process may delete the file while the current process was waiting for the inode to be free.) Acquire Inode then locks the inode by setting LOCKING PID field in the file status table to the given PID. Implement Acquire Inode function using the detailed algorithm given in the resource manager module link above.","title":"Acquire Inode (function number = 4, resource manager module)"},{"location":"roadmap/stage-23/#release-inode-function-number-5-resource-manager-module","text":"Release Inode takes an inode index and PID of a process as arguments. Release Inode frees the inode (file) by invalidating the LOCKING PID field in the file status table . The function then wakes up the processes waiting for the file with given inode index by changing state of those processes to READY. Implement Release Inode function using the detailed algorithm given in the resource manager module link above. Note The implementation of Create , Delete , Acquire Inode and Release Inode are final.","title":"Release Inode (function number = 5, resource manager module)"},{"location":"roadmap/stage-23/#interrupt-routine-15-shutdown-system-call","text":"Create and Delete system calls update the memory copies of Inode table, disk free list and root file. The changed data structures are not committed into the disk by these system calls. The disk update for these data structures are done during system shutdown. Control flow for Shutdown system call Interrupt routine 15 written in stage 21 contains just HALT instruction. In this stage, Shutdown system call is implemented in the interrupt routine 15. Shutdown system call has system call number 21 and it does not have any arguments.","title":"Interrupt routine 15 ( Shutdown system call)"},{"location":"roadmap/stage-23/#shutdown-system-call","text":"Switch to the kernel stack and set the MODE FLAG in the process table to the system call number. Shutdown system call can be invoked only from the shell process of the root user. If the current process is not shell (PID in the process table is not equal to 1) or the current user is not root user (USERID in the process table is not equal to 1) then store -1 as return value, reset the MODE FLAG, change the stack to user stack and return to user mode. Commit the changes made in the memory copies of the inode table (along with user table), the root file and the disk free list by storing them back to the disk invoking the Disk Store function of device manager module . Refer to disk/memory organization for block and page numbers of these data structures. Finally, halt the system using the SPL statement halt. Note The implementation of the Shutdown system call is not final. Implementation will change in later stages.","title":"Shutdown system call"},{"location":"roadmap/stage-23/#disk-store-function-number-1-device-manager-module","text":"Disk Store function takes PID of a process, a page number and a block number as arguments. To store data into the disk, Disk Store first needs to lock the disk by invoking the Acquire Disk function of the resource manager module . After locking the disk, Disk Store updates the disk status table . Finally, Disk Store initiates the store operation for given page number and block number and waits in WAIT_DISK state until the store operation is complete. When store operation is completed, system raises the disk interrupt which makes this process READY again. Implement Disk Store function using the detailed algorithm given in the device manager module link above. Note The implementation of Disk Store function is final.","title":"Disk Store (function number = 1, Device manager module)"},{"location":"roadmap/stage-23/#modifications-to-boot-module","text":"Load interrupt routine 4 and root file from the disk to the memory. See the memory organization here . Initialize the file status table by setting LOCKING PID and FILE OPEN COUNT fields of all entries to -1. Initialize the buffer table by setting BLOCK NUMBER and LOCKING PID fields to -1 and DIRTY BIT to 0 in all entries. At present to simplify the implementation, we consider a single user system with only one user called root, USERID of root is 1. Hence, set the USERID field in the process table of INIT to 1. Later when INIT is forked, the USERID field is copied to the process table of the child process.","title":"Modifications to boot module"},{"location":"roadmap/stage-23/#making-things-work","text":"Compile and load the newly written/modified files to the disk using XFS-interface. Q1. What is the need for Delete system call to lock the file before deleting it? Locking the file in Delete system call makes sure that some other process will not be able to open the file or perform any other operation on the file during the deletion of the file. Assignment 1 Write an ExpL program to take file name(string) and permission(integer) as input from the console and create a file with the provided input. (It is recommended to have .dat as extension for data files.) Run this program using shell. Using XFS-interface check if the entry for the file is created in inode table and root file. Assignment 2 Write an ExpL program to take file name(string) as input from the console and delete a file with provided input. Run the program using shell. Using XFS-interface check if the entry for the file is deleted from inode table and root file. Check the program for different files- like files created using Create system call, files not present in disk and files loaded using XFS-interface having some data (eg- sample.dat used in stage 2).","title":"Making things work"},{"location":"roadmap/stage-24/","text":"Learning Objectives Understanding buffer cache. Implementation of Open , Close and Read system calls. Pre-requisite Reading Description of data structures - File(inode) status table , Buffer table , Open file table and per-process resource table . In this stage, we will understand the mechanism of opening and closing a file with the help of Open and Close system calls. We will also understand how contents of a file can be read by using Read system call. Fork system call and Free User Area Page function of process manager module are also modified in this stage. Interrupt routine 5 \u00b6 The system calls Open and Close are implemented in the interrupt routine 5. Open and Close have system call numbers 2 and 3 respectively. From ExpL programs, these system calls are called using exposcall function . Control flow for Open and Close system calls Open system call \u00b6 Open system call takes a filename as an argument from the user program. To perform read/write operations on a file, a process must open the file first. Open system call creates a new open instance for the file and returns a file descriptor (index of the new per-process resource table entry created for the open instance). Further operations on the open instance are performed using this file descriptor. A process can open a file several times and each time a different open instance (and new descriptor) is created. The global data structure, Open file table keeps track of all the open file instances in the system. (A new entry is created in this table whenever the Open system call is invoked with any file name.) File status table is a global data structure that maintains an entry for every file in the system (not just opened files). Open system call creates new entries for the file to be opened in the per-process resource table and the open file table. A process keeps track of an open instance by storing the index of the open file table entry of the instance in (the corresponding) resource table entry. When a file is opened, the OPEN INSTANCE COUNT in the open file table is set to 1 and seek position is initialized to the starting of the file (0). Each time when a file is opened, the FILE OPEN COUNT in the file status table entry for the file is incremented by one. Open system call invokes Open function of file manager module to deal with global data structures - file status table and open file table . When a process executes a Fork system call, the open instances of files (and semaphores) created by the process are shared between the current process and its child. As an effect of Fork , the OPEN INSTANCE COUNT in the open file table entry corresponding to the open instance is incremented by one. It is necessary not to be confused between FILE OPEN COUNT (in the file status table) and OPEN INSTANCE COUNT (in the open file table). The former keeps track of the global count of how many times Open system call has been invoked with each file in the system - that is the number of open instances of a file at a given point of time. This count is decremented each time when a Close is invoked on the file by any process. Each open instance could be further shared between multiple processes (via Fork ). OPEN INSTANCE COUNT value of a particular open instance essentially keeps track of this \"share count\". Implement Open system call using the detailed algorithm provided here . Close system call \u00b6 When a process no longer needs to perform read/write operations on an open instance of a file, the open instance may be closed using the Close system call. Even if a process does not explicitly close an open instance by invoking Close system call, the open instance is closed at the termination of the process by Exit system call. Close system call takes a file descriptor (index of the per-process resource table entry) as argument from the user program. Close system call invalidates the per-process resource table entry (corresponding to given file descriptor) by storing -1 in the Resource Identifier field. To decrement share count of the open instance in the open file table and update the file status table accordingly, Close function of file manager module is invoked by the Close system call. Implement Close system call using the detailed algorithm provided here . Open (function number = 3, file manager module ) \u00b6 Open function is invoked by Open system call to update the file status table and the open file table when a file is opened. Open takes a file name as an argument. This function locates the inode index for the file in the inode table and locks the inode before proceeding further. Acquire Inode function of resource manager module is invoked to lock the file. Locking the file is necessary to make sure that no other process tries to delete the file concurrently. Open function creates a new entry in the open file table and returns the index of this entry to the caller. (Note that this index recieved as return value is stored in the per-process resource table entry by the Open system call.) All the fields of the open file table entry are initialized. In case the file is \"root\" file, INODE INDEX field is initialized to the INODE_ROOT (0). Open function increments the FILE OPEN COUNT field by one in the file status table entry for the file, except if the file is \"root\" file. (FILE OPEN COUNT is irrelevent for the root file as the root file is pre-loaded into the memory at boot time and can never be deleted.) The lock on the file is released by invoking Release Inode function of resource manager module before returning to the caller. Implement Open function using the detailed algorithm given in the file manager module link above. Close (function number = 4, file manager module ) \u00b6 Close function is invoked by the Close system call to update the file status table and the open file table when a file is closed. Close takes an open file table index as argument. Close function decrements the share count (i.e OPEN INSTANCE COUNT field in the open file table entry) as the process no longer shares the open instance of the file. When the share count becomes zero, this indicates that all processes sharing that open instance of the file have closed the file. Hence, open file table entry corresponding to that open instance of the file is invalidated by setting the INODE INDEX field to -1 and the open count of the file (FILE OPEN COUNT field in file status table entry) is decremented. Implement Close function using the detailed algorithm given in the file manager module link above. Modifications to Fork system call \u00b6 There is a simple modification required to the Fork System call. When a process forks to create a child process, the file instances currently opened by the parent are now shared between child and parent. To reflect this change, the OPEN INSTANCE COUNT field in the open file table is incremented for each open file instance in the per-process resource table of parent process. While Copying the per-process resource table of parent to the child process do following - If the resource is a file (check the Resource Identifier field in the per-process resource table), then using the open file table index, increment the OPEN INSTANCE COUNT field in the open file table entry. /*The change in Fork system call to update the semaphore table , is already done in stage 22*/ Modifications to Free User Area Page (function number = 2, process manager module ) \u00b6 When a process terminates, all the files the process has opened (and haven't closed explicitly) have to be closed. This is done in the Free User Area page function. The Close function of the file manager module is invoked for every open file in the per-process resource table of the process. For each entry in the per-process resource table of the process, do following - If the resource is valid and is file (check the Resource Identifier field in the per-process resource table), then invoke the Close function of the file manager module . /*The change in the Free User Area Page to release the unrelased semaphores is already done in stage 22*/ Note : The implementation of Open , Close , Fork system calls and Open , Close , Free User Area Page functions are final. Interrupt routine 6 ( Read system call) \u00b6 Interrupt routine 6 written in stage 16 reads data (words) only from the terminal. In this stage, Read system call is modified to read data from files. Read system call has system call number 7. From ExpL programs, Read system call is called using exposcall function . Control flow for reading a word from a file Read system call \u00b6 Read system call takes as input a file descriptor and the address of a word into which data should be read. Read system call locks the inode (corresponding to the file descriptor) at the beginning of the system call and releases the lock at the end of the system call. The functions Acquire Inode and Release Inode of resource manager module are used to lock and release the inode respectively. Read system call reads the word at the position pointed to by the value of LSEEK (in the open file table entry) and stores it into the memory address provided as input. After reading the word from the file, LSEEK is incremented by one. As file data is stored in the disk blocks allocated to the file, in order to read from position pointed to by LSEEK, the disk block containing the word pointed to by LSEEK has to be loaded first into the memory. eXpOS maintains a buffer cache (see memory organization )that can store up to four disk blocks in memory simultaneously. The cache pages are numbered 0,1,2 and 3 and are stored in memory pages 71, 72, 73 and 74. The simple caching scheme we user here is the following. If we want to bring disk block N into memory, the cache page N mod 4 will be used. Hence, if the disk block number to be loaded is - say 195 - then the cache page number to which the block will be noded is 3 and hence, the block will be loaded to page number 74. The functions Buffered Read and Buffered Write of the file manager module are designed to handle buffer management. Read invokes Buffered Read function to bring the required disk block into the memory buffer and read the word present at position LSEEK. Reading from the root file does not require a buffer, as root file is already loaded into the memory at boot-time. Memory copy of the root file is present in memory page 62 and the start address of this page is denoted by the SPL constant ROOT_FILE . The word in the root file at LSEEK position is copied into the address provided. Note that the memory address provided as argument is a logical address, and as system call runs in kernel mode logical address should be translated to physical address before storing data. Read system call needs to lock the resources - Inode (file), buffer and disk before using them. These are locked in the order 1) Inode 2) buffer and 3) disk and released in the reverse order. This order is also followed while writing to a file. Ordering of resource acquisition is imposed in order to avoid processes getting into circular wait for resources. Avoiding circular wait prevents deadlocks . Implement Read system call using detailed algorithm provided here . Buffered Read (function number = 2, file manager module ) \u00b6 Buffered Read takes as input 1) a disk block number, 2) an offset value and 3) a physical memory address. The task of Buffered read is to read a word at position specified by the offset within the given disk block and store it into the given physical memory address. To read a word from a disk block, it has to be present in the memory. Memory buffer cache is used for this purpose. The disk block is loaded (if not loaded already) into the buffer page with buffer number given by formula - (disk block number%4) . To use a buffer page, it has to be locked first by invoking Acquire Buffer function of resource manager module . To load a disk block into a memory buffer page, Buffered Read invokes the function Disk Load of the device manager module . After loading the given disk block into the corresponding buffer, the word present at the given offset in the memory buffer is copied into the address given as argument. The buffer page to which a disk block has to be loaded may contain some other disk block. In such case, if the buffer page has been modified earlier ( dirty bit in the buffer table is set), the disk block present in the buffer has to be stored back into the disk before loading a new disk block. To store a disk block back into the disk, Buffered Read invokes Disk Store function of device manager module. After completion of the read operation, Buffered Read unlocks the buffer page by invoking Release Buffer function of resource manager module . Now that the buffer is unlocked, other processes are allowed to use the buffer. Implement Buffered Read function using the detailed algorithm given in the file manager module link above. Acquire Buffer (function number = 1, resource manager module ) \u00b6 Acquire Buffer takes a buffer number and PID of a process as arguments. This function is invoked by the Buffered Read and Buffered Write functions of the file manager module to lock a buffer before its use. A process needs to acquire a buffer before accessing it to prevent data inconsistency that may arise if other processes are allowed to access the buffer concurrently. Acquire Buffer locks a buffer by storing the given PID in the LOCKING PID field of the buffer table entry corresponding to the given buffer number. If the required buffer is locked by some other process (some other process has set the LOCKING PID), then the process with the given PID is blocked ( STATE is changed to (WAIT_BUFFER, buffer number) in the process table ). The process waits in the blocked state, until the required buffer is free. When the process which has acquired the buffer releases the buffer by invoking Release Buffer function (described next), the state of this blocked process is made READY and Acquire Buffer attempts to lock the buffer again. Implement Acquire Buffer function using the detailed algorithm given in the resource manager module link above. Release Buffer (function number = 2, resource manager module ) \u00b6 A process uses the Release Buffer function to release a buffer page that it has acquired earlier. Release Buffer takes as input the number of a buffer page to be released and the PID of a process. Release Buffer function invalidates the LOCKING PID field (store -1) in the buffer table entry corresponding to the given buffer number. Release Buffer also wakes up all processes waiting for the buffer with given buffer number by changing the STATE in the process table from tuple (WAIT_BUFFER, buffer number) to READY. Implement Release Buffer function using the detailed algorithm given in the resource manager module link above. Note The implementation of Read system call and Buffered Read , Acquire Buffer , Release Buffer functions are final. Modifications to boot module \u00b6 Load interrupt routine 5 and module 3 from the disk to the memory. See the memory organization here . Initialize all entries of the open file table by setting INODE INDEX field to -1 and OPEN INSTANCE COUNT field to 0. Making things work \u00b6 Compile and load the newly written/modified files to the disk using XFS-interface. Assignment 1 Write an ExpL program to take file name as input from the console, read the contents of the file and print to the console. Run this program using shell. Load external data files needed for the program using XFS-interface, as at present eXpOS does not support writing to a file. Check the program with following data files as input - 1) sample.dat from stage 2, 2) \"numbers.dat\" containing numbers 1 to 2047 separated by new line. (You may write a C program to generate the file \"numbers.dat\".) Assignment 2 Run the program provided here using shell. Use data files from previous question as input. The program takes name of a data file as input and opens the file first. It then forks to create child process. The content of the file with shared open instance (shared LSEEK) will be printed to the terminal concurrently by parent and child. A semaphore is used to synchronize the use of the open instance between parent and child.","title":"Stage 24"},{"location":"roadmap/stage-24/#interrupt-routine-5","text":"The system calls Open and Close are implemented in the interrupt routine 5. Open and Close have system call numbers 2 and 3 respectively. From ExpL programs, these system calls are called using exposcall function . Control flow for Open and Close system calls","title":"Interrupt routine 5"},{"location":"roadmap/stage-24/#open-system-call","text":"Open system call takes a filename as an argument from the user program. To perform read/write operations on a file, a process must open the file first. Open system call creates a new open instance for the file and returns a file descriptor (index of the new per-process resource table entry created for the open instance). Further operations on the open instance are performed using this file descriptor. A process can open a file several times and each time a different open instance (and new descriptor) is created. The global data structure, Open file table keeps track of all the open file instances in the system. (A new entry is created in this table whenever the Open system call is invoked with any file name.) File status table is a global data structure that maintains an entry for every file in the system (not just opened files). Open system call creates new entries for the file to be opened in the per-process resource table and the open file table. A process keeps track of an open instance by storing the index of the open file table entry of the instance in (the corresponding) resource table entry. When a file is opened, the OPEN INSTANCE COUNT in the open file table is set to 1 and seek position is initialized to the starting of the file (0). Each time when a file is opened, the FILE OPEN COUNT in the file status table entry for the file is incremented by one. Open system call invokes Open function of file manager module to deal with global data structures - file status table and open file table . When a process executes a Fork system call, the open instances of files (and semaphores) created by the process are shared between the current process and its child. As an effect of Fork , the OPEN INSTANCE COUNT in the open file table entry corresponding to the open instance is incremented by one. It is necessary not to be confused between FILE OPEN COUNT (in the file status table) and OPEN INSTANCE COUNT (in the open file table). The former keeps track of the global count of how many times Open system call has been invoked with each file in the system - that is the number of open instances of a file at a given point of time. This count is decremented each time when a Close is invoked on the file by any process. Each open instance could be further shared between multiple processes (via Fork ). OPEN INSTANCE COUNT value of a particular open instance essentially keeps track of this \"share count\". Implement Open system call using the detailed algorithm provided here .","title":"Open system call"},{"location":"roadmap/stage-24/#close-system-call","text":"When a process no longer needs to perform read/write operations on an open instance of a file, the open instance may be closed using the Close system call. Even if a process does not explicitly close an open instance by invoking Close system call, the open instance is closed at the termination of the process by Exit system call. Close system call takes a file descriptor (index of the per-process resource table entry) as argument from the user program. Close system call invalidates the per-process resource table entry (corresponding to given file descriptor) by storing -1 in the Resource Identifier field. To decrement share count of the open instance in the open file table and update the file status table accordingly, Close function of file manager module is invoked by the Close system call. Implement Close system call using the detailed algorithm provided here .","title":"Close system call"},{"location":"roadmap/stage-24/#open-function-number-3-file-manager-module","text":"Open function is invoked by Open system call to update the file status table and the open file table when a file is opened. Open takes a file name as an argument. This function locates the inode index for the file in the inode table and locks the inode before proceeding further. Acquire Inode function of resource manager module is invoked to lock the file. Locking the file is necessary to make sure that no other process tries to delete the file concurrently. Open function creates a new entry in the open file table and returns the index of this entry to the caller. (Note that this index recieved as return value is stored in the per-process resource table entry by the Open system call.) All the fields of the open file table entry are initialized. In case the file is \"root\" file, INODE INDEX field is initialized to the INODE_ROOT (0). Open function increments the FILE OPEN COUNT field by one in the file status table entry for the file, except if the file is \"root\" file. (FILE OPEN COUNT is irrelevent for the root file as the root file is pre-loaded into the memory at boot time and can never be deleted.) The lock on the file is released by invoking Release Inode function of resource manager module before returning to the caller. Implement Open function using the detailed algorithm given in the file manager module link above.","title":"Open (function number = 3, file manager module )"},{"location":"roadmap/stage-24/#close-function-number-4-file-manager-module","text":"Close function is invoked by the Close system call to update the file status table and the open file table when a file is closed. Close takes an open file table index as argument. Close function decrements the share count (i.e OPEN INSTANCE COUNT field in the open file table entry) as the process no longer shares the open instance of the file. When the share count becomes zero, this indicates that all processes sharing that open instance of the file have closed the file. Hence, open file table entry corresponding to that open instance of the file is invalidated by setting the INODE INDEX field to -1 and the open count of the file (FILE OPEN COUNT field in file status table entry) is decremented. Implement Close function using the detailed algorithm given in the file manager module link above.","title":"Close (function number = 4, file manager module )"},{"location":"roadmap/stage-24/#modifications-to-fork-system-call","text":"There is a simple modification required to the Fork System call. When a process forks to create a child process, the file instances currently opened by the parent are now shared between child and parent. To reflect this change, the OPEN INSTANCE COUNT field in the open file table is incremented for each open file instance in the per-process resource table of parent process. While Copying the per-process resource table of parent to the child process do following - If the resource is a file (check the Resource Identifier field in the per-process resource table), then using the open file table index, increment the OPEN INSTANCE COUNT field in the open file table entry. /*The change in Fork system call to update the semaphore table , is already done in stage 22*/","title":"Modifications to Fork system call"},{"location":"roadmap/stage-24/#modifications-to-free-user-area-page-function-number-2-process-manager-module","text":"When a process terminates, all the files the process has opened (and haven't closed explicitly) have to be closed. This is done in the Free User Area page function. The Close function of the file manager module is invoked for every open file in the per-process resource table of the process. For each entry in the per-process resource table of the process, do following - If the resource is valid and is file (check the Resource Identifier field in the per-process resource table), then invoke the Close function of the file manager module . /*The change in the Free User Area Page to release the unrelased semaphores is already done in stage 22*/ Note : The implementation of Open , Close , Fork system calls and Open , Close , Free User Area Page functions are final.","title":"Modifications to Free User Area Page (function number = 2, process manager module )"},{"location":"roadmap/stage-24/#interrupt-routine-6-read-system-call","text":"Interrupt routine 6 written in stage 16 reads data (words) only from the terminal. In this stage, Read system call is modified to read data from files. Read system call has system call number 7. From ExpL programs, Read system call is called using exposcall function . Control flow for reading a word from a file","title":"Interrupt routine 6 ( Read system call)"},{"location":"roadmap/stage-24/#read-system-call","text":"Read system call takes as input a file descriptor and the address of a word into which data should be read. Read system call locks the inode (corresponding to the file descriptor) at the beginning of the system call and releases the lock at the end of the system call. The functions Acquire Inode and Release Inode of resource manager module are used to lock and release the inode respectively. Read system call reads the word at the position pointed to by the value of LSEEK (in the open file table entry) and stores it into the memory address provided as input. After reading the word from the file, LSEEK is incremented by one. As file data is stored in the disk blocks allocated to the file, in order to read from position pointed to by LSEEK, the disk block containing the word pointed to by LSEEK has to be loaded first into the memory. eXpOS maintains a buffer cache (see memory organization )that can store up to four disk blocks in memory simultaneously. The cache pages are numbered 0,1,2 and 3 and are stored in memory pages 71, 72, 73 and 74. The simple caching scheme we user here is the following. If we want to bring disk block N into memory, the cache page N mod 4 will be used. Hence, if the disk block number to be loaded is - say 195 - then the cache page number to which the block will be noded is 3 and hence, the block will be loaded to page number 74. The functions Buffered Read and Buffered Write of the file manager module are designed to handle buffer management. Read invokes Buffered Read function to bring the required disk block into the memory buffer and read the word present at position LSEEK. Reading from the root file does not require a buffer, as root file is already loaded into the memory at boot-time. Memory copy of the root file is present in memory page 62 and the start address of this page is denoted by the SPL constant ROOT_FILE . The word in the root file at LSEEK position is copied into the address provided. Note that the memory address provided as argument is a logical address, and as system call runs in kernel mode logical address should be translated to physical address before storing data. Read system call needs to lock the resources - Inode (file), buffer and disk before using them. These are locked in the order 1) Inode 2) buffer and 3) disk and released in the reverse order. This order is also followed while writing to a file. Ordering of resource acquisition is imposed in order to avoid processes getting into circular wait for resources. Avoiding circular wait prevents deadlocks . Implement Read system call using detailed algorithm provided here .","title":"Read system call"},{"location":"roadmap/stage-24/#buffered-read-function-number-2-file-manager-module","text":"Buffered Read takes as input 1) a disk block number, 2) an offset value and 3) a physical memory address. The task of Buffered read is to read a word at position specified by the offset within the given disk block and store it into the given physical memory address. To read a word from a disk block, it has to be present in the memory. Memory buffer cache is used for this purpose. The disk block is loaded (if not loaded already) into the buffer page with buffer number given by formula - (disk block number%4) . To use a buffer page, it has to be locked first by invoking Acquire Buffer function of resource manager module . To load a disk block into a memory buffer page, Buffered Read invokes the function Disk Load of the device manager module . After loading the given disk block into the corresponding buffer, the word present at the given offset in the memory buffer is copied into the address given as argument. The buffer page to which a disk block has to be loaded may contain some other disk block. In such case, if the buffer page has been modified earlier ( dirty bit in the buffer table is set), the disk block present in the buffer has to be stored back into the disk before loading a new disk block. To store a disk block back into the disk, Buffered Read invokes Disk Store function of device manager module. After completion of the read operation, Buffered Read unlocks the buffer page by invoking Release Buffer function of resource manager module . Now that the buffer is unlocked, other processes are allowed to use the buffer. Implement Buffered Read function using the detailed algorithm given in the file manager module link above.","title":"Buffered Read (function number = 2, file manager module )"},{"location":"roadmap/stage-24/#acquire-buffer-function-number-1-resource-manager-module","text":"Acquire Buffer takes a buffer number and PID of a process as arguments. This function is invoked by the Buffered Read and Buffered Write functions of the file manager module to lock a buffer before its use. A process needs to acquire a buffer before accessing it to prevent data inconsistency that may arise if other processes are allowed to access the buffer concurrently. Acquire Buffer locks a buffer by storing the given PID in the LOCKING PID field of the buffer table entry corresponding to the given buffer number. If the required buffer is locked by some other process (some other process has set the LOCKING PID), then the process with the given PID is blocked ( STATE is changed to (WAIT_BUFFER, buffer number) in the process table ). The process waits in the blocked state, until the required buffer is free. When the process which has acquired the buffer releases the buffer by invoking Release Buffer function (described next), the state of this blocked process is made READY and Acquire Buffer attempts to lock the buffer again. Implement Acquire Buffer function using the detailed algorithm given in the resource manager module link above.","title":"Acquire Buffer (function number = 1, resource manager module )"},{"location":"roadmap/stage-24/#release-buffer-function-number-2-resource-manager-module","text":"A process uses the Release Buffer function to release a buffer page that it has acquired earlier. Release Buffer takes as input the number of a buffer page to be released and the PID of a process. Release Buffer function invalidates the LOCKING PID field (store -1) in the buffer table entry corresponding to the given buffer number. Release Buffer also wakes up all processes waiting for the buffer with given buffer number by changing the STATE in the process table from tuple (WAIT_BUFFER, buffer number) to READY. Implement Release Buffer function using the detailed algorithm given in the resource manager module link above. Note The implementation of Read system call and Buffered Read , Acquire Buffer , Release Buffer functions are final.","title":"Release Buffer (function number = 2, resource manager module )"},{"location":"roadmap/stage-24/#modifications-to-boot-module","text":"Load interrupt routine 5 and module 3 from the disk to the memory. See the memory organization here . Initialize all entries of the open file table by setting INODE INDEX field to -1 and OPEN INSTANCE COUNT field to 0.","title":"Modifications to boot module"},{"location":"roadmap/stage-24/#making-things-work","text":"Compile and load the newly written/modified files to the disk using XFS-interface. Assignment 1 Write an ExpL program to take file name as input from the console, read the contents of the file and print to the console. Run this program using shell. Load external data files needed for the program using XFS-interface, as at present eXpOS does not support writing to a file. Check the program with following data files as input - 1) sample.dat from stage 2, 2) \"numbers.dat\" containing numbers 1 to 2047 separated by new line. (You may write a C program to generate the file \"numbers.dat\".) Assignment 2 Run the program provided here using shell. Use data files from previous question as input. The program takes name of a data file as input and opens the file first. It then forks to create child process. The content of the file with shared open instance (shared LSEEK) will be printed to the terminal concurrently by parent and child. A semaphore is used to synchronize the use of the open instance between parent and child.","title":"Making things work"},{"location":"roadmap/stage-25/","text":"Learning Objectives Understanding the allocation of disk blocks to a file. Implementation of Write and Seek system calls. Modify Shutdown system call so that file writes are committed to the disk properly. Pre-requisite Reading Description of disk data structures - Inode table and disk free list . Description of memory data structures - Buffer table , Open file table and per-process resource table . In this stage, We will learn how contents of a file are modified using Write system call. Seek system call which is used to change the LSEEK position for a open instance is also implemented in this stage. Shutdown system call is modified to terminate all processes and store back the memory buffers which are modified during Write system call to the disk. Interrupt routine 7 ( Write system call) Interrupt routine 7 written in stage 15, writes data (words) only to the terminal. In this stage, we will modify Write system call to write data into a file. Write system call has system call number 5. From ExpL programs, Write system call is called using exposcall function . Control flow for writing a word to a file Write system call Write system call takes as arguments 1) a file descriptor and 2) a word to be written into the file. Write system call locks the inode at the beginning of the system call and releases the lock at the end of the system call. The functions Acquire Inode and Release Inode of Resource Manager Module are used to lock and release inodes. After acquiring the Inode, Write system call writes the given word to the file, at the offset determined by LSEEK (field in the open file table entry). Previously present data, if any, at the position determined by LSEEK is overwritten by the write operation. The maximum file size permitted by eXpOS is four disk blocks. Hence, Write fails if the LSEEK value exceeds 2047. The Write system call finds the logical block number corresponding to the LSEEK position using the formula LSEEK / 512. LSEEK % 512 gives the offset position in the block to which data must be written into. For example, if the LSEEK value is 1024, then the block number will be 2 (third data block) and the offset is 0. The block numbers of the disk blocks that had been allocated for the file so far are stored in the inode table entry corresponding to the file. In the above example, suppose that the file had been allocated three or more blocks earlier. Then, the physical block number corresponding to logical block number = 2 will have a valid entry in the inode table for the file. Hence, Write system call must bring that block into the buffer and write the data into the required offset position within the block. However, if there is no disk block allocated for logical block number = 2 (that is the file had been allocated only 2 blocks so far), then Write system call must allocate a new block for the file. eXpOS design ensures that the value of LSEEK can never exceed the file size. This ensures that a write operation allocates exactly one new block for a file when the LSEEK value is a multiple of 512 and is equal to the file size (why?). In particular, the first data block for a newly created file is allocated upon the first write into the file. To allocate a new block for the file, Write invokes Get Free Block function of memory manager module . For writing to position LSEEK in the file, the disk block corresponding to position LSEEK has to be present in the memory. To bring the required disk block into the memory buffer and write the given word to position LSEEK, Write invokes Buffered Write function of the file manager module . Buffered Write function expects the physical block number as argument. Write system call finds the physical block number corresponding to the logical block number from the inode table entry of the file. Write (and Delete) fails if the user id of the process calling Write has no access permission to modify the file (see file access permissions ). Since in the present stage the user id of all processes is set to root, Write fails only on the root file and executable files. Implement Write system call using detailed algorithm provided here . Buffered Write (function number = 1, file manager module ) Buffered Write takes a disk block number, offset and a word as arguments. The task of Buffered Write is to write the given word to the given disk block at the position specified by the offset. To write a word to a disk block, the disk block has to be brought into memory. Memory buffer cache is used for this purpose. The disk block is loaded (if not loaded already) into the buffer page with buffer number specified by the formula - (disk block number%4) . To use a buffer page, it has to be locked by invoking Acquire Buffer function of resource manager module . To load a disk block into a memory buffer page, Buffered Write invokes the function Disk Load of device manager module . After loading the given disk block into the corresponding buffer, the given word is written to the memory buffer at the position specified by the offset. As the buffer is modified, the DIRTY BIT in the corresponding buffer table entry is set to 1. Buffered Write may find that, the buffer page to which a disk block has to be loaded contains some other disk block. In such case, if the buffer is modified (dirty bit is set), the disk block present in the buffer is stored back into the disk before loading the new disk block. To store a disk block back into the disk, Buffered Write invokes Disk Store function of the device manager module . Finally, the buffer page is released by invoking Release Buffer function of resource manager module. Implement Buffered Write function using the detailed algorithm given in the file manager module link above. Note [Implementation Hazard] Algorithms of Buffered Write and Buffered Read functions are almost identical, except that in Buffered Write - given word is written to the buffer whereas in Buffered Read - a word is read from the buffer. If your code for file manager module exceeds maximum number of assembly instructions permitted for a eXpOS module (512 instructions), then implement the code for Buffered Read and Buffered Write in a single 'if block' to reduce number of instructions. Get Free Block (function number = 3, memory manager module ) Get Free Block function does not take any argument and returns the block number of a free block in the disk. If no free block is found, Get Free Block returns -1. A free block can be found by searching for a free entry in the disk free list from position DISK_FREE_AREA to DISK_SWAP_AREA-1. A free entry in the disk free list is denoted by 0. In the disk, the blocks from 69 to 255 called User blocks, are reserved for allocation to executable and data files. SPL constant DISK_FREE_AREA gives the starting block number for User blocks. DISK_SWAP_AREA gives the starting block number of swap area. See disk organization . Implement Get Free Block function using the detailed algorithm given in the memory manager module link above. Note The implementation of Write system call and Buffered Write , Get Free Block functions are final. Interrupt routine 5 ( Seek system call) Interrupt routine 5 implements Seek system call along with Open and Close system calls. Seek has system call number 6. From ExpL programs, Seek system call is called using exposcall function . Control flow for Seek system call Seek system call Seek system call is used to move LSEEK pointer value for an open instance according to users requirement. Seek system call takes as argument a file descriptor and an offset from the user program. Seek updates the LSEEK field in the open file table corresponding to the open instance according to the provided offset value. Offset value can be any integer (positive, zero or negative). If the given offset value is 0, then LSEEK field is set to the starting of the file. For a non-zero value of offset, the given offset is added to the current LSEEK value. If the new LSEEK exceeds size of the file, then LSEEK is set to file size. If the new LSEEK position becomes negative, then Seek system call fails and return to user program with appropriate error code without changing the LSEEK position. Implement Seek system call using detailed algorithm provided here . Note The implementation of Seek system call is final. Interrupt routine 15 ( Shutdown system call) Now that eXpOS supports writing to the files, the disk has to be consistent with the modified files before the system shuts down. Shutdown system call is modified in this stage to store back the buffers changed by the Write system call. Shutdown system call also terminates all the processes except current process, IDLE and INIT by invoking Kill All function of process manager module . Finally Shutdown halts the system after disk is made consistent. Control flow for Shutdown system call Modify Shutdown system call (interrupt routine 15) to perform the following addition steps. Invoke Kill All function of process manager module . Kill All terminates all the processes except IDLE, INIT and the process calling Shutdown . For every valid entry in the buffer table (BLOCK NUMBER is not equal to -1), if the DIRTY BIT field is set, then store back the buffer page of that buffer entry into the corresponding disk block by invoking Disk Store function of the device manager module . Implement Shutdown system call using detailed algorithm provided here . Kill All (function number = 5, process manager module ) Kill All function takes PID of a process as an argument. Kill All terminates all the processes except IDLE, INIT and the process with given PID. Kill All first locks all the files present in the inode table by invoking Acquire Inode function of resource manager module for every file. Locking all the inodes makes sure that, no process is in the middle of any file operation. If suppose a process (say A) is using a file and has locked the inode, then the process which has invoked Kill All will wait until process A completes the file operation and releases the inode. After acquiring all the inodes, Kill All terminates all the processes (except IDLE, INIT and process with given PID) by invoking Exit Process function of process manager module for every process. Finally, all the acquired inodes are released by invoking Release Inode function of resource manager module for each valid file. Implement Kill All function using the detailed algorithm given in the process manager module link above. Note The implementation of the Shutdown system call Kill All function is final. Implementation of Shell executable file commands \u00b6 Linux shell support file commands which makes working with files present in the system easier. An example of such file commands that Linux support is \"ls\". (Command \"ls\" lists all the files present in the current directory.) Now that all file related system calls are supported by eXpOS, we can implement few of these commands in eXpOS. This will enrich user experience for handling the files. Support for file commands ls, rm, cp, cat will be added to shell by implementing executable files for the commands. To implement the command ls, write a program ls.expl according to specification given in executable commands/files . Compile this program to generate executable file ls.xsm and load into the disk using XFS-interface. To run command \"ls\", run the executable file ls.xsm from the shell. Implement commands ls, rm, cp, cat as executable files according to the specification of executable commands/files and load into the disk as executable files. Making things work \u00b6 Compile and load the modified files to the disk using XFS-interface. Assignment 1 Write an ExpL program to take file name(string) and permission(integer) as input from the console and create a file with the provided name and permission. Write numbers from 1 to 1100 into the file and print the contents of the file in the reverse order (You will need Seek system call to do this). Run this program using shell. Assignment 2 Write an ExpL program to append numbers from 2000 to 2513 to the file created in first assignment and print the contents of the file in reverse order. Run this program using shell. Assignment 3 Run the program provided here using shell. The program takes a file name and permission as input and creates a new file with given input. It then forks to create two child processes. The two child processes act as writers and parent as reader. A file open instance is shared between two writers and there is separate open instance of the same file for reader. Two writers will write numbers from 1 to 100 into the file, with one writer adding even numbers and other writing odd numbers. The reader reads from the file and prints the data into the console concurrently. To synchronize the use of the shared open file between two writers a semaphore is used. The program prints integers from 1 to 100, not necessarily in sequential order. Assignment 4 Run the program provided here using shell. The program first creates 4 files with values from s to 4*c+s, where s=1..4 and c=0..511. The program then, merges the 4 files taking 2 at a time, and finally, creates a merge.dat file containing numbers from 1 to 2048. Using cat.xsm , print the contents of merge.dat and check whether it contains the numbers from 1 to 2048 in ascending order. POSTSCRIPT: How does an Operating System handle multiple devices in a uniform way? eXpOS supported just one file system and just two devices - the disk and the terminal. The application interface to the file system and the terminal is the same - through the Read/Write system calls. The OS presents a single abstraction (or interface) to the application program for file read/write and console read/write, hiding the fact that these are two completely different hardware devices. Let us review one of the system calls - say the Read system call. The system call code checks whether the read is issued for the terminal or the file system. If the read is from the terminal, then the system call redirects control to the terminal read function of the device manager. If the read is for a disk file, Read system call directly access the file system data structures to perform the system call (with appropriate calls to resource manager, and file manager for performing subtasks - See here ). Such a simple implementation works because eXpOS is dealing with just two devices. A modern OS might be connected to several hard disks and each hard disk may contain separate file systems on different disk partitions. Similarly, a plethora of devices - mouse, printer, USB devices and so on will be connected to the system. New devices may be needed to be connected to the system and the OS shouldn\u2019t require re-design to accommodate each new device! How should then OS design be changed to handle such complexity? The general principle of abstraction holds the key in designing the OS for handling a large number of devices and file systems. We first look at devices. 1. The OS will provide the same set of system calls to access every device - say, Open, Close, Read, Write, Seek, etc. (Some system calls may be vaccus for some devices - for instance, a Read operation on a printer or a Write to a mouse may perform nothing). 2. Open system call invoked with the appropriate device/file name returns a descriptor which shall be used for further Read/Write/Seek operations to the device. 3. The OS expects that the manufacturer of each device supplies a device specific interface software called the device driver . The device driver code for each device must be loaded as part of the OS. The OS expects that each device driver contains functions Open, Close, Read, Write and Seek. For instance, Write function in the print device driver may take as input a word and may contain low level code to issue appropriate command to the printer device to print the word. 4. When an application invokes a system call like Read, the system call handler checks the file descriptor and identifies the correct device. It then invokes the Read function of the appropriate device driver. The principle involved in handling multiple file systems is similar. Each file system will be associated with a corresponding file system driver implementing Open, Close, Read, Write and Seek operations for the corresponding file system. Thus files and devices are handled in a single uniform manner. The advantage of such abstract strategy is that any number of devices can be added to the system, provided device manufacturers and file system designers comply to provide appropriate device/file system drivers with the standard interface stipulated by the OS. The following figure demonstrates the flow of control in device/file operations. Note: Each device will have a programmable device controller hardware that is connected to the machine through a port/serial bus or some such interface. The device driver issues the Write/Read command to the device controller and the device controller in turn commands the device to perform appropriate action to get the task done. Thus, in the case of a printer, the device driver will issue commands to the printer controller, which in turn controls the printer actions. Some additional implementation details and pointers to advanced reading concerning the above abstract principles are described below. 1. All modern file systems support a directory structure for file systems. (This is one major feature missing in eXpOS). In a directory file system, the filename field in the inode entry of a file will be a complete pathname describing the logical directory location of the file in the directory structure of the file system. The last part of the pathname will be the name of the file. For instance, a pathname \u201c/usr/myfiles/hello\u201d specifies a file with name \u201chello\u201d in the directory \u201c/usr/myfiles\u201d. 2. Traditionally Operating systems have a default root file system that supports a directory structure. Other file systems are attached (mounted) as subdirectories of the root file system. When a Read/Write operation is performed on a file, the Read/Write system call checks the pathname of the file to determine which file system driver must be used for Read/Write operations. Devices are also mounted just like file systems.","title":"Stage 25"},{"location":"roadmap/stage-25/#implementation-of-shell-executable-file-commands","text":"Linux shell support file commands which makes working with files present in the system easier. An example of such file commands that Linux support is \"ls\". (Command \"ls\" lists all the files present in the current directory.) Now that all file related system calls are supported by eXpOS, we can implement few of these commands in eXpOS. This will enrich user experience for handling the files. Support for file commands ls, rm, cp, cat will be added to shell by implementing executable files for the commands. To implement the command ls, write a program ls.expl according to specification given in executable commands/files . Compile this program to generate executable file ls.xsm and load into the disk using XFS-interface. To run command \"ls\", run the executable file ls.xsm from the shell. Implement commands ls, rm, cp, cat as executable files according to the specification of executable commands/files and load into the disk as executable files.","title":"Implementation of Shell executable file commands"},{"location":"roadmap/stage-25/#making-things-work","text":"Compile and load the modified files to the disk using XFS-interface. Assignment 1 Write an ExpL program to take file name(string) and permission(integer) as input from the console and create a file with the provided name and permission. Write numbers from 1 to 1100 into the file and print the contents of the file in the reverse order (You will need Seek system call to do this). Run this program using shell. Assignment 2 Write an ExpL program to append numbers from 2000 to 2513 to the file created in first assignment and print the contents of the file in reverse order. Run this program using shell. Assignment 3 Run the program provided here using shell. The program takes a file name and permission as input and creates a new file with given input. It then forks to create two child processes. The two child processes act as writers and parent as reader. A file open instance is shared between two writers and there is separate open instance of the same file for reader. Two writers will write numbers from 1 to 100 into the file, with one writer adding even numbers and other writing odd numbers. The reader reads from the file and prints the data into the console concurrently. To synchronize the use of the shared open file between two writers a semaphore is used. The program prints integers from 1 to 100, not necessarily in sequential order. Assignment 4 Run the program provided here using shell. The program first creates 4 files with values from s to 4*c+s, where s=1..4 and c=0..511. The program then, merges the 4 files taking 2 at a time, and finally, creates a merge.dat file containing numbers from 1 to 2048. Using cat.xsm , print the contents of merge.dat and check whether it contains the numbers from 1 to 2048 in ascending order. POSTSCRIPT: How does an Operating System handle multiple devices in a uniform way? eXpOS supported just one file system and just two devices - the disk and the terminal. The application interface to the file system and the terminal is the same - through the Read/Write system calls. The OS presents a single abstraction (or interface) to the application program for file read/write and console read/write, hiding the fact that these are two completely different hardware devices. Let us review one of the system calls - say the Read system call. The system call code checks whether the read is issued for the terminal or the file system. If the read is from the terminal, then the system call redirects control to the terminal read function of the device manager. If the read is for a disk file, Read system call directly access the file system data structures to perform the system call (with appropriate calls to resource manager, and file manager for performing subtasks - See here ). Such a simple implementation works because eXpOS is dealing with just two devices. A modern OS might be connected to several hard disks and each hard disk may contain separate file systems on different disk partitions. Similarly, a plethora of devices - mouse, printer, USB devices and so on will be connected to the system. New devices may be needed to be connected to the system and the OS shouldn\u2019t require re-design to accommodate each new device! How should then OS design be changed to handle such complexity? The general principle of abstraction holds the key in designing the OS for handling a large number of devices and file systems. We first look at devices. 1. The OS will provide the same set of system calls to access every device - say, Open, Close, Read, Write, Seek, etc. (Some system calls may be vaccus for some devices - for instance, a Read operation on a printer or a Write to a mouse may perform nothing). 2. Open system call invoked with the appropriate device/file name returns a descriptor which shall be used for further Read/Write/Seek operations to the device. 3. The OS expects that the manufacturer of each device supplies a device specific interface software called the device driver . The device driver code for each device must be loaded as part of the OS. The OS expects that each device driver contains functions Open, Close, Read, Write and Seek. For instance, Write function in the print device driver may take as input a word and may contain low level code to issue appropriate command to the printer device to print the word. 4. When an application invokes a system call like Read, the system call handler checks the file descriptor and identifies the correct device. It then invokes the Read function of the appropriate device driver. The principle involved in handling multiple file systems is similar. Each file system will be associated with a corresponding file system driver implementing Open, Close, Read, Write and Seek operations for the corresponding file system. Thus files and devices are handled in a single uniform manner. The advantage of such abstract strategy is that any number of devices can be added to the system, provided device manufacturers and file system designers comply to provide appropriate device/file system drivers with the standard interface stipulated by the OS. The following figure demonstrates the flow of control in device/file operations. Note: Each device will have a programmable device controller hardware that is connected to the machine through a port/serial bus or some such interface. The device driver issues the Write/Read command to the device controller and the device controller in turn commands the device to perform appropriate action to get the task done. Thus, in the case of a printer, the device driver will issue commands to the printer controller, which in turn controls the printer actions. Some additional implementation details and pointers to advanced reading concerning the above abstract principles are described below. 1. All modern file systems support a directory structure for file systems. (This is one major feature missing in eXpOS). In a directory file system, the filename field in the inode entry of a file will be a complete pathname describing the logical directory location of the file in the directory structure of the file system. The last part of the pathname will be the name of the file. For instance, a pathname \u201c/usr/myfiles/hello\u201d specifies a file with name \u201chello\u201d in the directory \u201c/usr/myfiles\u201d. 2. Traditionally Operating systems have a default root file system that supports a directory structure. Other file systems are attached (mounted) as subdirectories of the root file system. When a Read/Write operation is performed on a file, the Read/Write system call checks the pathname of the file to determine which file system driver must be used for Read/Write operations. Devices are also mounted just like file systems.","title":"Making things work"},{"location":"roadmap/stage-26/","text":"Learning Objectives Adding support in eXpOS to manage multiple users. Implementation of multi-user system calls. Pre-requisite Reading It is absolutely necessary to read and understand multi-user management and implementation documentation. Description of data structures- User Table Description of special processes - Init (Login) and Shell process . In this stage, we will enable eXpOS to handle multiple users by implementing multi-user system calls . Newusr and Remusr system calls are implemented to create new users and delete existing users in the system. The data structure called user table is maintained to store user name and encrypted password of each user in the system. The index of the user table entry for a user is the USERID for the user. Two special users called \"kernel\" (USERID = 0) and \"root\" (USERID = 1) are already initialized in the user table at the time of disk formatting (executing fdisk command in XFS-interface). Password of \"kernel\" is unspecified and \"root\" user is given default password \"root\" (The user table will store the encrypted form of the string \"root\"). System calls Setpwd , Getuname and Getuid are also implemented in this stage. Login and Logout system calls are implemented to enable users to login into the system and logout from the system. From this stage onwards, we will modify the INIT process to work as a special login process , running with PID=1 and owned by the kernel (user id is set to 0). Login process enables users to login into the system with their user name and password. After a user logs into the system, the OS (the login system call) will schedule the shell process with PID=2. The shell will run in the context of the logged in user (that is, user id of the shell will be set to the user id of the logged in user). Note that the address space for the shell process would be already set up in the memory by the OS boot code. Hence the login process simply sets the shell process to ready state and invoke the scheduler to start its execution. The Shell program will be modified in this stage to support built-in shell commands . Interrupt routine 17 \u00b6 The Login system call is implemented in the interrupt routine 17. Login has system call number 27. From ExpL programs, this system call is called using exposcall function . Login system call Login system call takes two arguments 1) a user name (string) and 2) an unencrypted password (string). Login system call can only be invoked from the login process (PID = 1). The init process of eXpOS is called login process. Login process will ask the user to enter user name and password from the console and invokes Login system call with provided login credentials. To login a user into the system, Login system call checks whether the user with given user name and password is present in the user table or not. Note that the password given as input is unencrypted and should be encrypted (using encrypt statement ) before comparing to ENCRYPTED PASSWORD field in the user table. Login system call fails if the user with given user name and password is not found. When a user with given login credentials is found, Login system call makes the shell process (PID = 2) ready for execution by changing the STATE field in the process table entry of shell process to CREATED. Although, login process does not explicitly invoke Fork and Exec system calls to create child, conceptually login process is considered as parent of shell process. So the PPID field in the process table entry of shell process is set to PID of login process (PID = 1). Also, login process must wait for shell process to terminate, so STATE of login process is changed to the tuple (WAIT_PROCESS, PID of shell). Then, Scheduler is invoked in order to schedule shell process for execution. Note that the shell process is already loaded into the address space in boot module so Login system call is not required to load shell process into the memory. Implement Login system call using detailed algorithm provided here . Note The implementation of Login system call is final. Interrupt routine 12 \u00b6 The Logout system call is implemented in the interrupt routine 12. Logout has system call number 28. From ExpL programs, this system call is called using exposcall function . Logout system call Control flow for Logout system call Logout system call is used to logout the current user from the system and does not take any arguments. Logout system call can only be executed from the shell process (PID = 2). Before leaving the system, all the non-terminated processes of the user should be terminated. As a consequence of terminating the processes, the resources acquired by these processes will be released. Logout system call invokes Kill All function of process manager module to terminate the processes. Recall that Kill All function terminates all processes in the system except idle, init (login) and the current process. Logout system call changes the STATE of current process (shell) to TERMINATED. The starting IP of the shell process is stored at first word of user stack of shell, so that the next time when a new user is logged in and shell process is scheduled for the first time in the context of the new user, shell will run as newly created process. Login process (PID = 1) is made ready for execution and scheduler is invoked to schedule login process. Implement Logout system call using detailed algorithm provided here . Note The implementation of Logout system call is final. Interrupt routine 16 \u00b6 The system calls Newusr , Remusr , Setpwd , Getuname and Getuid are implemented in the interrupt routine 16. Newusr , Remusr , Setpwd , Getuname and Getuid have system call numbers 22, 23, 24, 25, 26 respectively. From ExpL programs, these system calls are called using exposcall function . Newusr system call A user name and an unencrypted text password are arguments to the Newusr system call. Newusr system call can only be invoked from the shell process of the root user. Newusr finds a free entry for the new user in the user table and initialize this entry with the provided user name and password. The password is encrypted (using encrypt statement ) before storing it into the user table. Implement Newusr system call using detailed algorithm provided here . Remusr system call Remusr system call takes the user name of the user to be removed as an argument. Remusr system call can only be invoked from the shell process of the root user. A user can not be removed from the system if the user is the owner of one or more files in the system. To remove a user from the system, Remusr system call invalidates the entry in the user table corresponding to given username by storing -1 in the USERNAME and ENCRYPTED PASSWORD fields. Note that the special users \"root\" and \"kernel\" can not be removed using Remusr system call. Implement Remusr system call using detailed algorithm provided here . Setpwd system call Setpwd changes the password of a user to newly provided password. It takes as arguments a user name and a new password from application program. Setpwd can only be executed by shell process. A user is permitted to change only its own password. The privileged user \"root\" has permission to change the password of any user. The \"root\" user is provided the default password \"root\". The password of root user can be changed later using Setpwd . Setpwd encrypts the provided password and replaces the ENCRYPTED PASSWORD field in the user table entry corresponding to provided user name. Implement Setpwd system call using detailed algorithm provided here . Getuname and Getuid system calls Getuname takes as argument a USERID from user program. Getuname returns the user name of the given USERID from the user table . Getuid takes a user name (string) as an argument from the user program. Getuid returns the USERID of the given user name. The system calls Getuname and Getuid can be executed from any process of any user. Implement Getuid and Getuname system calls using detailed algorithms provided here . Note The implementation of Newusr , Remusr , Setpwd , Getuname and Getuid system calls are final. Modification to Shutdown system call \u00b6 There is a slight modification in Shutdown system call. Shutdown system call can only be invoked from shell process. Until this stage, shell process was loaded as init program with PID = 1, but now login process is loaded as init and shell is loaded with PID = 2. So in Shutdown system call, modify the condition to check whether current process is shell or not, by comparing current PID to 2 (instead of the previous value 1). Note The implementation of Shutdown system call is final. Modifications to boot module and OS startup code \u00b6 The boot module is modified to initialize the Shell process. Shell process has PID equal to 2. The process table entry and page table with index as 2 is initialized in the boot module for shell process. Heap, user stack and kernel stack pages are also allocated for the shell. The boot module will set the shell process to TERMINATED state so that it will not be scheduled. The state of the shell process will be set to CREATED by the login system call when a valid user is logged in. This ensures that the shell process is scheduled only after a valid user is logged in. Implementation Note Since Idle, Shell and Login processes are system processes that does pre-defined functionality, it is easy to design ExpL programs for them so that 1) they require no heap pages 2) Idle and login (init) processes require only one user stack page each 3) Idle and login code will fit into just one code page each (shell will be hard to implement without two pages of code). Hence, we will modify the boot code so as to allocate only one stack page apart from the user area page and code pages for Idle and Login processes. Shell process will be allocated two stack pages. Note that the memory organization allocates two pages each for Idle and Login. Since the code for Idle and Login can fit into just one page, the second page can be allocated for their user stack. Kernel stack pages will have to be allocated in the free memory area. This leads to better memory utilization so that more concurrent processes may be run with the available memory. The page table entries for unallocated heap pages, stack page and code pages must be set to invalid. Steps to be done in the OS startup code to reflect the above changes are described below: \u00b6 Changes for idle process allocation Load only the first code page from disk to memory (instead of two code pages). See disk/memory organization . Allocate second code page (70) as user stack page for idle (only one page for user stack is needed). Allocate memory page 76 for kernel stack of idle. Change the page table entries for stack and code pages according to above allocation. Also change the user area page number in the process table entry of idle. Store the starting IP address from the header of the first code page on the top of new user stack as the user stack page number is changed now for idle. Steps to be done in the boot module to reflect the above changes are described below: \u00b6 Load shell process, int 16, int 12 (Logout), int 17 from disk to memory. See disk and memory organization here . Changes for init process allocation Load only the first code page from disk to memory (instead of two code pages). See disk/memory organization . Allocate second code page (66) as user stack page for init (only one page for user stack is needed). Allocate memory page 77 for kernel stack of init. Invalidate the heap page entries in the page table of the INIT process. Change the page table entries for stack and code pages according to above allocation. Also change the user area page number in the process table entry of init. Store the starting IP address from the header of the first code page on the top of new user stack as the user stack page number is changed now for init. Remove disk map table initialization for the init process as it is not needed any longer. Shell process allocation Load two code pages from disk to memory. See disk/memory organization . Allocate memory pages 78 and 79 for user stack of shell. Also allocate memory page 80 for kernel stack of shell. Set the library page entries to 63 and 64 in the page table of shell. Invalidate the heap page entries in the page table. Initialize the page table entries for stack and code pages according to above allocation. Also change the user area page number in the process table entry of shell. Initialize the process table entry of the shell process (PID = 2) as follows- Set the STATE field to TERMINATED. Store PID and PPID fields to 2 and 1 respectively. Store the kernel stack page number allocated above in the USER AREA PAGE NUMBER field. Set the KERNEL STACK POINTER field to 0 and USER STACK POINTER to 8*512. Also initialize PTBR and PTLR fields for the shell process. Initialize the disk map table entry of the shell process (PID = 2) as follows - Store the block numbers of the two code pages in the disk map table entry of the shell. Invalidate all other entries of the disk map table entry by storing -1. Store the starting IP address from the header of the first code page on the top of user stack for the shell process. Note that shell process is set up for execution but STATE of the shell process is set to TERMINATED in the boot module. The shell process will be made READY only upon successful login of the user. Change the initialization of memory free list according to the memory pages allocated for idle, init and shell processes. Update the MEM_FREE_COUNT in the system status table to 47 as now 47 memory pages are available. Login program \u00b6 Login program is run as the Init process from this stage onwards. This program asks user for a user name and a password to log into the system. Login process uses Login system call to log in the user into the system. This is repeated in a loop. Write login program using the pseudocode provided here and load the XSM excutable as init program using XFS-interface . Extended Shell program \u00b6 Shell program is improvised to support the built-in shell commands and XSM executable commands/files according to the specification provided in eXpOS shell specification . An implementation of the ExpL shell program is given here . Compile and load this program as shell into the disk using XFS-interface . This program will be run as shell when a user logs into the system. Now that multiple user related system calls are supported in eXpOS, the shell commands - \"lu\" and \"ru\" can be implemented. Implement commands lu, ru as executable files according to the specification of executable commands/files and load into the disk as executable files. Making things work \u00b6 Compile and load the newly written/modified files to the disk using XFS-interface. Q1. Why Newusr , Remusr and Setpwd system calls are permitted to execute only from shell program whereas Getuid and Getuname can be executed from any application program? The system calls Newusr , Remusr and Setpwd modify the data related to users in the user table. Getuid and Getuname system calls only access data related to users. As application programs other than Shell are not allowed to modify the user related data, system calls Newusr , Remusr , Setpwd are only executed from shell process. Assignment 1 Test the system calls, login and shell process by performing following sequence of actions - Login into the system as root user and change the password of root user using Setpwd command Create new user using Newusr command Log out from system Login as newly created user Create new files and perform file operations on them List all users using \"lu.xsm\" executable file Logout and again login as root user Remove files owned by the new user using excutable file command \"ru.xsm\" from the shell of root. You can further test the system by running all build-in shell commands and excutable files commands to make sure that implementation is correct.","title":"Stage 26"},{"location":"roadmap/stage-26/#interrupt-routine-17","text":"The Login system call is implemented in the interrupt routine 17. Login has system call number 27. From ExpL programs, this system call is called using exposcall function . Login system call Login system call takes two arguments 1) a user name (string) and 2) an unencrypted password (string). Login system call can only be invoked from the login process (PID = 1). The init process of eXpOS is called login process. Login process will ask the user to enter user name and password from the console and invokes Login system call with provided login credentials. To login a user into the system, Login system call checks whether the user with given user name and password is present in the user table or not. Note that the password given as input is unencrypted and should be encrypted (using encrypt statement ) before comparing to ENCRYPTED PASSWORD field in the user table. Login system call fails if the user with given user name and password is not found. When a user with given login credentials is found, Login system call makes the shell process (PID = 2) ready for execution by changing the STATE field in the process table entry of shell process to CREATED. Although, login process does not explicitly invoke Fork and Exec system calls to create child, conceptually login process is considered as parent of shell process. So the PPID field in the process table entry of shell process is set to PID of login process (PID = 1). Also, login process must wait for shell process to terminate, so STATE of login process is changed to the tuple (WAIT_PROCESS, PID of shell). Then, Scheduler is invoked in order to schedule shell process for execution. Note that the shell process is already loaded into the address space in boot module so Login system call is not required to load shell process into the memory. Implement Login system call using detailed algorithm provided here . Note The implementation of Login system call is final.","title":"Interrupt routine 17"},{"location":"roadmap/stage-26/#interrupt-routine-12","text":"The Logout system call is implemented in the interrupt routine 12. Logout has system call number 28. From ExpL programs, this system call is called using exposcall function . Logout system call Control flow for Logout system call Logout system call is used to logout the current user from the system and does not take any arguments. Logout system call can only be executed from the shell process (PID = 2). Before leaving the system, all the non-terminated processes of the user should be terminated. As a consequence of terminating the processes, the resources acquired by these processes will be released. Logout system call invokes Kill All function of process manager module to terminate the processes. Recall that Kill All function terminates all processes in the system except idle, init (login) and the current process. Logout system call changes the STATE of current process (shell) to TERMINATED. The starting IP of the shell process is stored at first word of user stack of shell, so that the next time when a new user is logged in and shell process is scheduled for the first time in the context of the new user, shell will run as newly created process. Login process (PID = 1) is made ready for execution and scheduler is invoked to schedule login process. Implement Logout system call using detailed algorithm provided here . Note The implementation of Logout system call is final.","title":"Interrupt routine 12"},{"location":"roadmap/stage-26/#interrupt-routine-16","text":"The system calls Newusr , Remusr , Setpwd , Getuname and Getuid are implemented in the interrupt routine 16. Newusr , Remusr , Setpwd , Getuname and Getuid have system call numbers 22, 23, 24, 25, 26 respectively. From ExpL programs, these system calls are called using exposcall function . Newusr system call A user name and an unencrypted text password are arguments to the Newusr system call. Newusr system call can only be invoked from the shell process of the root user. Newusr finds a free entry for the new user in the user table and initialize this entry with the provided user name and password. The password is encrypted (using encrypt statement ) before storing it into the user table. Implement Newusr system call using detailed algorithm provided here . Remusr system call Remusr system call takes the user name of the user to be removed as an argument. Remusr system call can only be invoked from the shell process of the root user. A user can not be removed from the system if the user is the owner of one or more files in the system. To remove a user from the system, Remusr system call invalidates the entry in the user table corresponding to given username by storing -1 in the USERNAME and ENCRYPTED PASSWORD fields. Note that the special users \"root\" and \"kernel\" can not be removed using Remusr system call. Implement Remusr system call using detailed algorithm provided here . Setpwd system call Setpwd changes the password of a user to newly provided password. It takes as arguments a user name and a new password from application program. Setpwd can only be executed by shell process. A user is permitted to change only its own password. The privileged user \"root\" has permission to change the password of any user. The \"root\" user is provided the default password \"root\". The password of root user can be changed later using Setpwd . Setpwd encrypts the provided password and replaces the ENCRYPTED PASSWORD field in the user table entry corresponding to provided user name. Implement Setpwd system call using detailed algorithm provided here . Getuname and Getuid system calls Getuname takes as argument a USERID from user program. Getuname returns the user name of the given USERID from the user table . Getuid takes a user name (string) as an argument from the user program. Getuid returns the USERID of the given user name. The system calls Getuname and Getuid can be executed from any process of any user. Implement Getuid and Getuname system calls using detailed algorithms provided here . Note The implementation of Newusr , Remusr , Setpwd , Getuname and Getuid system calls are final.","title":"Interrupt routine 16"},{"location":"roadmap/stage-26/#modification-to-shutdown-system-call","text":"There is a slight modification in Shutdown system call. Shutdown system call can only be invoked from shell process. Until this stage, shell process was loaded as init program with PID = 1, but now login process is loaded as init and shell is loaded with PID = 2. So in Shutdown system call, modify the condition to check whether current process is shell or not, by comparing current PID to 2 (instead of the previous value 1). Note The implementation of Shutdown system call is final.","title":"Modification to Shutdown system call"},{"location":"roadmap/stage-26/#modifications-to-boot-module-and-os-startup-code","text":"The boot module is modified to initialize the Shell process. Shell process has PID equal to 2. The process table entry and page table with index as 2 is initialized in the boot module for shell process. Heap, user stack and kernel stack pages are also allocated for the shell. The boot module will set the shell process to TERMINATED state so that it will not be scheduled. The state of the shell process will be set to CREATED by the login system call when a valid user is logged in. This ensures that the shell process is scheduled only after a valid user is logged in. Implementation Note Since Idle, Shell and Login processes are system processes that does pre-defined functionality, it is easy to design ExpL programs for them so that 1) they require no heap pages 2) Idle and login (init) processes require only one user stack page each 3) Idle and login code will fit into just one code page each (shell will be hard to implement without two pages of code). Hence, we will modify the boot code so as to allocate only one stack page apart from the user area page and code pages for Idle and Login processes. Shell process will be allocated two stack pages. Note that the memory organization allocates two pages each for Idle and Login. Since the code for Idle and Login can fit into just one page, the second page can be allocated for their user stack. Kernel stack pages will have to be allocated in the free memory area. This leads to better memory utilization so that more concurrent processes may be run with the available memory. The page table entries for unallocated heap pages, stack page and code pages must be set to invalid.","title":"Modifications to boot module and OS startup code"},{"location":"roadmap/stage-26/#steps-to-be-done-in-the-os-startup-code-to-reflect-the-above-changes-are-described-below","text":"Changes for idle process allocation Load only the first code page from disk to memory (instead of two code pages). See disk/memory organization . Allocate second code page (70) as user stack page for idle (only one page for user stack is needed). Allocate memory page 76 for kernel stack of idle. Change the page table entries for stack and code pages according to above allocation. Also change the user area page number in the process table entry of idle. Store the starting IP address from the header of the first code page on the top of new user stack as the user stack page number is changed now for idle.","title":"Steps to be done in the OS startup code to reflect the above changes are described below:"},{"location":"roadmap/stage-26/#steps-to-be-done-in-the-boot-module-to-reflect-the-above-changes-are-described-below","text":"Load shell process, int 16, int 12 (Logout), int 17 from disk to memory. See disk and memory organization here . Changes for init process allocation Load only the first code page from disk to memory (instead of two code pages). See disk/memory organization . Allocate second code page (66) as user stack page for init (only one page for user stack is needed). Allocate memory page 77 for kernel stack of init. Invalidate the heap page entries in the page table of the INIT process. Change the page table entries for stack and code pages according to above allocation. Also change the user area page number in the process table entry of init. Store the starting IP address from the header of the first code page on the top of new user stack as the user stack page number is changed now for init. Remove disk map table initialization for the init process as it is not needed any longer. Shell process allocation Load two code pages from disk to memory. See disk/memory organization . Allocate memory pages 78 and 79 for user stack of shell. Also allocate memory page 80 for kernel stack of shell. Set the library page entries to 63 and 64 in the page table of shell. Invalidate the heap page entries in the page table. Initialize the page table entries for stack and code pages according to above allocation. Also change the user area page number in the process table entry of shell. Initialize the process table entry of the shell process (PID = 2) as follows- Set the STATE field to TERMINATED. Store PID and PPID fields to 2 and 1 respectively. Store the kernel stack page number allocated above in the USER AREA PAGE NUMBER field. Set the KERNEL STACK POINTER field to 0 and USER STACK POINTER to 8*512. Also initialize PTBR and PTLR fields for the shell process. Initialize the disk map table entry of the shell process (PID = 2) as follows - Store the block numbers of the two code pages in the disk map table entry of the shell. Invalidate all other entries of the disk map table entry by storing -1. Store the starting IP address from the header of the first code page on the top of user stack for the shell process. Note that shell process is set up for execution but STATE of the shell process is set to TERMINATED in the boot module. The shell process will be made READY only upon successful login of the user. Change the initialization of memory free list according to the memory pages allocated for idle, init and shell processes. Update the MEM_FREE_COUNT in the system status table to 47 as now 47 memory pages are available.","title":"Steps to be done in the boot module to reflect the above changes are described below:"},{"location":"roadmap/stage-26/#login-program","text":"Login program is run as the Init process from this stage onwards. This program asks user for a user name and a password to log into the system. Login process uses Login system call to log in the user into the system. This is repeated in a loop. Write login program using the pseudocode provided here and load the XSM excutable as init program using XFS-interface .","title":"Login program"},{"location":"roadmap/stage-26/#extended-shell-program","text":"Shell program is improvised to support the built-in shell commands and XSM executable commands/files according to the specification provided in eXpOS shell specification . An implementation of the ExpL shell program is given here . Compile and load this program as shell into the disk using XFS-interface . This program will be run as shell when a user logs into the system. Now that multiple user related system calls are supported in eXpOS, the shell commands - \"lu\" and \"ru\" can be implemented. Implement commands lu, ru as executable files according to the specification of executable commands/files and load into the disk as executable files.","title":"Extended Shell program"},{"location":"roadmap/stage-26/#making-things-work","text":"Compile and load the newly written/modified files to the disk using XFS-interface. Q1. Why Newusr , Remusr and Setpwd system calls are permitted to execute only from shell program whereas Getuid and Getuname can be executed from any application program? The system calls Newusr , Remusr and Setpwd modify the data related to users in the user table. Getuid and Getuname system calls only access data related to users. As application programs other than Shell are not allowed to modify the user related data, system calls Newusr , Remusr , Setpwd are only executed from shell process. Assignment 1 Test the system calls, login and shell process by performing following sequence of actions - Login into the system as root user and change the password of root user using Setpwd command Create new user using Newusr command Log out from system Login as newly created user Create new files and perform file operations on them List all users using \"lu.xsm\" executable file Logout and again login as root user Remove files owned by the new user using excutable file command \"ru.xsm\" from the shell of root. You can further test the system by running all build-in shell commands and excutable files commands to make sure that implementation is correct.","title":"Making things work"},{"location":"roadmap/stage-27/","text":"Learning Objectives Understand the disk swap-out and swap-in mechanisms. Implement the pager module that supports Swap in and Swap out functions. Pre-requisite Reading Revisit the description of data structures- Process table , Page table , System status table , Disk Map table . In this stage, we will learn how the limited physical memory pages of the XSM machine can be used effectively to run the maximum number of concurrent processes. To achieve this, we will implement the functions Swap Out and Swap In of Pager module (Module 6). Corresponding modifications are done in Timer Interrupt and Context Switch module as well. eXpOS gives provision to execute 16 processes concurrently in the system and the number of memory pages available for user processes are 52 (from 76 to 127 - See memory organization ). Consider a case, where every process uses four code, two heap, two user stack and one kernel stack pages. Then each process will need 9 memory pages. In this situation, the OS will run out of memory before all 16 processes can be brought into the memory, as the memory required will be 144 pages in total. A solution to this problem is following - when the OS falls short of free memory pages needed for a process, try to identify some inactive process whose memory pages could be swapped out to the disk. The memory pages freed this way can be allocated to the new process. At a later point of time, the OS can swap back the swapped out pages when the inactive process needs to be re-activated. This gives illusion of more memory than actual available memory. (Also see Virtual Memory .) eXpOS uses an approach for memory management where the system does not wait for all the memory to become completely exhausted before initiating a process swap out. Instead, the OS regularly checks for the status of available memory. At any time if the OS finds that the available (free) memory drops below a critical level, a swap out is initiated. In such case, the OS identifies a relatively inactive process and swaps out some of the pages of the process to make more free memory available. The critical level in eXpOS is denoted by MEM_LOW (MEM_LOW is equal to 4 in present design). When available memory pages are less than MEM_LOW, eXpOS calls Swap Out function of pager module . Swap Out function selects a suitable process to swap out to the disk. The memory pages used by the selected process are moved into the disk blocks and the memory pages (except the memory pages of the library) are released. The code pages are not required to be copied to the disk as the disk already contains a copy of the code pages. The kernel stack page of a process is also not swapped out by eXpOS. However, the heap and the user stack pages are swapped out into the disk. eXpOS has 256 reserved blocks in the disk (256 to 511 - see disk organization ) for swapping purpose. This area is called swap area . A swapped out process is swapped back into memory, when one of the following events occur: 1) A process has remained in swapped out state for more than a threshold amount of time. 2) The available memory pages exceed certain level denoted by MEM_HIGH (MEM_HIGH is set to 12 in present design). Each process has an associated TICK value (see process table ) which is reset whenever the process is swapped out. The TICK value is incremented every time the system enters the timer interrupt routine. If the TICK value of a swapped out process exceeds the value MAX_TICK , the OS decides that the process must be swapped in. A second condition when the OS decides that a process can be swapped in is when the available number of free memory pages (see MEM_FREE_COUNT in system status table ) exceeds the value MEM_HIGH. When does the OS check for MEM_LOW/MEM_HIGH condition? This is done in the timer interrupt handler . Since the system enters the timer routine at regular intervals, this design ensures that regular monitoring of TICK/MEM_FREE_COUNT is achieved. We will modify the timer interrupt handler in the following way. Whenever it is entered from the context of any process except a special swapper daemon process (to be described later), the handler will inspect the TICK status of the swapped out processes and the memory availability status in the system status table to decide whether a swap-in/swap-out must be initiated. If swap-in/swap-out is needed, the timer will set the PAGING_STATUS field in the system status table to SWAP_IN/SWAP_OUT appropriately to inform the scheduler about the need for a swap-in/swap-out. The timer handler then passes control to the scheduler. Note that the timer does not initiate any swap-in/swap-out now. We will describe the actions performed when the timer interrupt handler is entered from the context of the swapper daemon soon below. We will modify the eXpOS scheduler to schedule the swapper daemon whenever PAGING_STATUS field in the system status table is set to SWAP_IN/SWAP_OUT. The OS reserves PID=15 for the swapper daemon process. (Thus the swapper daemon joins login, shell and idle processess as special processess initiated by the kernel.) The swapper daemon shares the code of the idle process, and is essentially a duplicate idle process running with a different PID. Its sole purpose is to set up a user context for swapping operations. A consequence of the introduction of the swapper daemon is that only 12 user applications can run concurrently now. If the timer interrupt handler is entered from the context of the swapper daemon, then it will call the Swap-in/Swap-out functions of the pager module after inspecting the value of PAGING_STATUS in the system status table. Thus, swap-in/swap out will be initiated by the timer interrupt handler only from the context of the swapper daemon. While swapping is ongoing, the swapper daemon may get blocked when swap-in/swap-out operation waits for a disk-memory transfer. The OS scheduler will run the Idle process in such case. Note that the Idle process will never get blocked, and can always be scheduled whenever no other process is ready to run. Once a swap-in/swap-out is initiated from the timer, the OS scheduler will not schedule any process other than the swapper daemon or the idle process until the swap-in/swap-out is completed. This policy is taken to avoid unpredicatable conditions that can arise if other processes rapidly acquire/release memory and change the memory availability in the system while a swap operation is ongoing. This design, though not very efficient, is simple to implement and yet achieves the goal of having the full quota of 16 process in concurrent execution. (Note that the size of the process table in the eXpOS implementation outlined here limits the number of concurrent processes to 16). The algorithms for Swap-in and Swap-out are implemented in the Pager Module (Module 6). Modifications to Timer Interrupt \u00b6 Control flow for timer interrupt Timer interrupt handler is modified as follows: The handler must check whether the current process is the swapper daemon . This condition can happen only when a swap operation is to be initiated. In this case, PAGING_STATUS field of the system status table must be checked and Swap_in/Swap_out function of the pager module must be invoked appropriately (SWAP_OUT = 1 and SWAP_IN = 2). If the current process is the idle process, there are two possibilities. If swapping is ongoing (check PAGING_STATUS), one can infer that Idle was scheduled because the swapper daemon was blocked. In this case, the timer must invoke the scheduler. (The scheduler will run Idle again if the daemon is not unblocked. Otherwise, the daemon will be scheduled.) The second possibility is that swapping was not on-going. This case is not different from the condition to be checked when timer is entered from any process other than the paging process, and will be descibed next. Generally, when the timer handler is entered from a process when scheduling was not on, the handler must decide whether normal scheduling shall continue or swap-in/swap-out must be inititiated. Swap-in must be initiated if the value of MEM_FREE COUNT in the system status table is below MEM_LOW. Swap-out must be inititated if either a) memory availability is high (MEM_FREE_COUNT value exceeds MEM_HIGH) or b) some swapped process has TICK value exceeding the threshold MAX_TICK. Another modification in the Timer interrupt is to increment the TICK field in the process table of every NON-TERMINATED process. When a process is created by the Fork system call, the TICK value of the process is set to 0 in the process table. Each time the system enters the timer interrupt handler, the TICK value of the process is incremented. The TICK value of a process is reset to zero whenever the process is swapped out or swapped in. Thus the tick value of a process that is not swapped out indicates for how long that process had been in memory without being swapped out. Similarly, the tick value of a swapped out process indicates how long the process had been in swapped state. The swap-in/swap-out algorithms will use the value of TICK to determine the process which had been in swapped state (or not swapped state) for the longest time for swapping in (or out). Modify Timer Interrupt implemented in earlier stages according to the detailed algorithm given here . Pager Module (Module 6) \u00b6 Pager module is responsible for selecting processes to swap-out/swap-in and also to conduct the swap-out/swap-in operations for effective memory management. Swap Out (function number = 1, Pager module ) Control flow for Swap Out Swap Out function is invoked from the timer interrupt handler and does not take any arguments. As mentioned earlier, the timer interrupt handler will invoke Swap Out only from the context of the Swapper Daemon . Swap Out function first chooses a suitable process for swapping out into the disk. The processes which are not running and are in WAIT_PROCESS or WAIT_SEMAPHORE state are considered first for swapping out (why?). When no such process is found, the process which has stayed longest in the memory is selected for swapping out into the disk. To detect the processes which has stayed longest in the memory, the TICK field in the process table is used. Thus the process with the highest TICK is selected for swapping out. Now that, a process is selected to swap out, the TICK field for the selected process is initialized to 0. (From now on, the TICK field must count for what amount of time the process has been in memory). The code pages for the swapping-out process are released and the page table entries of the code pages are invalidated. The process selected for swapping out, can have shared heap pages. To simplify implementation, shared heap pages are not swapped out into the disk. Again, to simplify implementation, the kernel stack page is also not swapped out. Non-shared heap pages and user stack pages are stored in the swap area in the disk. Get Swap Block function of the memory manager module is invoked to find free blocks in the swap area. These memory pages are stored into the allocated disk blocks by invoking Disk Store function of the device manager module and disk map table is updated with the disk numbers of corresponding pages. Memory pages of the process are released using Release Page function of memory manager module and page table entries for these swapped out pages are invalidated. Also the SWAP FLAG in the process table of the swapped out process is set to 1, indicating that the process is swapped out. Finally, the PAGING_STATUS in the System Status Table is reset to 0. This step informs the scheduler that the swap operation is complete and normal scheduling can be resumed. Implement Swap Out function using the detailed algorithm given in the pager module link above. Swap In (function number = 2, Pager module ) Control flow for Swap In Swap In function is invoked from the timer interrupt handler and does not take any arguments. The Swap In function selects a swapped out process to be brought back to memory. The process which has stayed for longest time in the disk and is ready to run is selected. That is, the process with the highest TICK among the swapped-out READY processes is selected). Now that, a process is selected to be swapped back into the memory, the TICK field for the selected process is initialized to 0. Code pages of the process are not loaded into the memory, as these pages can be loaded later when exception occurs during execution of the process. Free memory pages for the heap and user stack are allocated using the Get Free Page function of the memory manager module and disk blocks of the process are loaded into these memory pages using the Disk Load function of the device manager module . The Page table is updated for the new heap and user stack pages. The swap disk blocks used by these pages are released using Release Block function of the memory manager module and Disk map table is invalidated for these pages. Also the SWAP FLAG in the process table of the swapped in process is set to 0, indicating that the process is no longer swapped out. Finally, the PAGING_STATUS in the System Status Table is reset to 0. This step informs the scheduler that the swap operation is complete and normal scheduling can be resumed. Implement Swap In function using the detailed algorithm given in the pager module link above. Implementation Hazard There is a possibility that the code of the Pager module will exceed more than 2 disk blocks (more than 512 instructions). Try to write optimized code to fit the pager module code in 2 blocks. You can use the following strategy to reduce the number of instructions. According to given algorithm for Swap Out function, the actions done for code pages, heap pages, user stack pages are written separately. This results in calling Release Page function 2 times, Get Swap Block and Disk Store functions 2 times each. Combine these actions into a single while loop where each module function is called only once. The loop should traverse through the page table entries one by one (except library page entries) and perform appropriate actions if the page table entry for a page is valid. Apply similar strategy for Swap In function also. Get Swap Block (function number = 6, Memory Manager Module ) Get Swap Block function does not take any arguments. The function returns a free block from the swap area (disk blocks 256 to 511 - see disk organization ) of the eXpOS. Get Swap Block searches for a free block from DISK_SWAP_AREA (starting of disk swap area) to DISK_SIZE -1 (ending of the eXpOS disk). If a free block is found, the block number is returned. If no free block in swap area is found, -1 is returned to the caller. Implement Get Swap Block function using the detailed algorithm given in the memory manager module link above. Note The implementation of module functions Swap Out , Swap In and Get Swap Block are final. Modification to Context Switch Module (Module 5) \u00b6 Previously, the Context Switch module (scheduler module) would select a new process to schedule according to the Round Robin scheduling algorithm. The procedure for selecting a process to execute is slightly modified in this stage. If swap-in/swap-out is ongoing (that is, if the PAGING_STATUS field of the system status table is set), the context switch module schedules the Swapper Daemon (PID = 15) whenever it is not blocked . If the swapper daemon is blocked (for some disk operation), then the idle process (PID = 0) must be scheduled. (The OS design disallows scheduling any process except Idle and Swapper daemon when swapping is on-going.) If the PAGING_STATUS is set to 0, swapping is not on-going and hence the next READY/CREATED process which is not swapped out is scheduled in normal Round Robin order. Finally, if no process is in READY or CREATED state, then the idle process is scheduled. Modify Context Switch module implemented in earlier stages according to the detailed algorithm given here . Modifications to OS Startup Code \u00b6 Modify OS Startup Code to initialize the process table and page table for the Swapper Daemon (similar to the Idle Process). The final algorithm is given here . Modifications to boot module \u00b6 Modify Boot module to add the following steps : Load module 6 (Pager Module) form disk to memory. See disk/memory organization . Initialize the SWAPPED_COUNT field to 0 and PAGING_STATUS field to 0 in the system status table to 0, as initially there are no swapped out processes. Initialize the TICK field to 0 for all the 16 process table entries. Update the MEM_FREE_COUNT to 45 in the system status table . (The 2 pages are allocated for the user/kernel stack for Swapper Daemon reducing the number from 47 to 45). Why only READY state processes are selected for swap in, even though swapped out processes can be in blocked state also? It is not very useful to swap in a process which is in blocked state into the memory. As the process is in blocked state, even after swapping in, the process will not execute until it is made READY. Until the process is made READY, it will just occupy memory pages which could be used for some other READY/RUNNING process. Assignment 1 Write an ExpL program which invokes Fork system call four times back to back. Then, the program shall use Exec system call to execute pid.xsm file (used in stage 21 ) to print the PID of the processes. Invoking four Forks back to back is supposed to create 16 new processes, but only 12 new processes will be created as eXpOS will run out of process table entries. Run this program using the shell in the context of a user. Assignment 2 Run the program provided here using shell in the context of a user. The program given in the given link will first read a delay parameter and then, call the Fork system call and create 12 processes. Each process prints numbers from PID*100 to PID*100 + 7. After printing each number, a delay function is called with the the delay parameter provided. Assignment 3 Run the program provided here using shell in the context of a user. The program will create a file with name as \"num.dat\" and permission as open access . Integers 1 to 1200 are written to this file and file is closed. The program will then invoke Fork system call four times, back to back to create 12 processes and Exec system call is invoked with file \"pgm1.xsm\". The program for \"pgm1.xsm\" is provided here . \"pgm1.xsm\" will create a new file according to the PID of the process and read 100 numbers from file \"num.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 consecutive numbers (PID-3)*100+1 to (PID-3)*100+100. Assignment 4 Run the program provided here using shell in the context of a user. The program will create a file with name as \"numbers.dat\" and permission as open access and open the file. The program also invokes Semget for a shared semaphore. The program will then invoke Fork system call four times, back to back to create 12 processes. The 12 processes now share a file open instance and a semaphore. Each process will write 100 numbers consecutively (PID*1000+1 to PID*1000+100) to the file \"numbers.dat\". Each process then invokes the Exec system call to run the program \"pgm2.xsm\". The program for \"pgm2.xsm\" is provided here . \"pgm2.xsm\" will create a new file according to the PID of the process and read 100 numbers from file \"numbers.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 numbers from X*1000 to X*1000+99, where X \u2208 {3,4..15}. The numbers written by a process in the newly created file need not be the same numbers the process has written in \"numbers.dat\" file. Assignment 5 Run the program ( merge.expl ) provided here using shell in the context of a user. The merge.expl program, first stores numbers from 1 to 512 in a random order into a file merge.dat . It then forks and executes m_store.expl which creates 8 files temp{i}.dat , where i=1..8 and stores 64 numbers each from merge.expl . Then, all the temporary files are sorted by executing m_sort.expl . Next, the first ExpL program forks and executes m_merge.expl which merges all the temporary files back into merge.dat and finally, prints the contents of the file in ascending order. If all the system calls in your OS implementation works correctly, then numbers 1 to 512 will be printed out in order. Note To run the program provided by the user, Shell process first invokes fork to create a child process. Shell will wait until this first child process completes its execution. When the first child exits, shell will resume execution even if some processes created by the given program are running in the background. This can lead to the following interesting situation. Suppose that all active processes execept idle, login and shell were swapped out and the XSM simulator is waiting for terminal input from the user into the shell. In this case, you will have to issue some command to the shell, so that the system keeps on running.","title":"Stage 27"},{"location":"roadmap/stage-27/#modifications-to-timer-interrupt","text":"Control flow for timer interrupt Timer interrupt handler is modified as follows: The handler must check whether the current process is the swapper daemon . This condition can happen only when a swap operation is to be initiated. In this case, PAGING_STATUS field of the system status table must be checked and Swap_in/Swap_out function of the pager module must be invoked appropriately (SWAP_OUT = 1 and SWAP_IN = 2). If the current process is the idle process, there are two possibilities. If swapping is ongoing (check PAGING_STATUS), one can infer that Idle was scheduled because the swapper daemon was blocked. In this case, the timer must invoke the scheduler. (The scheduler will run Idle again if the daemon is not unblocked. Otherwise, the daemon will be scheduled.) The second possibility is that swapping was not on-going. This case is not different from the condition to be checked when timer is entered from any process other than the paging process, and will be descibed next. Generally, when the timer handler is entered from a process when scheduling was not on, the handler must decide whether normal scheduling shall continue or swap-in/swap-out must be inititiated. Swap-in must be initiated if the value of MEM_FREE COUNT in the system status table is below MEM_LOW. Swap-out must be inititated if either a) memory availability is high (MEM_FREE_COUNT value exceeds MEM_HIGH) or b) some swapped process has TICK value exceeding the threshold MAX_TICK. Another modification in the Timer interrupt is to increment the TICK field in the process table of every NON-TERMINATED process. When a process is created by the Fork system call, the TICK value of the process is set to 0 in the process table. Each time the system enters the timer interrupt handler, the TICK value of the process is incremented. The TICK value of a process is reset to zero whenever the process is swapped out or swapped in. Thus the tick value of a process that is not swapped out indicates for how long that process had been in memory without being swapped out. Similarly, the tick value of a swapped out process indicates how long the process had been in swapped state. The swap-in/swap-out algorithms will use the value of TICK to determine the process which had been in swapped state (or not swapped state) for the longest time for swapping in (or out). Modify Timer Interrupt implemented in earlier stages according to the detailed algorithm given here .","title":"Modifications to Timer Interrupt"},{"location":"roadmap/stage-27/#pager-module-module-6","text":"Pager module is responsible for selecting processes to swap-out/swap-in and also to conduct the swap-out/swap-in operations for effective memory management. Swap Out (function number = 1, Pager module ) Control flow for Swap Out Swap Out function is invoked from the timer interrupt handler and does not take any arguments. As mentioned earlier, the timer interrupt handler will invoke Swap Out only from the context of the Swapper Daemon . Swap Out function first chooses a suitable process for swapping out into the disk. The processes which are not running and are in WAIT_PROCESS or WAIT_SEMAPHORE state are considered first for swapping out (why?). When no such process is found, the process which has stayed longest in the memory is selected for swapping out into the disk. To detect the processes which has stayed longest in the memory, the TICK field in the process table is used. Thus the process with the highest TICK is selected for swapping out. Now that, a process is selected to swap out, the TICK field for the selected process is initialized to 0. (From now on, the TICK field must count for what amount of time the process has been in memory). The code pages for the swapping-out process are released and the page table entries of the code pages are invalidated. The process selected for swapping out, can have shared heap pages. To simplify implementation, shared heap pages are not swapped out into the disk. Again, to simplify implementation, the kernel stack page is also not swapped out. Non-shared heap pages and user stack pages are stored in the swap area in the disk. Get Swap Block function of the memory manager module is invoked to find free blocks in the swap area. These memory pages are stored into the allocated disk blocks by invoking Disk Store function of the device manager module and disk map table is updated with the disk numbers of corresponding pages. Memory pages of the process are released using Release Page function of memory manager module and page table entries for these swapped out pages are invalidated. Also the SWAP FLAG in the process table of the swapped out process is set to 1, indicating that the process is swapped out. Finally, the PAGING_STATUS in the System Status Table is reset to 0. This step informs the scheduler that the swap operation is complete and normal scheduling can be resumed. Implement Swap Out function using the detailed algorithm given in the pager module link above. Swap In (function number = 2, Pager module ) Control flow for Swap In Swap In function is invoked from the timer interrupt handler and does not take any arguments. The Swap In function selects a swapped out process to be brought back to memory. The process which has stayed for longest time in the disk and is ready to run is selected. That is, the process with the highest TICK among the swapped-out READY processes is selected). Now that, a process is selected to be swapped back into the memory, the TICK field for the selected process is initialized to 0. Code pages of the process are not loaded into the memory, as these pages can be loaded later when exception occurs during execution of the process. Free memory pages for the heap and user stack are allocated using the Get Free Page function of the memory manager module and disk blocks of the process are loaded into these memory pages using the Disk Load function of the device manager module . The Page table is updated for the new heap and user stack pages. The swap disk blocks used by these pages are released using Release Block function of the memory manager module and Disk map table is invalidated for these pages. Also the SWAP FLAG in the process table of the swapped in process is set to 0, indicating that the process is no longer swapped out. Finally, the PAGING_STATUS in the System Status Table is reset to 0. This step informs the scheduler that the swap operation is complete and normal scheduling can be resumed. Implement Swap In function using the detailed algorithm given in the pager module link above. Implementation Hazard There is a possibility that the code of the Pager module will exceed more than 2 disk blocks (more than 512 instructions). Try to write optimized code to fit the pager module code in 2 blocks. You can use the following strategy to reduce the number of instructions. According to given algorithm for Swap Out function, the actions done for code pages, heap pages, user stack pages are written separately. This results in calling Release Page function 2 times, Get Swap Block and Disk Store functions 2 times each. Combine these actions into a single while loop where each module function is called only once. The loop should traverse through the page table entries one by one (except library page entries) and perform appropriate actions if the page table entry for a page is valid. Apply similar strategy for Swap In function also. Get Swap Block (function number = 6, Memory Manager Module ) Get Swap Block function does not take any arguments. The function returns a free block from the swap area (disk blocks 256 to 511 - see disk organization ) of the eXpOS. Get Swap Block searches for a free block from DISK_SWAP_AREA (starting of disk swap area) to DISK_SIZE -1 (ending of the eXpOS disk). If a free block is found, the block number is returned. If no free block in swap area is found, -1 is returned to the caller. Implement Get Swap Block function using the detailed algorithm given in the memory manager module link above. Note The implementation of module functions Swap Out , Swap In and Get Swap Block are final.","title":"Pager Module (Module 6)"},{"location":"roadmap/stage-27/#modification-to-context-switch-module-module-5","text":"Previously, the Context Switch module (scheduler module) would select a new process to schedule according to the Round Robin scheduling algorithm. The procedure for selecting a process to execute is slightly modified in this stage. If swap-in/swap-out is ongoing (that is, if the PAGING_STATUS field of the system status table is set), the context switch module schedules the Swapper Daemon (PID = 15) whenever it is not blocked . If the swapper daemon is blocked (for some disk operation), then the idle process (PID = 0) must be scheduled. (The OS design disallows scheduling any process except Idle and Swapper daemon when swapping is on-going.) If the PAGING_STATUS is set to 0, swapping is not on-going and hence the next READY/CREATED process which is not swapped out is scheduled in normal Round Robin order. Finally, if no process is in READY or CREATED state, then the idle process is scheduled. Modify Context Switch module implemented in earlier stages according to the detailed algorithm given here .","title":"Modification to Context Switch Module (Module 5)"},{"location":"roadmap/stage-27/#modifications-to-os-startup-code","text":"Modify OS Startup Code to initialize the process table and page table for the Swapper Daemon (similar to the Idle Process). The final algorithm is given here .","title":"Modifications to OS Startup Code"},{"location":"roadmap/stage-27/#modifications-to-boot-module","text":"Modify Boot module to add the following steps : Load module 6 (Pager Module) form disk to memory. See disk/memory organization . Initialize the SWAPPED_COUNT field to 0 and PAGING_STATUS field to 0 in the system status table to 0, as initially there are no swapped out processes. Initialize the TICK field to 0 for all the 16 process table entries. Update the MEM_FREE_COUNT to 45 in the system status table . (The 2 pages are allocated for the user/kernel stack for Swapper Daemon reducing the number from 47 to 45). Why only READY state processes are selected for swap in, even though swapped out processes can be in blocked state also? It is not very useful to swap in a process which is in blocked state into the memory. As the process is in blocked state, even after swapping in, the process will not execute until it is made READY. Until the process is made READY, it will just occupy memory pages which could be used for some other READY/RUNNING process. Assignment 1 Write an ExpL program which invokes Fork system call four times back to back. Then, the program shall use Exec system call to execute pid.xsm file (used in stage 21 ) to print the PID of the processes. Invoking four Forks back to back is supposed to create 16 new processes, but only 12 new processes will be created as eXpOS will run out of process table entries. Run this program using the shell in the context of a user. Assignment 2 Run the program provided here using shell in the context of a user. The program given in the given link will first read a delay parameter and then, call the Fork system call and create 12 processes. Each process prints numbers from PID*100 to PID*100 + 7. After printing each number, a delay function is called with the the delay parameter provided. Assignment 3 Run the program provided here using shell in the context of a user. The program will create a file with name as \"num.dat\" and permission as open access . Integers 1 to 1200 are written to this file and file is closed. The program will then invoke Fork system call four times, back to back to create 12 processes and Exec system call is invoked with file \"pgm1.xsm\". The program for \"pgm1.xsm\" is provided here . \"pgm1.xsm\" will create a new file according to the PID of the process and read 100 numbers from file \"num.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 consecutive numbers (PID-3)*100+1 to (PID-3)*100+100. Assignment 4 Run the program provided here using shell in the context of a user. The program will create a file with name as \"numbers.dat\" and permission as open access and open the file. The program also invokes Semget for a shared semaphore. The program will then invoke Fork system call four times, back to back to create 12 processes. The 12 processes now share a file open instance and a semaphore. Each process will write 100 numbers consecutively (PID*1000+1 to PID*1000+100) to the file \"numbers.dat\". Each process then invokes the Exec system call to run the program \"pgm2.xsm\". The program for \"pgm2.xsm\" is provided here . \"pgm2.xsm\" will create a new file according to the PID of the process and read 100 numbers from file \"numbers.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 numbers from X*1000 to X*1000+99, where X \u2208 {3,4..15}. The numbers written by a process in the newly created file need not be the same numbers the process has written in \"numbers.dat\" file. Assignment 5 Run the program ( merge.expl ) provided here using shell in the context of a user. The merge.expl program, first stores numbers from 1 to 512 in a random order into a file merge.dat . It then forks and executes m_store.expl which creates 8 files temp{i}.dat , where i=1..8 and stores 64 numbers each from merge.expl . Then, all the temporary files are sorted by executing m_sort.expl . Next, the first ExpL program forks and executes m_merge.expl which merges all the temporary files back into merge.dat and finally, prints the contents of the file in ascending order. If all the system calls in your OS implementation works correctly, then numbers 1 to 512 will be printed out in order. Note To run the program provided by the user, Shell process first invokes fork to create a child process. Shell will wait until this first child process completes its execution. When the first child exits, shell will resume execution even if some processes created by the given program are running in the background. This can lead to the following interesting situation. Suppose that all active processes execept idle, login and shell were swapped out and the XSM simulator is waiting for terminal input from the user into the shell. In this case, you will have to issue some command to the shell, so that the system keeps on running.","title":"Modifications to boot module"},{"location":"roadmap/stage-28/","text":"Learning Objectives Modifying eXpOS kernel to exploit parallelism in a two core machine. Understanding processor synchronization in multi-core systems. Pre-requisite Reading Read and understand NEXSM (two core extension of XSM) specification. Read and understand design documentation for eXpOS on NEXSM Installation \u00b6 Since you will be working on a new machine architecture on this stage, upgraded versions of the XSM machine simulator, SPL compiler, ExpL compiler and xfs-interface has to be downloaded. Create a new folder and download the upgraded eXpOS package so that there are no conflicts with the old version. The OS kernel code and other programs will have to be copied into the new folder before you start working. Follow the installation instructions here to download the upgraded eXpOS package. Outline \u00b6 In this stage, you will port eXpOS to a two core extension of XSM called NEXSM. The specification of the OS does not undergo any change from the point of view of the end user or the application programmer (that is, the API - high level library interface or ABI - low level system call interface are unchanged except for some insignificant updates). Thus, the upward (application) interface of the OS does not change. What changes is the downward (architecture) interface. NEXSM supports a few more memory pages, a few more disk blocks and more significantly, a second core processor. The question is - how to make the best use of the available parallelism with minimal changes to the eXpOS code? The bootstrap process happens on one of the cores (called the primary core in NEXSM specification). The bootstrap code completes the initial set up operations and then start the other core (called secondary core ) into parallel action. A read only register called CORE will have value 0 in the primary and 1 in the secondary. This allows the kernel code to determine the core on which it is executing. It is absolutely necessary to have a careful reading of the NEXSM architecture specification before proceeding further. Once the OS is up and running on the two-core machine after bootstrap, each core runs the same OS code and schedules processes parallelly . The fundamental issue to be addressed is to ensure that parallel actions of OS on the two cores do not lead the OS into an inconsistent state . Handling concurrency is a tricky issue. Here, we impose a few conservative design level restrictions to the level of parallelism permitted so that a simple and comprehensible design is possible. The resultant design is not an efficient one; but it is sufficient to demonstrate the underlying principles. The constraints imposed are the following: A single process will never be scheduled simultaneously on both the cores. The scheduler will be designed so as to ensure this policy. Only one core will run scheduling code at a given time. This makes implementation of the first policy straight-forward. Only one core will be executing critical kernel code at a time. By critical kernel code, we mean 'kernel code that updates the Disk data structures and System-Wide data structures ' . We will ensure that critical kernel code gets executed quickly and thus a core will never have to wait for a long time for the other core to leave critical section . (Non-interfering routines of the OS kernel are allowed to run parallelly - for instance both cores can enter the timer interrupt routine parallely; one core may be running the scheduler while the other is executing a system call and so on.) A few other simplifying design decisions are: The Login process and Shell Process will be run only from the primary. (As a consequence, logout and shutdown will be initiated only from the primary). The pager module will also be run only from the primary. An additional IDLE process is created at boot time (called IDLE2 with PID=14). IDLE2 will be scheduled in the second core when no other process can be scheduled. (The primary will schedule IDLE when no other process can be scheduled as in the current design). IDLE2 will never be swapped out. The primary core will never schedule IDLE2 and the secondary core will never schedule IDLE. When either logout or paging is initiated from the primary, the scheduler running on the secondary core will schedule the IDLE2 process . How can the kernel implement the policies (a) and (b)? The implementation mechanism is to maintain two access lock variables - called SCHED_LOCK and KERN_LOCK. The kernel maintains an access lock table (starting at location 29576 - see here ) where these lock variables are stored. The use of these variables will be described in detail below. Upon entry into a system call (respectively, scheduler code), the kernel first checks whether the other core is executing a system call code (respectively, scheduler code). If that is the case, the kernel waits for the other core to finish the critical system call code (respectively, scheduler code) before proceeding. Data Structure Updates \u00b6 The system status table will now contain two new entries. CURRENT_PID2: Stores the PID of the process running on the secondary core. LOGOUT_STATUS: This field is set to 1 if logout is initiated on the primary core; set to 0 otherwise. If LOGOUT_STATUS is on, only IDLE2 will be scheduled in the secondary core. A new data structure called access lock table is introduced. The fields that are of interest in this data structure are the following: a) KERN_LOCK b) SCHED_LOCK When the kernel enters a system call/exception handler (in either core), it first checks whether KERN_LOCK=1 (If so, the value should have been set to 1 by the kernel code running on the other core). In that case, the kernel executes a spin lock (details will follow) till the kernel code running on the other core sets the lock back to zero. When the lock becomes available, the system call/exception handler sets KERN_LOCK to 1 and proceed with the normal execution of the system call. This ensures, mutual exclusion (between the two cores) for the critical code of system calls/exception handler. Since paging code is critical, KERN_LOCK is set before invoking the pager module (from the timer interrupt handler ) and set back to zero upon return from the pager module. At any point of time, if the system call/exception handler has to block for some event, it sets KERN_LOCK=0 before invoking the scheduler so that if the other core is waiting for KERN_LOCK, it can acquire the lock and enter critical section. Upon getting scheduled again, the system call/exception handler must do a spin lock again and set KERN_LOCK to 1 before proceeding. This protocol ensures that a core holds onto the kernel lock only for short durations of time . This also ensures that the kernel running on one core never holds on to SCHEDULE_LOCK and KERN_LOCK simultaneously. Finally, KERN_LOCK is set to zero before return to user mode after completion of the system call handler/exception handler code. Before starting scheduling actions, the scheduler code first checks whether SCHED_LOCK is set to 1 by the scheduler code running on the other core. If the lock is set, a spin lock is executed (details will follow) till the scheduler code running on the other core resets the lock back to zero. This ensures that when scheduling actions are ongoing in one core, the other core waits. Note that scheduler code is small and will execute quickly, and hence the wait will not be for long. SCHED_LOCK is set to 0 at the end of scheduling. The fundamental point that must be understood is that the test and set operations on KERN_LOCK and SCHED_LOCK need to be atomic , for otherwise while one core is testing the value of a lock, the other core can change it from 0 to 1 and both the cores will simultaneously enter critical section. Atomicity of test and set operations can be achieved in two ways: Hardware solution: If the hardware provides instructions to perform atomic test and set operations on a variable then the facility can be used. Software Solution: Even if no hardware support is available, there are clever software solutions that achieve synchronization. Peterson\u2019s algorithm is one famous solution. In our case, the NEXSM machine provides a hardware solution in the TSL instruction to support atomic test and set operations and we will use this mechanism to implement atomic operations on KERN_LOCK and SCHED_LOCK variables. Access Control Module \u00b6 You will add a new module that implements atomic test and set operations on KERN_LOCK and SCHED_LOCK. The module will be added as Module 8 ( memory pages 132-133 ). Access control module supports the following functions: AcquireKernLock() AcquireSchedLock() ReleaseLock(LockVarAddress) Note The eXpOS design documentation supports a general purpose lock called GLOCK, reserved for future enhancements. The present implementation does not need it and we will not discuss it in the roadmap. The AccessLock functions can be implemented using the NEXSM TSL instruction to ensure that locking is atomic. SPL provides the tsl instruction which is translated to the XSM TSL machine instruction. The general locking logic in SPL would be the following. Acquire****Lock() { .... .... while (tsl (LockVariableAddress) == 1) continue; endwhile; } This would translate to the following XSM code (or equivalent): L1: TSL Ri, [LockVariableAddress] MOV Rj, 1 EQ Ri, Rj JNZ Ri, L1 The code atomically reads the lock variable repeatedly until its value is zero. Once the value is founf to be zero, the value is set to one. This procedure is sometimes called a spin lock . A spin-lock is advisable only when the CPU only make a few iterations before the resource could be accessed, as in the present case. Important: LOGOUT_STATUS will be used by the Acquire Kernel Lock function of the Access Control Module in the following way. When the Acquire Kernel Lock function is called from the secondary core, if PAGING_STATUS or LOGOUT_STATUS is on, then the lock must not be acquired. Instead, the state of the current process must be set to READY and the scheduler must be invoked. This is because when paging module is running or if the system has initiated logout (from the primary), normal processing is stopped and only IDLE2 must be scheduled in the secondary. (The scheduler will be designed so that under these circumstances, only IDLE2 will be scheduled for execution). The access control module algorithms are given here . Bootstrap Procedure \u00b6 When NEXSM boots up, only the primary core will execute. Upon execution of the START instruction from the primary (see NEXSM specification ), the secondary starts execution from physical address 65536 (page 128 - see Memory Organisation ). Hence, the primary bootstrap routine (OS startup code) must load the secondary bootstrap loader into memory before issuing START instruction. The IDLE2 process needs to be set up in memory. The access lock table entries are also initialized during bootstrap. A couple of new entries will be added to the system status table as well. The required changes to the primary OS Startup code /boot module are summarized below: Transfer the secondary bootstrap loader code from disk to memory (from disk block 512 to memory page 128). The access control module also must be loaded from disk to memory (blocks 516-517 to pages 132-133) - see disk and memory organization . (Note: The design allows 2 blocks of secondary bootstrap code, but you will only need one block for the present eXpOS version). Set up the page tables for IDLE2 (PID=14) in memory. Since one user stack and one kernel stack pages will have to be allocated for IDLE2 (the first two free pages, 83 and 84 may be allocated). The memory free list has to be updated accordingly. Also, the free memory count in the system status table will need corresponding update. The process table entries for IDLE2 will be set (similar to IDLE). In particular, the state has to be set to RUNNING (as it is going to be running very soon on the secondary core!). New entries in the system status table must be initialized. a) CURRENT_PID2 must be set to the the PID of IDLE2 process (PID=14). b) LOGOUT_STATUS must be set to 0. The access control variables KERN_LOCK and SCHED_LOCK of the Access Lock Table must be initialized to 0. Issue the START instruction to start the secondary core into execution. The secondary bootstrap code that begins parallel execution upon START must do the following: Set up the return address in user stack of the IDLE2 process; SP, PTBR and PTLR registers must be updated. Execute ireturn to run IDLE2. Thus, the primary and secondary bootstrap code will schedule IDLE (PID=0) and IDLE2 (PID=14) on the respective cores at the end of system startup. Modifications to Scheduler Module \u00b6 The scheduler module requires the following modifications: At the beginning of execution, determine whether scheduler is running on the primary or the secondary (read the CORE register value). SCHED_LOCK must be acquired by calling AcquireSchedLock() function of the access control module . If the core is primary , there is no change to existing algorithm except that: IDLE2 (PID=14) must not be scheduled. (IDLE2 is scheduled only in the secondary). The Process which is currently running on the secondary core must not be scheduled (This can be determined by reading CURRENT_PID2 field of the system status table ). If LOGOUT_STATUS=1 and the secondary core is not running IDLE2, then schedule IDLE (wait for the current running process to be scheduled out of the secondary core). If the core is secondary , there is no change to existing algorithm except that: If PAGING_STATUS or LOGOUT_STATUS is set (in the system status table ), then IDLE2 must be scheduled). IDLE (PID=0), LOGIN (PID=1), SHELL (PID=2) and SWAPPER_DAEMON (PID=15) should never be scheduled, as the eXpOS design stipulates that these processes will run only on the primary. Process which is currently running on the primary core must not be scheduled (read CURRENT_PID field of the system status table ). The PID of the process that is selected for scheduling in the secondary core must be set to CURRENT_PID2 field of the system status table. SCHED_LOCK must be released by calling ReleaseLock() function of the access control module before return from the scheduler. (Note: If the new process to be scheduled is in CREATED state, the scheduler directly returns to user mode using the ireturn statement. Do not forget to release SCHED_LOCK in this case as well!). Modifications to Exception Handler and System Calls \u00b6 Before starting any system call, KERN_LOCK must be acquired by invoking AcquireKernLock() function of the access control module . The value of Current PID will be different on the primary and the secondary cores - [SYSTEM_STATUS_TABLE + 1] in the primary core and [SYSTEM_STATUS_TABLE + 6] in the secondary core. ( Implementation trick: the formula [SYSTEM_STATUS_TABLE + 5*CORE + 1] works on both the cores!!). ReleaseLock() function of the access control module must be used to release KERN_LOCK before, a) any call to the scheduler, b) return from the system call/exception handler to the user program. Note that, the scheduler can be invoked not only from system calls, but also from kernel modules. In all such cases, KERN_LOCK must be released before invoking the scheduler. AcquireKernLock() of the access control module must be invoked at any point after return from the scheduler (inside system calls as well as kernel modules). Important Note When a process has acquired KERN_LOCK, any other process trying to acquire KERN_LOCK on the other core will be in a spin lock, doing no userful processing. Hence, your implementation should ensure that ReleaseLock() is invoked at the earliest point when it is safe to allow parallel execution of critical code from the other core. Further note that under normal conditions (except in Logout, Shutdown, etc.), updates to process table and page table entries of a process are private to the process and there is no harm in letting other processes to run parallelly when a system call needs to make updates only to these data structures. Modifications to Timer Interrupt Handler \u00b6 Do not invoke pager module from the secondary core. When running on the primary core, call AcquireKernLock() and ReleaseLock(KERN_LOCK) of the access control module before and after calling pager module. Modifications to Process Manager and Pager Modules \u00b6 Kill All function in process manager module must not call Exit Process function for IDLE2 (PID=14) as this process is never killed. Pager module must not swap out IDLE2 (PID=14). Modifications to Logout System Call \u00b6 In Logout System call , first set LOGOUT_STATUS=1 in the system status table , but then call the scheduler (wait until secondary core schedules IDLE2 before proceeding). After execution of Kill All function, set LOGOUT_STATUS=0. In the system status table . Note Since, Logout is also a system call, all the updates done to system calls in general will apply to Logout as well. Modifications to Shutdown System Call \u00b6 In Shutdown system call , before calling Kill All function of the process manager module , reset the secondary core (using RESET instruction of NEXSM) and set SCHED_LOCK to 0. Note Since, Shutdown is also a system call, all the updates done to system calls in general will apply to Shutdown as well. We have tried to include all the necessary details. We leave it to you to figure out anything that is missing here and get the OS working!! Q1.Suppose the scheduler is about to resume execution of a process which was blocked while executing some system call, what would go wrong if we modify the present design so that scheduler simply sets KERN_LOCK=1 before scheduling it (instead of the process doing a AcquireKernLock() inside the system call after being scheduled)? Note that the scheduler will not run simultaneously on both the cores. If the scheduler simply sets KERN_LOCK=1, then there is a possibility that the other core may have already acquired the KERN_LOCK. This causes both the cores to execute the critical section code parallelly, which will corrupt the OS data structures. Also, AcquireKernLock() function must be called from the system call, instead of the scheduler, as the return from scheduler may be to the timer interrupt handler which doesn't require a Kernel Lock. Q2. Why should the logout system call wait for the secondary to execute IDLE2 before proceeding? The Logout system call terminates all the processes from 4 through 13 by calling the Kill All function in the process manager module. So, if this system call terminates the currently running process in the secondary core, the memory pages assigned to the process will be released by freeing the page table and user area page, which causes the secondary core to raise an exception. Waiting for the secondary core to schedule IDLE2 prevents this from happening. Assignment 1 Run all the test cases of the previous stage. Assignment 2 Modify the access locking algorithm to use Peterson\u2019s algorithm instead of using the TSL instruction and run all test cases. Thought Experiment Right now, all kernel code (except scheduler) operates with a single KERN_LOCK. Instead, suppose you put different lock variables for each kernel data structure, clearly, better use of parallelism can be achieved. What are the issues you have to consider when such a re-design is one? (You don\u2019t have to do the experiment, but try to work out the design details on pen and paper). Do you think this will make the kernel run considerably faster? Can such a design lead to deadlocks?","title":"Stage 28"},{"location":"roadmap/stage-28/#installation","text":"Since you will be working on a new machine architecture on this stage, upgraded versions of the XSM machine simulator, SPL compiler, ExpL compiler and xfs-interface has to be downloaded. Create a new folder and download the upgraded eXpOS package so that there are no conflicts with the old version. The OS kernel code and other programs will have to be copied into the new folder before you start working. Follow the installation instructions here to download the upgraded eXpOS package.","title":"Installation"},{"location":"roadmap/stage-28/#outline","text":"In this stage, you will port eXpOS to a two core extension of XSM called NEXSM. The specification of the OS does not undergo any change from the point of view of the end user or the application programmer (that is, the API - high level library interface or ABI - low level system call interface are unchanged except for some insignificant updates). Thus, the upward (application) interface of the OS does not change. What changes is the downward (architecture) interface. NEXSM supports a few more memory pages, a few more disk blocks and more significantly, a second core processor. The question is - how to make the best use of the available parallelism with minimal changes to the eXpOS code? The bootstrap process happens on one of the cores (called the primary core in NEXSM specification). The bootstrap code completes the initial set up operations and then start the other core (called secondary core ) into parallel action. A read only register called CORE will have value 0 in the primary and 1 in the secondary. This allows the kernel code to determine the core on which it is executing. It is absolutely necessary to have a careful reading of the NEXSM architecture specification before proceeding further. Once the OS is up and running on the two-core machine after bootstrap, each core runs the same OS code and schedules processes parallelly . The fundamental issue to be addressed is to ensure that parallel actions of OS on the two cores do not lead the OS into an inconsistent state . Handling concurrency is a tricky issue. Here, we impose a few conservative design level restrictions to the level of parallelism permitted so that a simple and comprehensible design is possible. The resultant design is not an efficient one; but it is sufficient to demonstrate the underlying principles. The constraints imposed are the following: A single process will never be scheduled simultaneously on both the cores. The scheduler will be designed so as to ensure this policy. Only one core will run scheduling code at a given time. This makes implementation of the first policy straight-forward. Only one core will be executing critical kernel code at a time. By critical kernel code, we mean 'kernel code that updates the Disk data structures and System-Wide data structures ' . We will ensure that critical kernel code gets executed quickly and thus a core will never have to wait for a long time for the other core to leave critical section . (Non-interfering routines of the OS kernel are allowed to run parallelly - for instance both cores can enter the timer interrupt routine parallely; one core may be running the scheduler while the other is executing a system call and so on.) A few other simplifying design decisions are: The Login process and Shell Process will be run only from the primary. (As a consequence, logout and shutdown will be initiated only from the primary). The pager module will also be run only from the primary. An additional IDLE process is created at boot time (called IDLE2 with PID=14). IDLE2 will be scheduled in the second core when no other process can be scheduled. (The primary will schedule IDLE when no other process can be scheduled as in the current design). IDLE2 will never be swapped out. The primary core will never schedule IDLE2 and the secondary core will never schedule IDLE. When either logout or paging is initiated from the primary, the scheduler running on the secondary core will schedule the IDLE2 process . How can the kernel implement the policies (a) and (b)? The implementation mechanism is to maintain two access lock variables - called SCHED_LOCK and KERN_LOCK. The kernel maintains an access lock table (starting at location 29576 - see here ) where these lock variables are stored. The use of these variables will be described in detail below. Upon entry into a system call (respectively, scheduler code), the kernel first checks whether the other core is executing a system call code (respectively, scheduler code). If that is the case, the kernel waits for the other core to finish the critical system call code (respectively, scheduler code) before proceeding.","title":"Outline"},{"location":"roadmap/stage-28/#data-structure-updates","text":"The system status table will now contain two new entries. CURRENT_PID2: Stores the PID of the process running on the secondary core. LOGOUT_STATUS: This field is set to 1 if logout is initiated on the primary core; set to 0 otherwise. If LOGOUT_STATUS is on, only IDLE2 will be scheduled in the secondary core. A new data structure called access lock table is introduced. The fields that are of interest in this data structure are the following: a) KERN_LOCK b) SCHED_LOCK When the kernel enters a system call/exception handler (in either core), it first checks whether KERN_LOCK=1 (If so, the value should have been set to 1 by the kernel code running on the other core). In that case, the kernel executes a spin lock (details will follow) till the kernel code running on the other core sets the lock back to zero. When the lock becomes available, the system call/exception handler sets KERN_LOCK to 1 and proceed with the normal execution of the system call. This ensures, mutual exclusion (between the two cores) for the critical code of system calls/exception handler. Since paging code is critical, KERN_LOCK is set before invoking the pager module (from the timer interrupt handler ) and set back to zero upon return from the pager module. At any point of time, if the system call/exception handler has to block for some event, it sets KERN_LOCK=0 before invoking the scheduler so that if the other core is waiting for KERN_LOCK, it can acquire the lock and enter critical section. Upon getting scheduled again, the system call/exception handler must do a spin lock again and set KERN_LOCK to 1 before proceeding. This protocol ensures that a core holds onto the kernel lock only for short durations of time . This also ensures that the kernel running on one core never holds on to SCHEDULE_LOCK and KERN_LOCK simultaneously. Finally, KERN_LOCK is set to zero before return to user mode after completion of the system call handler/exception handler code. Before starting scheduling actions, the scheduler code first checks whether SCHED_LOCK is set to 1 by the scheduler code running on the other core. If the lock is set, a spin lock is executed (details will follow) till the scheduler code running on the other core resets the lock back to zero. This ensures that when scheduling actions are ongoing in one core, the other core waits. Note that scheduler code is small and will execute quickly, and hence the wait will not be for long. SCHED_LOCK is set to 0 at the end of scheduling. The fundamental point that must be understood is that the test and set operations on KERN_LOCK and SCHED_LOCK need to be atomic , for otherwise while one core is testing the value of a lock, the other core can change it from 0 to 1 and both the cores will simultaneously enter critical section. Atomicity of test and set operations can be achieved in two ways: Hardware solution: If the hardware provides instructions to perform atomic test and set operations on a variable then the facility can be used. Software Solution: Even if no hardware support is available, there are clever software solutions that achieve synchronization. Peterson\u2019s algorithm is one famous solution. In our case, the NEXSM machine provides a hardware solution in the TSL instruction to support atomic test and set operations and we will use this mechanism to implement atomic operations on KERN_LOCK and SCHED_LOCK variables.","title":"Data Structure Updates"},{"location":"roadmap/stage-28/#access-control-module","text":"You will add a new module that implements atomic test and set operations on KERN_LOCK and SCHED_LOCK. The module will be added as Module 8 ( memory pages 132-133 ). Access control module supports the following functions: AcquireKernLock() AcquireSchedLock() ReleaseLock(LockVarAddress) Note The eXpOS design documentation supports a general purpose lock called GLOCK, reserved for future enhancements. The present implementation does not need it and we will not discuss it in the roadmap. The AccessLock functions can be implemented using the NEXSM TSL instruction to ensure that locking is atomic. SPL provides the tsl instruction which is translated to the XSM TSL machine instruction. The general locking logic in SPL would be the following. Acquire****Lock() { .... .... while (tsl (LockVariableAddress) == 1) continue; endwhile; } This would translate to the following XSM code (or equivalent): L1: TSL Ri, [LockVariableAddress] MOV Rj, 1 EQ Ri, Rj JNZ Ri, L1 The code atomically reads the lock variable repeatedly until its value is zero. Once the value is founf to be zero, the value is set to one. This procedure is sometimes called a spin lock . A spin-lock is advisable only when the CPU only make a few iterations before the resource could be accessed, as in the present case. Important: LOGOUT_STATUS will be used by the Acquire Kernel Lock function of the Access Control Module in the following way. When the Acquire Kernel Lock function is called from the secondary core, if PAGING_STATUS or LOGOUT_STATUS is on, then the lock must not be acquired. Instead, the state of the current process must be set to READY and the scheduler must be invoked. This is because when paging module is running or if the system has initiated logout (from the primary), normal processing is stopped and only IDLE2 must be scheduled in the secondary. (The scheduler will be designed so that under these circumstances, only IDLE2 will be scheduled for execution). The access control module algorithms are given here .","title":"Access Control Module"},{"location":"roadmap/stage-28/#bootstrap-procedure","text":"When NEXSM boots up, only the primary core will execute. Upon execution of the START instruction from the primary (see NEXSM specification ), the secondary starts execution from physical address 65536 (page 128 - see Memory Organisation ). Hence, the primary bootstrap routine (OS startup code) must load the secondary bootstrap loader into memory before issuing START instruction. The IDLE2 process needs to be set up in memory. The access lock table entries are also initialized during bootstrap. A couple of new entries will be added to the system status table as well. The required changes to the primary OS Startup code /boot module are summarized below: Transfer the secondary bootstrap loader code from disk to memory (from disk block 512 to memory page 128). The access control module also must be loaded from disk to memory (blocks 516-517 to pages 132-133) - see disk and memory organization . (Note: The design allows 2 blocks of secondary bootstrap code, but you will only need one block for the present eXpOS version). Set up the page tables for IDLE2 (PID=14) in memory. Since one user stack and one kernel stack pages will have to be allocated for IDLE2 (the first two free pages, 83 and 84 may be allocated). The memory free list has to be updated accordingly. Also, the free memory count in the system status table will need corresponding update. The process table entries for IDLE2 will be set (similar to IDLE). In particular, the state has to be set to RUNNING (as it is going to be running very soon on the secondary core!). New entries in the system status table must be initialized. a) CURRENT_PID2 must be set to the the PID of IDLE2 process (PID=14). b) LOGOUT_STATUS must be set to 0. The access control variables KERN_LOCK and SCHED_LOCK of the Access Lock Table must be initialized to 0. Issue the START instruction to start the secondary core into execution. The secondary bootstrap code that begins parallel execution upon START must do the following: Set up the return address in user stack of the IDLE2 process; SP, PTBR and PTLR registers must be updated. Execute ireturn to run IDLE2. Thus, the primary and secondary bootstrap code will schedule IDLE (PID=0) and IDLE2 (PID=14) on the respective cores at the end of system startup.","title":"Bootstrap Procedure"},{"location":"roadmap/stage-28/#modifications-to-scheduler-module","text":"The scheduler module requires the following modifications: At the beginning of execution, determine whether scheduler is running on the primary or the secondary (read the CORE register value). SCHED_LOCK must be acquired by calling AcquireSchedLock() function of the access control module . If the core is primary , there is no change to existing algorithm except that: IDLE2 (PID=14) must not be scheduled. (IDLE2 is scheduled only in the secondary). The Process which is currently running on the secondary core must not be scheduled (This can be determined by reading CURRENT_PID2 field of the system status table ). If LOGOUT_STATUS=1 and the secondary core is not running IDLE2, then schedule IDLE (wait for the current running process to be scheduled out of the secondary core). If the core is secondary , there is no change to existing algorithm except that: If PAGING_STATUS or LOGOUT_STATUS is set (in the system status table ), then IDLE2 must be scheduled). IDLE (PID=0), LOGIN (PID=1), SHELL (PID=2) and SWAPPER_DAEMON (PID=15) should never be scheduled, as the eXpOS design stipulates that these processes will run only on the primary. Process which is currently running on the primary core must not be scheduled (read CURRENT_PID field of the system status table ). The PID of the process that is selected for scheduling in the secondary core must be set to CURRENT_PID2 field of the system status table. SCHED_LOCK must be released by calling ReleaseLock() function of the access control module before return from the scheduler. (Note: If the new process to be scheduled is in CREATED state, the scheduler directly returns to user mode using the ireturn statement. Do not forget to release SCHED_LOCK in this case as well!).","title":"Modifications to Scheduler Module"},{"location":"roadmap/stage-28/#modifications-to-exception-handler-and-system-calls","text":"Before starting any system call, KERN_LOCK must be acquired by invoking AcquireKernLock() function of the access control module . The value of Current PID will be different on the primary and the secondary cores - [SYSTEM_STATUS_TABLE + 1] in the primary core and [SYSTEM_STATUS_TABLE + 6] in the secondary core. ( Implementation trick: the formula [SYSTEM_STATUS_TABLE + 5*CORE + 1] works on both the cores!!). ReleaseLock() function of the access control module must be used to release KERN_LOCK before, a) any call to the scheduler, b) return from the system call/exception handler to the user program. Note that, the scheduler can be invoked not only from system calls, but also from kernel modules. In all such cases, KERN_LOCK must be released before invoking the scheduler. AcquireKernLock() of the access control module must be invoked at any point after return from the scheduler (inside system calls as well as kernel modules). Important Note When a process has acquired KERN_LOCK, any other process trying to acquire KERN_LOCK on the other core will be in a spin lock, doing no userful processing. Hence, your implementation should ensure that ReleaseLock() is invoked at the earliest point when it is safe to allow parallel execution of critical code from the other core. Further note that under normal conditions (except in Logout, Shutdown, etc.), updates to process table and page table entries of a process are private to the process and there is no harm in letting other processes to run parallelly when a system call needs to make updates only to these data structures.","title":"Modifications to Exception Handler and System Calls"},{"location":"roadmap/stage-28/#modifications-to-timer-interrupt-handler","text":"Do not invoke pager module from the secondary core. When running on the primary core, call AcquireKernLock() and ReleaseLock(KERN_LOCK) of the access control module before and after calling pager module.","title":"Modifications to Timer Interrupt Handler"},{"location":"roadmap/stage-28/#modifications-to-process-manager-and-pager-modules","text":"Kill All function in process manager module must not call Exit Process function for IDLE2 (PID=14) as this process is never killed. Pager module must not swap out IDLE2 (PID=14).","title":"Modifications to Process Manager and Pager Modules"},{"location":"roadmap/stage-28/#modifications-to-logout-system-call","text":"In Logout System call , first set LOGOUT_STATUS=1 in the system status table , but then call the scheduler (wait until secondary core schedules IDLE2 before proceeding). After execution of Kill All function, set LOGOUT_STATUS=0. In the system status table . Note Since, Logout is also a system call, all the updates done to system calls in general will apply to Logout as well.","title":"Modifications to Logout System Call"},{"location":"roadmap/stage-28/#modifications-to-shutdown-system-call","text":"In Shutdown system call , before calling Kill All function of the process manager module , reset the secondary core (using RESET instruction of NEXSM) and set SCHED_LOCK to 0. Note Since, Shutdown is also a system call, all the updates done to system calls in general will apply to Shutdown as well. We have tried to include all the necessary details. We leave it to you to figure out anything that is missing here and get the OS working!! Q1.Suppose the scheduler is about to resume execution of a process which was blocked while executing some system call, what would go wrong if we modify the present design so that scheduler simply sets KERN_LOCK=1 before scheduling it (instead of the process doing a AcquireKernLock() inside the system call after being scheduled)? Note that the scheduler will not run simultaneously on both the cores. If the scheduler simply sets KERN_LOCK=1, then there is a possibility that the other core may have already acquired the KERN_LOCK. This causes both the cores to execute the critical section code parallelly, which will corrupt the OS data structures. Also, AcquireKernLock() function must be called from the system call, instead of the scheduler, as the return from scheduler may be to the timer interrupt handler which doesn't require a Kernel Lock. Q2. Why should the logout system call wait for the secondary to execute IDLE2 before proceeding? The Logout system call terminates all the processes from 4 through 13 by calling the Kill All function in the process manager module. So, if this system call terminates the currently running process in the secondary core, the memory pages assigned to the process will be released by freeing the page table and user area page, which causes the secondary core to raise an exception. Waiting for the secondary core to schedule IDLE2 prevents this from happening. Assignment 1 Run all the test cases of the previous stage. Assignment 2 Modify the access locking algorithm to use Peterson\u2019s algorithm instead of using the TSL instruction and run all test cases. Thought Experiment Right now, all kernel code (except scheduler) operates with a single KERN_LOCK. Instead, suppose you put different lock variables for each kernel data structure, clearly, better use of parallelism can be achieved. What are the issues you have to consider when such a re-design is one? (You don\u2019t have to do the experiment, but try to work out the design details on pen and paper). Do you think this will make the kernel run considerably faster? Can such a design lead to deadlocks?","title":"Modifications to Shutdown System Call"},{"location":"support-tools/constants/","text":"SPL constants defining the call addresses for Interrupts/Exceptions/Modules \u00b6 Name Default Value Comments EX_HANDLER / EXCEPTION 1024 Starting address of Exception Handler TIMER 2048 Starting address of Timer Interrupt Routine DISK 3072 Starting address of Disk Controller Interrupt Routine CONSOLE 4096 Starting address of Console Interrupt Routine INT_4 5120 (Create, 1) * , (Delete, 4) INT_5 6144 (Seek, 6), (Open, 2), (Close,3) INT_6 7168 (Read, 7) INT_7 8192 (Write, 5) INT_8 9216 (Fork, 8) INT_9 10240 (Exec, 9) INT_10 11264 (Exit, 10) INT_11 12288 (Getpid, 11), (Getppid, 12), (Wait, 13), (Signal, 14) INT_12 13312 (Logout, 28) INT_13 14336 (Semget, 17), (Semrelease, 18) INT_14 15360 (SemLock, 19), (SemUnLock, 20) INT_15 16384 (Shutdown, 21) INT_16 17408 (Newusr, 22), (Remusr, 23), (Setpwd, 24), (Getuname, 25), (Getuid, 26) INT_17 18432 (Login, 27) INT_18 19456 (Test0, 96), (Test1, 97), (Test2, 98), (Test3, 99) MOD_0 / RESOURCE_MANAGER 20480 Resource Manager MOD_1 / PROCESS_MANAGER 21504 Process Manager MOD_2 / MEMORY_MANAGER 22528 Memory Manager MOD_3 / FILE_MANAGER 23552 File Manager MOD_4 / DEVICE_MANAGER 24576 Device Manager MOD_5 / CONTEXT_SWITCH / SCHEDULER 25600 Context Switch Module (Scheduler Module) MOD_6 / PAGER_MODULE 26624 Pager Module MOD_7 / BOOT_MODULE 27648 Boot Module * (System Call Name, System Call Number) SPL constants for the System Call Numbers \u00b6 Name System Call Number Comments INT_CREATE 1 Create System Call INT_OPEN 2 Open System Call INT_CLOSE 3 Close System Call INT_DELETE 4 Delete System Call INT_WRITE 5 Write System Call INT_SEEK 6 Seek System Call INT_READ 7 Read System Call INT_FORK 8 Fork System Call INT_EXEC 9 Exec System Call INT_EXIT 10 Exit System Call INT_GETPID 11 Getpid System Call INT_GETPPID 12 Getppid System Call INT_WAIT 13 Wait System Call INT_SIGNAL 14 Signal System Call INT_SEMGET 17 Semget System Call INT_SEMRELEASE 18 Semrelease System Call INT_SEMLOCK 19 SemLock System Call INT_SEMUNLOCK 20 SemUnLock System Call INT_SHUTDOWN 21 Shutdown System Call INT_NEWUSR 22 Newusr System Call INT_REMUSR 23 Remusr System Call INT_SETPWD 24 Setpwd System Call INT_GETUNAME 25 Getuname System Call INT_GETUID 26 Getuid System Call INT_LOGIN 27 Login System Call INT_LOGOUT 28 Logout System Call INT_TEST0 96 Test System Call 0 INT_TEST1 97 Test System Call 1 INT_TEST2 98 Test System Call 2 INT_TEST3 99 Test System Call 3 SPL constants for indicating the Function Numbers in Modules \u00b6 Name Default Value Comments ACQUIRE_BUFFER 1 Resource Manager Function #1 RELEASE_BUFFER 2 Resource Manager Function #2 ACQUIRE_DISK 3 Resource Manager Function #3 ACQUIRE_INODE 4 Resource Manager Function #4 RELEASE_INODE 5 Resource Manager Function #5 ACQUIRE_SEMAPHORE 6 Resource Manager Function #6 RELEASE_SEMAPHORE 7 Resource Manager Function #7 ACQUIRE_TERMINAL 8 Resource Manager Function #8 RELEASE TERMINAL 9 Resource Manager Function #9 GET_PCB_ENTRY 1 Process Manager Function #1 FREE_USER_AREA_PAGE 2 Process Manager Function #2 EXIT_PROCESS 3 Process Manager Function #3 FREE_PAGE_TABLE 4 Process Manager Function #4 KILL_ALL 5 Process Manager Function #5 GET_FREE_PAGE 1 Memory Manager Function #1 RELEASE_PAGE 2 Memory Manager Function #2 GET_FREE_BLOCK 3 Memory Manager Function #3 RELEASE_BLOCK 4 Memory Manager Function #4 GET_CODE_PAGE 5 Memory Manager Function #5 GET_SWAP_BLOCK 6 Memory Manager Function #6 BUFFERED_WRITE 1 File Manager Function #1 BUFFERED_READ 2 File Manager Function #2 OPEN 3 File Manager Function #3 CLOSE 4 File Manager Function #4 DISK_STORE 1 Device Manager Function #1 DISK_LOAD 2 Device Manager Function #2 TERMINAL_WRITE 3 Device Manager Function #3 TERMINAL_READ 4 Device Manager Function #4 SWAP_OUT 1 Pager Module Function #1 SWAP_IN 2 Pager Module Function #2 SPL constants for indicating the starting addresses of Kernel Data Structures in Memory (See Memory Organisation ) \u00b6 Name Default Value Comments PROCESS_TABLE 28672 Starting address of Process Table OPEN_FILE_TABLE 28928 Starting address of Open File Table SEMAPHORE_TABLE 29056 Starting address of Semaphore Table MEMORY_FREE_LIST 29184 Starting address of Memory Free List FILE_STATUS_TABLE 29312 Starting address of File Status Table DISK_STATUS_TABLE 29552 Starting address of Disk Status Table SYSTEM_STATUS_TABLE 29560 Starting address of System Status Table TERMINAL_STATUS_TABLE 29568 Starting address of Terminal Status Table PAGE_TABLE_BASE 29696 Starting address of Page tables BUFFER_TABLE 30016 Starting address of Buffer Table DISK_MAP_TABLE 30032 Starting address of Disk Map Table INODE_TABLE 30208 Starting address of Inode Table USER_TABLE 31168 Starting address of User Table DISK_FREE_LIST 31232 Starting address of Disk Free List ROOT_FILE 31744 Starting address of Root File BUFFER 36352 Starting address of Buffer Cache BUFFER_BASE 71 Starting page number of Buffer Cache SPL constants for related to User Programs loaded by the Kernel to Memory (See Memory Organisation ) \u00b6 Name Default Value Comments LIBRARY 32256 Starting address of eXpOS Library INIT / LOGIN 33280 Starting address of INIT/Login Program SHELL 34304 Starting address of Shell Program IDLE / SWAPPER 35328 Starting address of Idle/Swapper Program IDLE_PROCESS 0 PID of the Idle Process INIT_PROCESS / LOGIN_PROCESS 1 PID of the Init/Login Proces SHELL_PROCESS 2 PID of the Shell SWAPPER_DAEMON 15 PID of the Swapper Daemon SPL constants for indicating the Process States \u00b6 Name Default Value Comments READY 1 Process State READY RUNNING 2 Process State RUNNING CREATED 3 Process State CREATED TERMINATED 4 Process State TERMINATED WAIT_DISK 5 Process is waiting to acquire disk WAIT_FILE 6 Process is waiting for release on an Inode WAIT_BUFFER 7 Process is waiting for release of buffer cache WAIT_TERMINAL 8 Process is waiting to acquire terminal WAIT_PROCESS 9 Process is waiting for a signal from another process WAIT_SEMAPHORE 10 Process is waiting to acquire a semaphore WAIT_MEM 11 Process is waiting as memory is not available ALLOCATED 12 Process Table entry has been allocated for the process, but process creation is not complete SPL constants identifying the File Type/Permission in Inode Table \u00b6 Name Default Value Comments EXCLUSIVE 0 EXCLUSIVE file permission OPEN_ACCESS 1 OPEN ACCESS file permission ROOT 1 Indicates that the file is the root file DATA 2 Indicates that the file is a data file EXEC 3 Indicates that the file is an executable file SPL constants related to Per-process Resource Table \u00b6 Name Default Value Comments FILE 0 Indicates that the resource is a file in the resource table SEMAPHORE 1 Indicates that the resource is a semaphore in the resource table RESOURCE_TABLE_OFFSET 496 Offset of the Resource Table from the start of user area page SPL constants related to Swapping \u00b6 Name Default Value Comments MEM_LOW 4 Memory is critically low so that swap out has to be initiated MEM_HIGH 12 Memory is high enough such that a process can be swapped in MAX_TICK 1000 Indicates the threshold after which a swapped out process must be swapped back in SPL constants related to eXpFS Disk (See Disk Origanisation ) \u00b6 Name Default Value Comments XFS_BSIZE 512 Number of words in a disk block MAX_FILE_BLOCKS 4 Maximum number of blocks allocatable to each file. DISK_SWAP_AREA 256 Starting block number of Swap Area in the disk DISK_FREE_AREA 69 Starting block number of User Block area in the disk DISK_SIZE 512 Number of blocks in the disk SPL constants defining the maximum limits \u00b6 Name Default Value Comments PAGE_SIZE 512 Size of a memory page in eXpOS NUM_MEM_PAGES 128 Number of memory pages in eXpOS MAX_PROC_NUM 16 Max. number of process allowed by eXpOS PT_ENTRY_SIZE 16 Size of one page table entry MAX_OPENFILE_NUM 32 Max. number of open files allowed by eXpOS MAX_MEM_PAGE 128 Max. number of memory pages availble to eXpOS MAX_SEM_COUNT 32 Max. number of semaphores allowed by eXpOS MAX_PROC_PAGES 10 Max. number of pages allowed for each process MAX_BUFFER 4 Max. number of file read/write buffers in eXpOS MAX_FILE_NUM 60 Max. number of files possible MAX_FILE_SIZE 2048 Max. words in a file MAX_USER_NUM 16 Max. number of users allowed Miscellaneous Constants \u00b6 Name Default Value Comments INODE_ROOT 0 Inode Index field of the Open File Table is set to INODE_ROOT if the file is the Root file. KERNEL 0 Indicates the Kernel user in the CURRENT_USER_ID field of the System Status Table ZERO 0 Zero ONE 1 One Constants for NEXSM \u00b6 Name Default Value Comments OS_SECONDARY 65536 Starting address of OS Startup code for secondary core. INT_19 66560 (Test4, 100), (Test5, 101), (Test6, 102), (Test7, 103) MOD_8 / ACCESS_CONTROL 67584 Access Control Module MOD_9 / TESTA 68608 TestA (Reserved for Future use) MOD_10 / TESTB 69632 TestB (Reserved for Future use) MOD_11 / TESTC 70656 TestC (Reserved for Future use) IDLE2_PROCESS 14 PID of the Idle Process for secondary core INT_TEST4 100 Test System Call 4 INT_TEST5 101 Test System Call 5 INT_TEST6 102 Test System Call 6 INT_TEST7 103 Test System Call 7 ACQUIRE_KERN_LOCK 1 Access Control Module Function #1 ACQUIRE_SCHED_LOCK 2 Access Control Module Function #2 ACQUIRE_GLOCK 3 Access Control Module Function #3 RELEASE_LOCK 4 Access Control Module Function #4 PRIMARY_CORE 0 Indicates that the current core is primary core SECONDARY_CORE 1 Indicates that the current core is secondary core ACCESS_LOCK_TABLE 29576 Starting address of Access Lock Table KERN_LOCK 29576 Kernel Lock SCHED_LOCK 29577 Scheduler Lock GLOCK 29578 General Purpose Lock NUM_MEM_PAGES * 144 Number of memory pages in eXpOS DISK_SIZE * 528 Number of blocks in the disk","title":"Constants"},{"location":"support-tools/constants/#spl-constants-defining-the-call-addresses-for-interruptsexceptionsmodules","text":"Name Default Value Comments EX_HANDLER / EXCEPTION 1024 Starting address of Exception Handler TIMER 2048 Starting address of Timer Interrupt Routine DISK 3072 Starting address of Disk Controller Interrupt Routine CONSOLE 4096 Starting address of Console Interrupt Routine INT_4 5120 (Create, 1) * , (Delete, 4) INT_5 6144 (Seek, 6), (Open, 2), (Close,3) INT_6 7168 (Read, 7) INT_7 8192 (Write, 5) INT_8 9216 (Fork, 8) INT_9 10240 (Exec, 9) INT_10 11264 (Exit, 10) INT_11 12288 (Getpid, 11), (Getppid, 12), (Wait, 13), (Signal, 14) INT_12 13312 (Logout, 28) INT_13 14336 (Semget, 17), (Semrelease, 18) INT_14 15360 (SemLock, 19), (SemUnLock, 20) INT_15 16384 (Shutdown, 21) INT_16 17408 (Newusr, 22), (Remusr, 23), (Setpwd, 24), (Getuname, 25), (Getuid, 26) INT_17 18432 (Login, 27) INT_18 19456 (Test0, 96), (Test1, 97), (Test2, 98), (Test3, 99) MOD_0 / RESOURCE_MANAGER 20480 Resource Manager MOD_1 / PROCESS_MANAGER 21504 Process Manager MOD_2 / MEMORY_MANAGER 22528 Memory Manager MOD_3 / FILE_MANAGER 23552 File Manager MOD_4 / DEVICE_MANAGER 24576 Device Manager MOD_5 / CONTEXT_SWITCH / SCHEDULER 25600 Context Switch Module (Scheduler Module) MOD_6 / PAGER_MODULE 26624 Pager Module MOD_7 / BOOT_MODULE 27648 Boot Module * (System Call Name, System Call Number)","title":"SPL constants defining the call addresses for Interrupts/Exceptions/Modules"},{"location":"support-tools/constants/#spl-constants-for-the-system-call-numbers","text":"Name System Call Number Comments INT_CREATE 1 Create System Call INT_OPEN 2 Open System Call INT_CLOSE 3 Close System Call INT_DELETE 4 Delete System Call INT_WRITE 5 Write System Call INT_SEEK 6 Seek System Call INT_READ 7 Read System Call INT_FORK 8 Fork System Call INT_EXEC 9 Exec System Call INT_EXIT 10 Exit System Call INT_GETPID 11 Getpid System Call INT_GETPPID 12 Getppid System Call INT_WAIT 13 Wait System Call INT_SIGNAL 14 Signal System Call INT_SEMGET 17 Semget System Call INT_SEMRELEASE 18 Semrelease System Call INT_SEMLOCK 19 SemLock System Call INT_SEMUNLOCK 20 SemUnLock System Call INT_SHUTDOWN 21 Shutdown System Call INT_NEWUSR 22 Newusr System Call INT_REMUSR 23 Remusr System Call INT_SETPWD 24 Setpwd System Call INT_GETUNAME 25 Getuname System Call INT_GETUID 26 Getuid System Call INT_LOGIN 27 Login System Call INT_LOGOUT 28 Logout System Call INT_TEST0 96 Test System Call 0 INT_TEST1 97 Test System Call 1 INT_TEST2 98 Test System Call 2 INT_TEST3 99 Test System Call 3","title":"SPL constants for the System Call Numbers"},{"location":"support-tools/constants/#spl-constants-for-indicating-the-function-numbers-in-modules","text":"Name Default Value Comments ACQUIRE_BUFFER 1 Resource Manager Function #1 RELEASE_BUFFER 2 Resource Manager Function #2 ACQUIRE_DISK 3 Resource Manager Function #3 ACQUIRE_INODE 4 Resource Manager Function #4 RELEASE_INODE 5 Resource Manager Function #5 ACQUIRE_SEMAPHORE 6 Resource Manager Function #6 RELEASE_SEMAPHORE 7 Resource Manager Function #7 ACQUIRE_TERMINAL 8 Resource Manager Function #8 RELEASE TERMINAL 9 Resource Manager Function #9 GET_PCB_ENTRY 1 Process Manager Function #1 FREE_USER_AREA_PAGE 2 Process Manager Function #2 EXIT_PROCESS 3 Process Manager Function #3 FREE_PAGE_TABLE 4 Process Manager Function #4 KILL_ALL 5 Process Manager Function #5 GET_FREE_PAGE 1 Memory Manager Function #1 RELEASE_PAGE 2 Memory Manager Function #2 GET_FREE_BLOCK 3 Memory Manager Function #3 RELEASE_BLOCK 4 Memory Manager Function #4 GET_CODE_PAGE 5 Memory Manager Function #5 GET_SWAP_BLOCK 6 Memory Manager Function #6 BUFFERED_WRITE 1 File Manager Function #1 BUFFERED_READ 2 File Manager Function #2 OPEN 3 File Manager Function #3 CLOSE 4 File Manager Function #4 DISK_STORE 1 Device Manager Function #1 DISK_LOAD 2 Device Manager Function #2 TERMINAL_WRITE 3 Device Manager Function #3 TERMINAL_READ 4 Device Manager Function #4 SWAP_OUT 1 Pager Module Function #1 SWAP_IN 2 Pager Module Function #2","title":"SPL constants for indicating the Function Numbers in Modules"},{"location":"support-tools/constants/#spl-constants-for-indicating-the-starting-addresses-of-kernel-data-structures-in-memory-see-memory-organisation","text":"Name Default Value Comments PROCESS_TABLE 28672 Starting address of Process Table OPEN_FILE_TABLE 28928 Starting address of Open File Table SEMAPHORE_TABLE 29056 Starting address of Semaphore Table MEMORY_FREE_LIST 29184 Starting address of Memory Free List FILE_STATUS_TABLE 29312 Starting address of File Status Table DISK_STATUS_TABLE 29552 Starting address of Disk Status Table SYSTEM_STATUS_TABLE 29560 Starting address of System Status Table TERMINAL_STATUS_TABLE 29568 Starting address of Terminal Status Table PAGE_TABLE_BASE 29696 Starting address of Page tables BUFFER_TABLE 30016 Starting address of Buffer Table DISK_MAP_TABLE 30032 Starting address of Disk Map Table INODE_TABLE 30208 Starting address of Inode Table USER_TABLE 31168 Starting address of User Table DISK_FREE_LIST 31232 Starting address of Disk Free List ROOT_FILE 31744 Starting address of Root File BUFFER 36352 Starting address of Buffer Cache BUFFER_BASE 71 Starting page number of Buffer Cache","title":"SPL constants for indicating the starting addresses of Kernel Data Structures in Memory (See Memory Organisation)"},{"location":"support-tools/constants/#spl-constants-for-related-to-user-programs-loaded-by-the-kernel-to-memory-see-memory-organisation","text":"Name Default Value Comments LIBRARY 32256 Starting address of eXpOS Library INIT / LOGIN 33280 Starting address of INIT/Login Program SHELL 34304 Starting address of Shell Program IDLE / SWAPPER 35328 Starting address of Idle/Swapper Program IDLE_PROCESS 0 PID of the Idle Process INIT_PROCESS / LOGIN_PROCESS 1 PID of the Init/Login Proces SHELL_PROCESS 2 PID of the Shell SWAPPER_DAEMON 15 PID of the Swapper Daemon","title":"SPL constants for related to User Programs loaded by the Kernel to Memory (See Memory Organisation)"},{"location":"support-tools/constants/#spl-constants-for-indicating-the-process-states","text":"Name Default Value Comments READY 1 Process State READY RUNNING 2 Process State RUNNING CREATED 3 Process State CREATED TERMINATED 4 Process State TERMINATED WAIT_DISK 5 Process is waiting to acquire disk WAIT_FILE 6 Process is waiting for release on an Inode WAIT_BUFFER 7 Process is waiting for release of buffer cache WAIT_TERMINAL 8 Process is waiting to acquire terminal WAIT_PROCESS 9 Process is waiting for a signal from another process WAIT_SEMAPHORE 10 Process is waiting to acquire a semaphore WAIT_MEM 11 Process is waiting as memory is not available ALLOCATED 12 Process Table entry has been allocated for the process, but process creation is not complete","title":"SPL constants for indicating the Process States"},{"location":"support-tools/constants/#spl-constants-identifying-the-file-typepermission-in-inode-table","text":"Name Default Value Comments EXCLUSIVE 0 EXCLUSIVE file permission OPEN_ACCESS 1 OPEN ACCESS file permission ROOT 1 Indicates that the file is the root file DATA 2 Indicates that the file is a data file EXEC 3 Indicates that the file is an executable file","title":"SPL constants identifying the File Type/Permission in Inode Table"},{"location":"support-tools/constants/#spl-constants-related-to-per-process-resource-table","text":"Name Default Value Comments FILE 0 Indicates that the resource is a file in the resource table SEMAPHORE 1 Indicates that the resource is a semaphore in the resource table RESOURCE_TABLE_OFFSET 496 Offset of the Resource Table from the start of user area page","title":"SPL constants related to Per-process Resource Table"},{"location":"support-tools/constants/#spl-constants-related-to-swapping","text":"Name Default Value Comments MEM_LOW 4 Memory is critically low so that swap out has to be initiated MEM_HIGH 12 Memory is high enough such that a process can be swapped in MAX_TICK 1000 Indicates the threshold after which a swapped out process must be swapped back in","title":"SPL constants related to Swapping"},{"location":"support-tools/constants/#spl-constants-related-to-expfs-disk-see-disk-origanisation","text":"Name Default Value Comments XFS_BSIZE 512 Number of words in a disk block MAX_FILE_BLOCKS 4 Maximum number of blocks allocatable to each file. DISK_SWAP_AREA 256 Starting block number of Swap Area in the disk DISK_FREE_AREA 69 Starting block number of User Block area in the disk DISK_SIZE 512 Number of blocks in the disk","title":"SPL constants related to eXpFS Disk (See Disk Origanisation)"},{"location":"support-tools/constants/#spl-constants-defining-the-maximum-limits","text":"Name Default Value Comments PAGE_SIZE 512 Size of a memory page in eXpOS NUM_MEM_PAGES 128 Number of memory pages in eXpOS MAX_PROC_NUM 16 Max. number of process allowed by eXpOS PT_ENTRY_SIZE 16 Size of one page table entry MAX_OPENFILE_NUM 32 Max. number of open files allowed by eXpOS MAX_MEM_PAGE 128 Max. number of memory pages availble to eXpOS MAX_SEM_COUNT 32 Max. number of semaphores allowed by eXpOS MAX_PROC_PAGES 10 Max. number of pages allowed for each process MAX_BUFFER 4 Max. number of file read/write buffers in eXpOS MAX_FILE_NUM 60 Max. number of files possible MAX_FILE_SIZE 2048 Max. words in a file MAX_USER_NUM 16 Max. number of users allowed","title":"SPL constants defining the maximum limits"},{"location":"support-tools/constants/#miscellaneous-constants","text":"Name Default Value Comments INODE_ROOT 0 Inode Index field of the Open File Table is set to INODE_ROOT if the file is the Root file. KERNEL 0 Indicates the Kernel user in the CURRENT_USER_ID field of the System Status Table ZERO 0 Zero ONE 1 One","title":"Miscellaneous Constants"},{"location":"support-tools/constants/#constants-for-nexsm","text":"Name Default Value Comments OS_SECONDARY 65536 Starting address of OS Startup code for secondary core. INT_19 66560 (Test4, 100), (Test5, 101), (Test6, 102), (Test7, 103) MOD_8 / ACCESS_CONTROL 67584 Access Control Module MOD_9 / TESTA 68608 TestA (Reserved for Future use) MOD_10 / TESTB 69632 TestB (Reserved for Future use) MOD_11 / TESTC 70656 TestC (Reserved for Future use) IDLE2_PROCESS 14 PID of the Idle Process for secondary core INT_TEST4 100 Test System Call 4 INT_TEST5 101 Test System Call 5 INT_TEST6 102 Test System Call 6 INT_TEST7 103 Test System Call 7 ACQUIRE_KERN_LOCK 1 Access Control Module Function #1 ACQUIRE_SCHED_LOCK 2 Access Control Module Function #2 ACQUIRE_GLOCK 3 Access Control Module Function #3 RELEASE_LOCK 4 Access Control Module Function #4 PRIMARY_CORE 0 Indicates that the current core is primary core SECONDARY_CORE 1 Indicates that the current core is secondary core ACCESS_LOCK_TABLE 29576 Starting address of Access Lock Table KERN_LOCK 29576 Kernel Lock SCHED_LOCK 29577 Scheduler Lock GLOCK 29578 General Purpose Lock NUM_MEM_PAGES * 144 Number of memory pages in eXpOS DISK_SIZE * 528 Number of blocks in the disk","title":"Constants for NEXSM"},{"location":"support-tools/docker-setup/","text":"Install and setup Docker on host machine \u00b6 Follow the instructions available here to install docker on your machine. You could also go through the Docker quick start quide to know more about Docker . Warning The following has not been tested on Windows . If you encounter any issues/ has suggestions raise an issue here Setting up \u00b6 We'll assume the following directory structure . \u251c\u2500\u2500 Dockerfile \u2514\u2500\u2500 workdir/ # <- user files will be stored here and mapped to container We'll store the user written code in workdir and map the same into the container. We can create the structure using the below commands Windows (Powershell) cd < your directory > New-Item Dockerfile New-Item -path workdir -ItemType directory Unix / Linux cd <your directory> touch Dockerfile mkdir workdir The contents of Dockerfile are given below FROM ubuntu:20.04 RUN apt-get update \\ && apt-get install -y bison flex libreadline-dev libc6-dev libfl-dev wget vim make gcc curl unzip build-essential RUN useradd -m expos USER expos RUN cd /home/expos \\ && curl -sSf https://raw.githubusercontent.com/eXpOSNitc/expos-bootstrap/main/download.sh | sh \\ && cd /home/expos/myexpos \\ && make WORKDIR /home/expos/myexpos The given Dockerfile will setup expos environment as specified in Setting Up Page Building the container image \u00b6 We'll now build the container image using the Dockerfile docker build -t expos:ubuntu20.04 . Start the container instance \u00b6 We'll start an instance of Container and map the local folder workdir into /home/expos/workdir directory of container. Windows (PowerShell) docker run -v ${ PWD }/ workdir :/ home / expos / myexpos / workdir -d - -name expos -i expos : ubuntu20 . 04 Unix / Linux docker run -v $PWD /workdir:/home/expos/myexpos/workdir -d --name expos -i expos:ubuntu20.04 We now have a container instance running in background with the name expos and required volume mounts Connecting to the container \u00b6 We can connect to the container instance using the following commands docker start expos # if the container instance is not already running docker exec -it expos /bin/bash # to get a bash shell inside the container After connecting to the container you can use spl , expl , xfs-interface , and xsm binaries as mentioned in Setting Up Page","title":"Docker based setup"},{"location":"support-tools/docker-setup/#install-and-setup-docker-on-host-machine","text":"Follow the instructions available here to install docker on your machine. You could also go through the Docker quick start quide to know more about Docker . Warning The following has not been tested on Windows . If you encounter any issues/ has suggestions raise an issue here","title":"Install and setup Docker on host machine"},{"location":"support-tools/docker-setup/#setting-up","text":"We'll assume the following directory structure . \u251c\u2500\u2500 Dockerfile \u2514\u2500\u2500 workdir/ # <- user files will be stored here and mapped to container We'll store the user written code in workdir and map the same into the container. We can create the structure using the below commands Windows (Powershell) cd < your directory > New-Item Dockerfile New-Item -path workdir -ItemType directory Unix / Linux cd <your directory> touch Dockerfile mkdir workdir The contents of Dockerfile are given below FROM ubuntu:20.04 RUN apt-get update \\ && apt-get install -y bison flex libreadline-dev libc6-dev libfl-dev wget vim make gcc curl unzip build-essential RUN useradd -m expos USER expos RUN cd /home/expos \\ && curl -sSf https://raw.githubusercontent.com/eXpOSNitc/expos-bootstrap/main/download.sh | sh \\ && cd /home/expos/myexpos \\ && make WORKDIR /home/expos/myexpos The given Dockerfile will setup expos environment as specified in Setting Up Page","title":"Setting up"},{"location":"support-tools/docker-setup/#building-the-container-image","text":"We'll now build the container image using the Dockerfile docker build -t expos:ubuntu20.04 .","title":"Building the container image"},{"location":"support-tools/docker-setup/#start-the-container-instance","text":"We'll start an instance of Container and map the local folder workdir into /home/expos/workdir directory of container. Windows (PowerShell) docker run -v ${ PWD }/ workdir :/ home / expos / myexpos / workdir -d - -name expos -i expos : ubuntu20 . 04 Unix / Linux docker run -v $PWD /workdir:/home/expos/myexpos/workdir -d --name expos -i expos:ubuntu20.04 We now have a container instance running in background with the name expos and required volume mounts","title":"Start the container instance"},{"location":"support-tools/docker-setup/#connecting-to-the-container","text":"We can connect to the container instance using the following commands docker start expos # if the container instance is not already running docker exec -it expos /bin/bash # to get a bash shell inside the container After connecting to the container you can use spl , expl , xfs-interface , and xsm binaries as mentioned in Setting Up Page","title":"Connecting to the container"},{"location":"support-tools/expl/","text":"ExpL is a simple programming language designed specifically for instructional purposes. Application programs for eXpOS may be written in ExpL. Specification Of ExpL \u00b6 The exposcall() interface \u00b6 The ExpL compiler supplied along with the eXpOS pakage extents the language with an additional eXpOS library interface function exposcall(). ExpL programs can invoke eXpOS system calls and dynamic memory allocation routines supported by the library by passing appropriate arguments to the exposcall() function. The exposcall() interface is given in detail here","title":"ExpL"},{"location":"support-tools/expl/#specification-of-expl","text":"","title":"Specification Of ExpL"},{"location":"support-tools/expl/#the-exposcall-interface","text":"The ExpL compiler supplied along with the eXpOS pakage extents the language with an additional eXpOS library interface function exposcall(). ExpL programs can invoke eXpOS system calls and dynamic memory allocation routines supported by the library by passing appropriate arguments to the exposcall() function. The exposcall() interface is given in detail here","title":"The exposcall() interface"},{"location":"support-tools/setting-up/","text":"The following setup instructions assume that you have a Linux based machine. If these instructions do not work, you can try the Docker based setup . Setting up \u00b6 1) Install prerequisites such as gcc, make, readline, flex/lex, bison/yacc Debian-based distros sudo apt-get install libreadline-dev flex bison make gcc wget curl RedHat Linux based distros sudo yum install readline-devel flex flex-devel byacc make gcc wget curl Arch Linux sudo pacman -S readline flex bison make gcc wget curl 2) In your terminal, copy and paste the following snippet and press enter: curl -sSf https://raw.githubusercontent.com/eXpOSNitc/expos-bootstrap/main/download.sh | sh When the script finishes executing, you will have a directory myexpos in your home drectory, with all components required for building your own eXpOS. 3) Change directory to myexpos directory. cd $HOME/myexpos 4) Make to build all the components. make If the setup worked correctly, the following executables will be created: spl in $HOME/myexpos/spl folder expl in $HOME/myexpos/expl folder xfs-interface in $HOME/myexpos/xfs-interface folder xsm in $HOME/myexpos/xsm folder If the setting up of the system is done correctly the following directories will be created. $HOME/myexpos/expl This directory contains the ExpL (Experimental Language) compiler required to compile user programs to XSM machine instructions. $HOME/myexpos/spl This directory contains the SPL (System Programmer's Language) Compiler required to compile system programs (i.e. operating system routines) to XSM machine instructions. $HOME/myexpos/xfs-interface This directory contains an interface ( XFS Interface or eXperimental File System Interface) through which files from your UNIX machine can be loaded into the File System of XSM. The interface can format the disk, dump the disk data structures, load/remove files, list files, transfer data and executable files between eXpFS filesystem and the host (UNIX) file system and copy specified blocks of the XFS disk to a UNIX file. $HOME/myexpos/xsm This directory contains the machine simulator ( XSM or eXperimental String Machine). $HOME/myexpos/test This directory contains the test scripts for eXpOS Setting Up (NEXSM) \u00b6 Warning This is relevant only for Stage 28 of the Roadmap. 1) Download the complete eXpOS package from here . 2) Copy the tar file to your home directory. cp nexpos.tar.gz $HOME/ cd $HOME 3) Extract the contents using the command. tar -xvf nexpos.tar.gz Now you will have a directory myexpos in your home drectory, with all components required for building your own eXpOS. 4) Install libreadline-dev package sudo apt-get install libreadline-dev 5) Make sure all the prerequisites which include gcc , flex / lex and bison / yacc are installed. In Ubuntu/Debian systems, use apt to install flex and bison sudo apt-get install flex bison 6) Change directory to mynexpos directory. cd $HOME/mynexpos 7) Make to build all the components. ./make If the setup worked correctly, the following executables will be created: spl in $HOME/mynexpos/nespl folder expl in $HOME/mynexpos/expl folder xfs-interface in $HOME/mynexpos/nexfs-interface folder xsm in $HOME/mynexpos/nexsm folder If the setting up of the system is done correctly the following directories will be created. $HOME/mynexpos/expl This directory contains the ExpL (Experimental Language) compiler required to compile user programs to NEXSM machine instructions. $HOME/mynexpos/nespl This directory contains the SPL (System Programmer's Language) Compiler required to compile system programs (i.e. operating system routines) to NEXSM machine instructions. $HOME/mynexpos/nexfs-interface This directory contains an interface ( XFS Interface or eXperimental File System Interface) through which files from your UNIX machine can be loaded into the File System of NEXSM. The interface can format the disk, dump the disk data structures, load/remove files, list files, transfer data and executable files between eXpFS filesystem and the host (UNIX) file system and copy specified blocks of the XFS disk to a UNIX file. $HOME/mynexpos/nexsm This directory contains the machine simulator ( NEXSM or NExt eXperimental String Machine). $HOME/mynexpos/test This directory contains the test scripts for eXpOS .","title":"Setting up"},{"location":"support-tools/setting-up/#setting-up","text":"1) Install prerequisites such as gcc, make, readline, flex/lex, bison/yacc Debian-based distros sudo apt-get install libreadline-dev flex bison make gcc wget curl RedHat Linux based distros sudo yum install readline-devel flex flex-devel byacc make gcc wget curl Arch Linux sudo pacman -S readline flex bison make gcc wget curl 2) In your terminal, copy and paste the following snippet and press enter: curl -sSf https://raw.githubusercontent.com/eXpOSNitc/expos-bootstrap/main/download.sh | sh When the script finishes executing, you will have a directory myexpos in your home drectory, with all components required for building your own eXpOS. 3) Change directory to myexpos directory. cd $HOME/myexpos 4) Make to build all the components. make If the setup worked correctly, the following executables will be created: spl in $HOME/myexpos/spl folder expl in $HOME/myexpos/expl folder xfs-interface in $HOME/myexpos/xfs-interface folder xsm in $HOME/myexpos/xsm folder If the setting up of the system is done correctly the following directories will be created. $HOME/myexpos/expl This directory contains the ExpL (Experimental Language) compiler required to compile user programs to XSM machine instructions. $HOME/myexpos/spl This directory contains the SPL (System Programmer's Language) Compiler required to compile system programs (i.e. operating system routines) to XSM machine instructions. $HOME/myexpos/xfs-interface This directory contains an interface ( XFS Interface or eXperimental File System Interface) through which files from your UNIX machine can be loaded into the File System of XSM. The interface can format the disk, dump the disk data structures, load/remove files, list files, transfer data and executable files between eXpFS filesystem and the host (UNIX) file system and copy specified blocks of the XFS disk to a UNIX file. $HOME/myexpos/xsm This directory contains the machine simulator ( XSM or eXperimental String Machine). $HOME/myexpos/test This directory contains the test scripts for eXpOS","title":"Setting up"},{"location":"support-tools/setting-up/#setting-up-nexsm","text":"Warning This is relevant only for Stage 28 of the Roadmap. 1) Download the complete eXpOS package from here . 2) Copy the tar file to your home directory. cp nexpos.tar.gz $HOME/ cd $HOME 3) Extract the contents using the command. tar -xvf nexpos.tar.gz Now you will have a directory myexpos in your home drectory, with all components required for building your own eXpOS. 4) Install libreadline-dev package sudo apt-get install libreadline-dev 5) Make sure all the prerequisites which include gcc , flex / lex and bison / yacc are installed. In Ubuntu/Debian systems, use apt to install flex and bison sudo apt-get install flex bison 6) Change directory to mynexpos directory. cd $HOME/mynexpos 7) Make to build all the components. ./make If the setup worked correctly, the following executables will be created: spl in $HOME/mynexpos/nespl folder expl in $HOME/mynexpos/expl folder xfs-interface in $HOME/mynexpos/nexfs-interface folder xsm in $HOME/mynexpos/nexsm folder If the setting up of the system is done correctly the following directories will be created. $HOME/mynexpos/expl This directory contains the ExpL (Experimental Language) compiler required to compile user programs to NEXSM machine instructions. $HOME/mynexpos/nespl This directory contains the SPL (System Programmer's Language) Compiler required to compile system programs (i.e. operating system routines) to NEXSM machine instructions. $HOME/mynexpos/nexfs-interface This directory contains an interface ( XFS Interface or eXperimental File System Interface) through which files from your UNIX machine can be loaded into the File System of NEXSM. The interface can format the disk, dump the disk data structures, load/remove files, list files, transfer data and executable files between eXpFS filesystem and the host (UNIX) file system and copy specified blocks of the XFS disk to a UNIX file. $HOME/mynexpos/nexsm This directory contains the machine simulator ( NEXSM or NExt eXperimental String Machine). $HOME/mynexpos/test This directory contains the test scripts for eXpOS .","title":"Setting Up (NEXSM)"},{"location":"support-tools/spl/","text":"SPL or System Programmer's Language in reality is not a high level programming language, but an enriched assembly language programming system for writing protected mode programs for the XSM machine. This language is useful for implementation of an OS on top of the XSM machine. The language is minimalistic and consists only of very basic constructs. Programming using SPL requires an understanding of the underlying XSM architecture . Each SPL program is considered as a module . A module consists of a maximum of 1024 words which includes both the space allocated for code and data. Particular class of modules called Interrupt Service Routines can be invoked from the application by the INT instruction. Other modules can only be invoked from the kernel. The SPL compiler translates an SPL source program to a target XSM assembly module. (See Loading modules into the disk architecture) . This specification defines the syntax and semantics of the basic constructs of the SPL language and also specifies the programming conventions recommended in using the langugage. The default SPL compiler provided as part of the eXpOS package is designed to follow the programming conventions specified in this document. Lexical Elements \u00b6 Comments and White Spaces \u00b6 SPL allows only single line comments. Comments start with the character sequence // and stop at the end of the line. White spaces in the program including tabs, newline and horizontal spaces are ignored. Keywords \u00b6 The following are the reserved words in SPL and it cannot be used as identifiers. alias define encrypt breakpoint inline halt goto call return ireturn backup restore readi read print loadi load store do while endwhile break continue if then else endif tsl* start* reset* * These keywords are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine. Operators and Delimiters \u00b6 The following are the operators and delimiters in SPL ( ) ; [ ] / * + - % : > < >= <= != == = && || ! Registers and Ports \u00b6 SPL allows the use of 25 registers ( R0 - R15 , BP , SP , IP , PTBR , PTLR , EIP , EC , EPN , EMA ) and 4 ports ( P0 - P3 ). P0 and P1 are used for standard input and standard output respectively. Identifiers \u00b6 Identifiers are used as symbolic names for constants and aliases for registers. Identifiers should start with an alphabet but may contain alphabets, digits and/or underscore ( _ ). No other special characters are allowed in identifiers. Examples: Valid : var1, new_page Invalid : 9blocks, $n etc. Literals \u00b6 Integer and String literals are permitted in SPL. An integer literal is a sequence of digits representing an integer. Negative integers are represented with a negative sign preceding the sequence of digits. eg. 3 , -512 , 1024 A string literal is a sequence of characters which are enclosed within double quotes (\" \").eg. \"alice\" Labels \u00b6 SPL supports labels which are used along with goto and call. Labels follow the same naming convention as that of the identifiers. eg. label1: . . . goto label1 Registers and Ports \u00b6 SPL provides a fixed set of registers and ports are provided. The register set in SPL contains 29 registers. There is a direct mapping between these registers and the machine registers in XSM. There are 4 ports supported. Name Register/Port Program Registers R0 - R15 Reserved Registers (For the use of SPL compiler) R16 - R19 Base Pointer BP Stack Pointer SP Instruction Pointer IP Page Table Base Register PTBR Page Table Length Register PTLR Exception Instruction Pointer EIP Exception Cause EC Exception Page Number EPN Exception Memory Address EMA Input Port P0 Output Port P1 Unused Ports P2, P3 Core Flag CORE This is an extra read-only register available only on NEXSM machine (a two-core extension of XSM). Aliasing \u00b6 Any register/port can be referred to by using a different name. A name is assigned to a particular register/port using the alias keyword. Each register/port can be assigned to only one alias at any particular point of time. However, a register/port can be reassigned to a different alias at a later point. Aliasing can also be done inside the if and while block. However, an alias defined within the if and while blocks will only be valid within the block. No two registers/ports can have the same alias name simultaneously. Constants \u00b6 Symbolic names for values can be defined in an SPL module using the define keyword. They will be visible only inside the module. Unlike aliasing, two or more names can be assigned to the same value. A constant can only be defined once in a program. Predefined Constants \u00b6 SPL provides a set of predefined constants defined in the file splconstants.cfg . The standard SPL implementation comes with a set of pre-defined constants included in the splconstants.cfg file specifically tuned for the implementation of eXpOS on the XSM architecture. These constants are mostly the starting addresses of various OS data structures/handlers in the memory which are specified in the implementation of the eXpOS. Users can also define constants which are visible in all SPL modules by including the definition in the splconstants.cfg file. If a constant defined in the splconstants.cfg file is re-defined in a module, the local definition will override the global definition. These predefined constants' definitions can be over-ruled by assigning different values explicitly by the user using the define keyword. Expressions \u00b6 An expression specifies the computation of a value by applying operators to operands. SPL supports arithmetic and logical expressions. Arithmetic Expressions \u00b6 Registers, constants and two or more arithmetic expressions connected using arithmetic operators are categorized as arithmetic expressions. SPL provides five arithmetic operators, viz., +, -, *, / (Integer Division) and % (Modulo operator) through which arithmetic expressions may be combined. Expression syntax and semantics are similar to standard practice in programming languages and normal rules of precedence, associativity and paranthesization hold. Examples: (5*R4) + 3 10 % 4 Logical Expressions \u00b6 Logical expressions may be formed by combining arithmetic expressions using relational operators. The relational operators supported by SPL are >, <, >=, <=, !=, == . Standard meanings apply to these operators. A relational operator will take in two arguments and return 1 if the relation is valid and 0 otherwise. The relational operators can also be applied to strings. <, >, <=, >= compares two strings lexicographically. != and == checks for equality in the case of strings. If one of the operands is a string, the other operand will also be considered as a string. Examples: \"adam\" < \"apple\" // This returns 1 \"hansel\" == \"gretel\" // This returns 0 \"3\" == 3 // This returns 1, as 3 will be treated as \"3\" Logical expressions themselves may be combined using logical operators, && (logical and) , || (logical or) and ! (not). Addressing Expressions \u00b6 Memory of the machine can be directly accessed in an SPL program. A word in the memory is accessed by specifying the addressing element, i.e. memory location within [ ] . This corresponds to the value stored in the given address. An arithmetic expression or an addressing expression can be used to specify the address. Examples: [1024], [R3], [R5+[R7]+128], [INODE\\_TABLE + R2] etc. Statements \u00b6 Statements control the execution of the program. All statements in SPL are terminated with a semicolon ( ; ) . Define Statement \u00b6 The define statement is used to define a symbolic name for a value. Define statements should be used before any other statement in an SPL program. The keyword define is used to associate a literal to a symbolic name. SYNTAX : define constant_name value; ; define DISK\\_BLOCK 437; Alias Statement \u00b6 An alias statement is used to associate a register/port with a name. Alias statements can be used anywhere in the program. SYNTAX : alias alias_name register_name; alias counter R0; Breakpoint Statement \u00b6 The breakpoint statement is used to debug the program. The program when run in the debug mode pauses the execution at this instruction. SYNTAX : breakpoint; This statement translates to BRKP machine instruction . Assignment Statement \u00b6 The SPL assignment statement assigns the value of an expression/value stored in a memory address to a register/memory address. = is the assignment operator used in SPL. The operand on the right hand side of the operator is assigned to the left hand side. SYNTAX : Register / Alias / [Address] = Register / Port / Number / String / Expression / [Address]; R2 = P0; [PTBR + 3] = [1024] + 10; R1 = \"hello world\"; If Statement \u00b6 If statement specifies the conditional execution of two branches according to the value of a logical expression. If the expression evaluates to 1, the if branch is executed, otherwise the else branch is executed. The else part is optional. SYNTAX : if (logical expression) then statements; else statements; endif ; While Statement \u00b6 While statement iteratively executes a set of statements based on a condition. The condition is defined using a logical expression. The statements are iteratively executed as long as the condition is true. SYNTAX : while (logical expression) do statements; endwhile ; Break Statement \u00b6 Break statement when used inside a while loop block, stops the execution of the loop in which it is used and passes the control of execution to the next statement after the loop. This statement cannot be used anywhere else other than while loop. SYNTAX : break; Continue Statement \u00b6 Continue statement when used inside a while loop block, skips the current iteration of the loop and passes the control to the next iteration after checking the loop condition. SYNTAX : continue; ireturn Statement \u00b6 ireturn statement or the Interrupt Return statement is used to pass control from a kernel mode interrupt service routine to the user mode program which invoked it. SYNTAX : ireturn ; The ireturn is generally used at the end of an interrupt code. This statement translates to IRET machine instruction . Read/Print Statements \u00b6 The read and print statements are used as standard input and output statements. The read statement initiates the transfer of a string from the console to the standard input port P0 using the IN machine instruction. The machine proceeds to execute the next instruction without waiting for the completion of the string transfer. Note String read or printed must not exceed 10 characters. The print statement outputs value of a register or an integer/string literal or value of a memory location. SYNTAX : read; print** Register / Number / String / Expression / [Address]; Readi Statement \u00b6 The readi statement reads a value from the standard input device and stores it in a register using the INI machine instruction (which can be used only in debug mode). Note String read must not exceed 10 characters. SYNTAX : readi Register; Load/Store Statements \u00b6 Loading and storing between the disk and the memory of the XSM machine can be accomplished using load and store statements in SPL. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. load statement loads the block specified by block_number from the disk to the the page specified by the page_number in the memory. store statement stores the page specified by page_number in the memory to the the block specified by the block_number in the disk. The page_number and block_number can be specified using arithmetic expressions. SYNTAX : load (page_number, block_number); store (page_number, block_number); Loadi Statement \u00b6 Loading from the disk to the memory of the XSM machine can also be accomplished using loadi statement in SPL. But here, the machine will continue execution of the next instruction only after the block transfer is completed. loadi statement loads the block specified by block_number from the disk to the the page specified by the page_number in the memory. The page_number and block_number can be specified using arithmetic expressions. SYNTAX : loadi (page\\_number, block\\_number); Multipush Statement \u00b6 Multipush statement is used to push a sequence of registers into the memory locations starting from the address pointed to by SP. The registers are pushed in the order in which they are specified in the statement. SYNTAX : multipush (Register1, Register2, ...); Multipop Statement \u00b6 Multipop statement is used to pop a sequence of registers from the memory locations starting from the address pointed to by SP. The registers are popped in the reverse order in which they are specified in the statement. SYNTAX : multipop (Register1, Register2, ...); Backup Statement \u00b6 The backup statement is used to backup all the machine registers (except SP, IP, exception flag registers and ports) into the memory locations starting from the address pointed to by SP in the order : BP, PTBR, PTLR, R0 - R19. The value of SP gets incremented accordingly. SYNTAX : backup; This statement translates to the BACKUP machine instruction . Restore Statement \u00b6 The restore statement is used to restore the backed up machine registers from the memory. The registers are restored from contiguous memory locations starting from the address pointed to by SP in the order : R19-R0, PTLR, PTBR, BP. The value of SP gets decremented accordingly. SYNTAX : restore; This statement translates to the RESTORE machine instruction . Encrypt Statement \u00b6 The encrypt statement replaces the value in the register Ri with its encrypted value. SYNTAX : encrypt Ri; This statement translates to the ENCRYPT machine instruction . Goto Statement \u00b6 The goto statement transfers control to the specified labelled statement. SYNTAX : goto label / INT_n / MOD_n / constants; (See SPL constants ) goto label1; goto INT\\_7; goto MOD\\_2; goto MEMORY\\_MANAGER; Note label should be defined within the module. Call Statement \u00b6 The call statement saves procedure linking information on the stack and branches to the procedure specified by the argument. SYNTAX : call label / INT_n / MOD _n / constants;` (See SPL constants ) call swap\\_func; call INT\\_7; call MOD\\_2; call MEMORY\\_MANAGER; Note label should be defined within the module. Call statement translates to the CALL machine instruction . Return Statement \u00b6 The return statement is used to transfer the control from a subroutine to the calling program in the kernel mode and the return address is popped from the stack. SYNTAX : return; This statement translates to the RET machine instruction . Halt Statement \u00b6 The halt statement is used to halt the machine. SYNTAX : halt; This statement translates to HALT machine instruction . Inline Statement \u00b6 The inline statement is used to give XSM machine instructions directly within an SPL program. SYNTAX : inline \"MACHINE INSTRUCTION\" ; inline \"JMP 11776\"; Functions \u00b6 SPL does not provide explicit support for functions. However, a label can be defined at the beginning of the code for a function and the code can be invoked using the call instruction using the label. This allows use of functions inside a module. Labels defined in one module will not be visible in other modules. If parameters are to be passed to a function, it has to be explictly passed either using agreed upon registers or using a stack. A function loaded at a particular known location in memory (either specified directly by the memory address or using a pre-defined constant) can be invoked by a call to the corresponding memory address. However, it is recommended to follow the conventions discussed below in inter-module calls. call swap; call MOD\\_4; call 511; /* Transfers control to the first page in memory */ SPL Interrupt Handler and Module Programming Conventions \u00b6 Each SPL System Call Handler/Interrupt Handler/Module is designed to occupy a maximum of two pages of continuous memory in the XSM machine. (Sometimes, the generic term \"module\" is abused to indicate all types of routines of the above categories, though we avoid this usage here). They contain protected mode code that carries out certain functions as determined by the OS programmer. The following suggests certain programming conventions which are recommend while designing SPL modules and interrupt handlers. These routines may be entered as a result of: 1. A system call handler is entered upon execution of a software interrupt from an application (user mode) program. 2. A hardware interrupt/exception is executed when the machine raises a corresponding hardware signal/exception while an application was executing. 3. A module may invoked from another module or Interrupt handler. Case a: (Software Interrupts) In this case, the arguments to the module are passed through the application program stack. The return values are also passed through the same stack. The convention is that the application must save the state of its registers before making the call . (For instance, the eXpL compiler will save the caller context in the user stack before invoking a software interrupt). Thus, the interrupt routine need not concern itself about saving the context of the application and can use the registers R0-R15 without saving them. However, the application is not expected to save the SP register before the call, and the module must save it for future return. In this case the kernel module must switch to the kernel stack and not use the application's stack. This is to avoid potential user level \u201chacks\u201d into the interrupt modules through the stack. Case b: (Hardware Interrupts) This case applies to the exception handler, timer interrupt routine, disk interrupt routine and the console interrupt routine. The difference here from Case a) is that the application does not have control over the transfer to the interrupt module, and hence would not have saved its context. Thus, in this case, the module must save the register context of the application in its own stack (or elsewhere in the memory) before using the registers and must restore the context before returning to the application. In this case also the module is expected to allocate its own stack in the memory and not use the application's stack. Case c: (Modules) In this case, since the caller and the callee are both executing in protected mode, the same stack can be used. Here, the recommended parameter passing convention is to use R1, R2... for argument_1, argument_2, argument_3... The return value of the module may be stored in R0. This convention is recommended instead of using the stack for passing arguments for improving efficiency. As in the previous cases, the caller must save the values of the registers in use into the stack before the call. Note The SPL compiler given here uses the constants (given in splconstants.cfg file) MOD_0 to MOD_7 as starting address of eXpOS kernel modules. eXpOS kernel loads these modules into various pre-defined memory pages of the XSM machine on startup. In addition to these, all interrupt service routines can be programmed as SPL modules and loaded to the corresponding interrupt service routine locations in memory. SPL Specification for NEXSM \u00b6 The following additonal instructions are available in SPL when running on the NEXSM machine , which is a two core extension for XSM. TSL Expression \u00b6 The contents of the memory location specified by ADDRESS is returned and the value at ADDRESS is set to 1. SYNTAX : tsl (ADDRESS) Examples: while( tsl(KERN\\_LOCK) == 1 ) do continue; endwhile; This statement translates to a sequence of instructions that uses the TSL machine instruction . START Statement \u00b6 The start instruction when executed from primary core of the NEXSM machine will start the secondary core into parallel execution. SYNTAX : start; This statement translates to the START machine instruction . RESET Statement \u00b6 The reset instruction when executed from primary core of the NEXSM machine will freeze the secondary core. SYNTAX : reset; This statement translates to the RESET machine instruction .","title":"SPL"},{"location":"support-tools/spl/#lexical-elements","text":"","title":"Lexical Elements"},{"location":"support-tools/spl/#comments-and-white-spaces","text":"SPL allows only single line comments. Comments start with the character sequence // and stop at the end of the line. White spaces in the program including tabs, newline and horizontal spaces are ignored.","title":"Comments and White Spaces"},{"location":"support-tools/spl/#keywords","text":"The following are the reserved words in SPL and it cannot be used as identifiers. alias define encrypt breakpoint inline halt goto call return ireturn backup restore readi read print loadi load store do while endwhile break continue if then else endif tsl* start* reset* * These keywords are available only on eXpOS running on NEXSM (a two-core extension of XSM) machine.","title":"Keywords"},{"location":"support-tools/spl/#operators-and-delimiters","text":"The following are the operators and delimiters in SPL ( ) ; [ ] / * + - % : > < >= <= != == = && || !","title":"Operators and Delimiters"},{"location":"support-tools/spl/#registers-and-ports","text":"SPL allows the use of 25 registers ( R0 - R15 , BP , SP , IP , PTBR , PTLR , EIP , EC , EPN , EMA ) and 4 ports ( P0 - P3 ). P0 and P1 are used for standard input and standard output respectively.","title":"Registers and Ports"},{"location":"support-tools/spl/#identifiers","text":"Identifiers are used as symbolic names for constants and aliases for registers. Identifiers should start with an alphabet but may contain alphabets, digits and/or underscore ( _ ). No other special characters are allowed in identifiers. Examples: Valid : var1, new_page Invalid : 9blocks, $n etc.","title":"Identifiers"},{"location":"support-tools/spl/#literals","text":"Integer and String literals are permitted in SPL. An integer literal is a sequence of digits representing an integer. Negative integers are represented with a negative sign preceding the sequence of digits. eg. 3 , -512 , 1024 A string literal is a sequence of characters which are enclosed within double quotes (\" \").eg. \"alice\"","title":"Literals"},{"location":"support-tools/spl/#labels","text":"SPL supports labels which are used along with goto and call. Labels follow the same naming convention as that of the identifiers. eg. label1: . . . goto label1","title":"Labels"},{"location":"support-tools/spl/#registers-and-ports_1","text":"SPL provides a fixed set of registers and ports are provided. The register set in SPL contains 29 registers. There is a direct mapping between these registers and the machine registers in XSM. There are 4 ports supported. Name Register/Port Program Registers R0 - R15 Reserved Registers (For the use of SPL compiler) R16 - R19 Base Pointer BP Stack Pointer SP Instruction Pointer IP Page Table Base Register PTBR Page Table Length Register PTLR Exception Instruction Pointer EIP Exception Cause EC Exception Page Number EPN Exception Memory Address EMA Input Port P0 Output Port P1 Unused Ports P2, P3 Core Flag CORE This is an extra read-only register available only on NEXSM machine (a two-core extension of XSM).","title":"Registers and Ports"},{"location":"support-tools/spl/#aliasing","text":"Any register/port can be referred to by using a different name. A name is assigned to a particular register/port using the alias keyword. Each register/port can be assigned to only one alias at any particular point of time. However, a register/port can be reassigned to a different alias at a later point. Aliasing can also be done inside the if and while block. However, an alias defined within the if and while blocks will only be valid within the block. No two registers/ports can have the same alias name simultaneously.","title":"Aliasing"},{"location":"support-tools/spl/#constants","text":"Symbolic names for values can be defined in an SPL module using the define keyword. They will be visible only inside the module. Unlike aliasing, two or more names can be assigned to the same value. A constant can only be defined once in a program.","title":"Constants"},{"location":"support-tools/spl/#predefined-constants","text":"SPL provides a set of predefined constants defined in the file splconstants.cfg . The standard SPL implementation comes with a set of pre-defined constants included in the splconstants.cfg file specifically tuned for the implementation of eXpOS on the XSM architecture. These constants are mostly the starting addresses of various OS data structures/handlers in the memory which are specified in the implementation of the eXpOS. Users can also define constants which are visible in all SPL modules by including the definition in the splconstants.cfg file. If a constant defined in the splconstants.cfg file is re-defined in a module, the local definition will override the global definition. These predefined constants' definitions can be over-ruled by assigning different values explicitly by the user using the define keyword.","title":"Predefined Constants"},{"location":"support-tools/spl/#expressions","text":"An expression specifies the computation of a value by applying operators to operands. SPL supports arithmetic and logical expressions.","title":"Expressions"},{"location":"support-tools/spl/#arithmetic-expressions","text":"Registers, constants and two or more arithmetic expressions connected using arithmetic operators are categorized as arithmetic expressions. SPL provides five arithmetic operators, viz., +, -, *, / (Integer Division) and % (Modulo operator) through which arithmetic expressions may be combined. Expression syntax and semantics are similar to standard practice in programming languages and normal rules of precedence, associativity and paranthesization hold. Examples: (5*R4) + 3 10 % 4","title":"Arithmetic Expressions"},{"location":"support-tools/spl/#logical-expressions","text":"Logical expressions may be formed by combining arithmetic expressions using relational operators. The relational operators supported by SPL are >, <, >=, <=, !=, == . Standard meanings apply to these operators. A relational operator will take in two arguments and return 1 if the relation is valid and 0 otherwise. The relational operators can also be applied to strings. <, >, <=, >= compares two strings lexicographically. != and == checks for equality in the case of strings. If one of the operands is a string, the other operand will also be considered as a string. Examples: \"adam\" < \"apple\" // This returns 1 \"hansel\" == \"gretel\" // This returns 0 \"3\" == 3 // This returns 1, as 3 will be treated as \"3\" Logical expressions themselves may be combined using logical operators, && (logical and) , || (logical or) and ! (not).","title":"Logical Expressions"},{"location":"support-tools/spl/#addressing-expressions","text":"Memory of the machine can be directly accessed in an SPL program. A word in the memory is accessed by specifying the addressing element, i.e. memory location within [ ] . This corresponds to the value stored in the given address. An arithmetic expression or an addressing expression can be used to specify the address. Examples: [1024], [R3], [R5+[R7]+128], [INODE\\_TABLE + R2] etc.","title":"Addressing Expressions"},{"location":"support-tools/spl/#statements","text":"Statements control the execution of the program. All statements in SPL are terminated with a semicolon ( ; ) .","title":"Statements"},{"location":"support-tools/spl/#define-statement","text":"The define statement is used to define a symbolic name for a value. Define statements should be used before any other statement in an SPL program. The keyword define is used to associate a literal to a symbolic name. SYNTAX : define constant_name value; ; define DISK\\_BLOCK 437;","title":"Define Statement"},{"location":"support-tools/spl/#alias-statement","text":"An alias statement is used to associate a register/port with a name. Alias statements can be used anywhere in the program. SYNTAX : alias alias_name register_name; alias counter R0;","title":"Alias Statement"},{"location":"support-tools/spl/#breakpoint-statement","text":"The breakpoint statement is used to debug the program. The program when run in the debug mode pauses the execution at this instruction. SYNTAX : breakpoint; This statement translates to BRKP machine instruction .","title":"Breakpoint Statement"},{"location":"support-tools/spl/#assignment-statement","text":"The SPL assignment statement assigns the value of an expression/value stored in a memory address to a register/memory address. = is the assignment operator used in SPL. The operand on the right hand side of the operator is assigned to the left hand side. SYNTAX : Register / Alias / [Address] = Register / Port / Number / String / Expression / [Address]; R2 = P0; [PTBR + 3] = [1024] + 10; R1 = \"hello world\";","title":"Assignment Statement"},{"location":"support-tools/spl/#if-statement","text":"If statement specifies the conditional execution of two branches according to the value of a logical expression. If the expression evaluates to 1, the if branch is executed, otherwise the else branch is executed. The else part is optional. SYNTAX : if (logical expression) then statements; else statements; endif ;","title":"If Statement"},{"location":"support-tools/spl/#while-statement","text":"While statement iteratively executes a set of statements based on a condition. The condition is defined using a logical expression. The statements are iteratively executed as long as the condition is true. SYNTAX : while (logical expression) do statements; endwhile ;","title":"While Statement"},{"location":"support-tools/spl/#break-statement","text":"Break statement when used inside a while loop block, stops the execution of the loop in which it is used and passes the control of execution to the next statement after the loop. This statement cannot be used anywhere else other than while loop. SYNTAX : break;","title":"Break Statement"},{"location":"support-tools/spl/#continue-statement","text":"Continue statement when used inside a while loop block, skips the current iteration of the loop and passes the control to the next iteration after checking the loop condition. SYNTAX : continue;","title":"Continue Statement"},{"location":"support-tools/spl/#ireturn-statement","text":"ireturn statement or the Interrupt Return statement is used to pass control from a kernel mode interrupt service routine to the user mode program which invoked it. SYNTAX : ireturn ; The ireturn is generally used at the end of an interrupt code. This statement translates to IRET machine instruction .","title":"ireturn Statement"},{"location":"support-tools/spl/#readprint-statements","text":"The read and print statements are used as standard input and output statements. The read statement initiates the transfer of a string from the console to the standard input port P0 using the IN machine instruction. The machine proceeds to execute the next instruction without waiting for the completion of the string transfer. Note String read or printed must not exceed 10 characters. The print statement outputs value of a register or an integer/string literal or value of a memory location. SYNTAX : read; print** Register / Number / String / Expression / [Address];","title":"Read/Print Statements"},{"location":"support-tools/spl/#readi-statement","text":"The readi statement reads a value from the standard input device and stores it in a register using the INI machine instruction (which can be used only in debug mode). Note String read must not exceed 10 characters. SYNTAX : readi Register;","title":"Readi Statement"},{"location":"support-tools/spl/#loadstore-statements","text":"Loading and storing between the disk and the memory of the XSM machine can be accomplished using load and store statements in SPL. The machine proceeds to execute the next instruction without waiting for the completion of the block transfer. load statement loads the block specified by block_number from the disk to the the page specified by the page_number in the memory. store statement stores the page specified by page_number in the memory to the the block specified by the block_number in the disk. The page_number and block_number can be specified using arithmetic expressions. SYNTAX : load (page_number, block_number); store (page_number, block_number);","title":"Load/Store Statements"},{"location":"support-tools/spl/#loadi-statement","text":"Loading from the disk to the memory of the XSM machine can also be accomplished using loadi statement in SPL. But here, the machine will continue execution of the next instruction only after the block transfer is completed. loadi statement loads the block specified by block_number from the disk to the the page specified by the page_number in the memory. The page_number and block_number can be specified using arithmetic expressions. SYNTAX : loadi (page\\_number, block\\_number);","title":"Loadi Statement"},{"location":"support-tools/spl/#multipush-statement","text":"Multipush statement is used to push a sequence of registers into the memory locations starting from the address pointed to by SP. The registers are pushed in the order in which they are specified in the statement. SYNTAX : multipush (Register1, Register2, ...);","title":"Multipush Statement"},{"location":"support-tools/spl/#multipop-statement","text":"Multipop statement is used to pop a sequence of registers from the memory locations starting from the address pointed to by SP. The registers are popped in the reverse order in which they are specified in the statement. SYNTAX : multipop (Register1, Register2, ...);","title":"Multipop Statement"},{"location":"support-tools/spl/#backup-statement","text":"The backup statement is used to backup all the machine registers (except SP, IP, exception flag registers and ports) into the memory locations starting from the address pointed to by SP in the order : BP, PTBR, PTLR, R0 - R19. The value of SP gets incremented accordingly. SYNTAX : backup; This statement translates to the BACKUP machine instruction .","title":"Backup Statement"},{"location":"support-tools/spl/#restore-statement","text":"The restore statement is used to restore the backed up machine registers from the memory. The registers are restored from contiguous memory locations starting from the address pointed to by SP in the order : R19-R0, PTLR, PTBR, BP. The value of SP gets decremented accordingly. SYNTAX : restore; This statement translates to the RESTORE machine instruction .","title":"Restore Statement"},{"location":"support-tools/spl/#encrypt-statement","text":"The encrypt statement replaces the value in the register Ri with its encrypted value. SYNTAX : encrypt Ri; This statement translates to the ENCRYPT machine instruction .","title":"Encrypt Statement"},{"location":"support-tools/spl/#goto-statement","text":"The goto statement transfers control to the specified labelled statement. SYNTAX : goto label / INT_n / MOD_n / constants; (See SPL constants ) goto label1; goto INT\\_7; goto MOD\\_2; goto MEMORY\\_MANAGER; Note label should be defined within the module.","title":"Goto Statement"},{"location":"support-tools/spl/#call-statement","text":"The call statement saves procedure linking information on the stack and branches to the procedure specified by the argument. SYNTAX : call label / INT_n / MOD _n / constants;` (See SPL constants ) call swap\\_func; call INT\\_7; call MOD\\_2; call MEMORY\\_MANAGER; Note label should be defined within the module. Call statement translates to the CALL machine instruction .","title":"Call Statement"},{"location":"support-tools/spl/#return-statement","text":"The return statement is used to transfer the control from a subroutine to the calling program in the kernel mode and the return address is popped from the stack. SYNTAX : return; This statement translates to the RET machine instruction .","title":"Return Statement"},{"location":"support-tools/spl/#halt-statement","text":"The halt statement is used to halt the machine. SYNTAX : halt; This statement translates to HALT machine instruction .","title":"Halt Statement"},{"location":"support-tools/spl/#inline-statement","text":"The inline statement is used to give XSM machine instructions directly within an SPL program. SYNTAX : inline \"MACHINE INSTRUCTION\" ; inline \"JMP 11776\";","title":"Inline Statement"},{"location":"support-tools/spl/#functions","text":"SPL does not provide explicit support for functions. However, a label can be defined at the beginning of the code for a function and the code can be invoked using the call instruction using the label. This allows use of functions inside a module. Labels defined in one module will not be visible in other modules. If parameters are to be passed to a function, it has to be explictly passed either using agreed upon registers or using a stack. A function loaded at a particular known location in memory (either specified directly by the memory address or using a pre-defined constant) can be invoked by a call to the corresponding memory address. However, it is recommended to follow the conventions discussed below in inter-module calls. call swap; call MOD\\_4; call 511; /* Transfers control to the first page in memory */","title":"Functions"},{"location":"support-tools/spl/#spl-interrupt-handler-and-module-programming-conventions","text":"Each SPL System Call Handler/Interrupt Handler/Module is designed to occupy a maximum of two pages of continuous memory in the XSM machine. (Sometimes, the generic term \"module\" is abused to indicate all types of routines of the above categories, though we avoid this usage here). They contain protected mode code that carries out certain functions as determined by the OS programmer. The following suggests certain programming conventions which are recommend while designing SPL modules and interrupt handlers. These routines may be entered as a result of: 1. A system call handler is entered upon execution of a software interrupt from an application (user mode) program. 2. A hardware interrupt/exception is executed when the machine raises a corresponding hardware signal/exception while an application was executing. 3. A module may invoked from another module or Interrupt handler. Case a: (Software Interrupts) In this case, the arguments to the module are passed through the application program stack. The return values are also passed through the same stack. The convention is that the application must save the state of its registers before making the call . (For instance, the eXpL compiler will save the caller context in the user stack before invoking a software interrupt). Thus, the interrupt routine need not concern itself about saving the context of the application and can use the registers R0-R15 without saving them. However, the application is not expected to save the SP register before the call, and the module must save it for future return. In this case the kernel module must switch to the kernel stack and not use the application's stack. This is to avoid potential user level \u201chacks\u201d into the interrupt modules through the stack. Case b: (Hardware Interrupts) This case applies to the exception handler, timer interrupt routine, disk interrupt routine and the console interrupt routine. The difference here from Case a) is that the application does not have control over the transfer to the interrupt module, and hence would not have saved its context. Thus, in this case, the module must save the register context of the application in its own stack (or elsewhere in the memory) before using the registers and must restore the context before returning to the application. In this case also the module is expected to allocate its own stack in the memory and not use the application's stack. Case c: (Modules) In this case, since the caller and the callee are both executing in protected mode, the same stack can be used. Here, the recommended parameter passing convention is to use R1, R2... for argument_1, argument_2, argument_3... The return value of the module may be stored in R0. This convention is recommended instead of using the stack for passing arguments for improving efficiency. As in the previous cases, the caller must save the values of the registers in use into the stack before the call. Note The SPL compiler given here uses the constants (given in splconstants.cfg file) MOD_0 to MOD_7 as starting address of eXpOS kernel modules. eXpOS kernel loads these modules into various pre-defined memory pages of the XSM machine on startup. In addition to these, all interrupt service routines can be programmed as SPL modules and loaded to the corresponding interrupt service routine locations in memory.","title":"SPL Interrupt Handler and Module Programming Conventions"},{"location":"support-tools/spl/#spl-specification-for-nexsm","text":"The following additonal instructions are available in SPL when running on the NEXSM machine , which is a two core extension for XSM.","title":"SPL Specification for NEXSM"},{"location":"support-tools/spl/#tsl-expression","text":"The contents of the memory location specified by ADDRESS is returned and the value at ADDRESS is set to 1. SYNTAX : tsl (ADDRESS) Examples: while( tsl(KERN\\_LOCK) == 1 ) do continue; endwhile; This statement translates to a sequence of instructions that uses the TSL machine instruction .","title":"TSL Expression"},{"location":"support-tools/spl/#start-statement","text":"The start instruction when executed from primary core of the NEXSM machine will start the secondary core into parallel execution. SYNTAX : start; This statement translates to the START machine instruction .","title":"START Statement"},{"location":"support-tools/spl/#reset-statement","text":"The reset instruction when executed from primary core of the NEXSM machine will freeze the secondary core. SYNTAX : reset; This statement translates to the RESET machine instruction .","title":"RESET Statement"},{"location":"support-tools/xfs-interface/","text":"XFS Interface (eXperimental File System Interface) is an external interface to access the eXpFS filesystem of the eXpOS \"from the host (UNIX) system\". The filesystem is simulated on a binary file called disk.xfs . The interface can format the disk, dump the disk data structures, load/remove files, list files, transfer data and executable files between eXpFS filesystem and the host (UNIX) file system and copy specified blocks of the XFS disk to a UNIX file. Within your xfs-interface directory, use the following command to run the interface ./xfs-interface Note XFS interface must not be run while the XSM simulator is run concurrently as it might leave the file system in inconsistent state. You can also run a single command in the xfs-interface by ./xfs-interface < command > The various commands available in XFS Interface are discussed below. Help \u00b6 Syntax : help Semantics : It displays the general syntax and function of all the commands. Disk Formatting \u00b6 Syntax : fdisk Semantics : It is used to create the disk (\u201ddisk.xfs\u201d) or to format the disk if already created. On a newly created/formatted disk default entries for the Disk Free List , Inode Table , Root File and User Table are initialized according to the XFS implementation for the XSM machine. These include entries for the root file in the Inode table, entry for the root file itself in the root file, entry for the special users \"root\" and \"system\" in the user table etc. Loading Files \u00b6 The command load is used to load files from the UNIX filesystem to the XFS disk. The type of the file that is loaded is specified by the first argument. The second argument <pathname> is the path to the UNIX file which is to be loaded to the filesystem. The command checks the size of the executable/data file , allocates the required number of blocks for the file, updates the disk free list and creates the corresponding inode table and root file entries for the file. xfs-interface recognizes the disk blocks designated for the timer, console and disk interrupt handlers, the exception handler, idle process, the shell code, OS modules and the OS startup code by the eXpOS implementation on the XSM machine and loads these modules to the appropriate places. The various load commands are listed below : Syntax : load --exec <pathname> Semantics : Loads an executable file to XFS disk after allocating sufficient disk blocks and creating inode table and root file entries. Syntax : load --data <pathname> Semantics : Loads a data file to XFS disk after allocating sufficient disk blocks and creating inode table and root file entries. Syntax : load --init <pathname> Semantics : Loads INIT/Login code to the recognised XFS disk blocks . Note Login code will be the INIT code in Multi User mode implementation of eXpOS. Syntax : load --os <pathname> Semantics : Loads OS startup code to the recognised XFS disk blocks . Syntax : load --idle <pathname> Semantics : Loads Idle code to the recognised XFS disk blocks . Syntax : load --shell <pathname> Semantics : Loads Shell code to the recognised XFS disk blocks . Syntax : load --library <pathname> Semantics : Loads Library to the recognised XFS disk blocks . Syntax : load --int=timer <pathname> Semantics : Loads Timer Interrupt routine to the recognised XFS disk blocks . Syntax : load --int=disk <pathname> Semantics : Loads Disk Interrupt routine to the recognised XFS disk blocks . Syntax : load --int=console <pathname> Semantics : Loads Console Interrupt routine to the recognised XFS disk blocks . Syntax : load --int=[4-18] <pathname> Semantics : Loads the specified Interrupt routine to the recognised XFS disk blocks . Syntax : load --exhandler <pathname> Semantics : Loads exception handler routine to the recognised XFS disk blocks . Syntax : load --module [0-7] <pathname> Semantics : Loads a module to the the recognised XFS disk blocks . Exporting Files \u00b6 The command export is used to export data files from the XFS disk to the UNIX filesystem. The argument <xfs_filename> specifies the file which is to be exported and the argument <pathname> specifies the UNIX file to which it is to be exported. The command searches the inode table entries for the data file and copies all the blocks corresponding to the file to the UNIX file specified. Note that if the argument is not given the file will be stored at $HOME/myexpos/xfs-interface/ and named as <xfs_filename> . Syntax : export <xfs_filename> <pathname> Semantics : Exports a data file from XFS disk to UNIX file system. Removing Files \u00b6 The command rm is used to remove files from the XFS disk. The argument <xfs_filename> specifies the file which is to be removed. The command searches the inode table entries for the file (executable/data file) and clears the blocks corresponding to the file, updates the disk free list and removes root file and inode table entries. Only data and executable files can be removed. Syntax : rm <xfs_filename> Semantics : Removes an executable/data file from XFS disk. Listing Files \u00b6 Syntax : ls Semantics : It lists all the files which are loaded into the filesystem. The size of the file is also displayed in number of words. This is done by traversing through the inode table entries. Display Disk Free List \u00b6 Syntax : df Semantics : It displays the Disk Free List . It also displays the total number of blocks and the number of free blocks. Display File Contents \u00b6 Syntax : cat <xfs_filename> Semantics : It displays the contents of a file in the filesystem. The inode table entries are searched to get the blocks corresponding to the file and then the blocks are displayed. Copying Disk Blocks to a UNIX File \u00b6 Syntax : copy <start_block> <end_block> <unix_filename> Semantics : It copies the contents of specified block(s) in the filesystem to an external UNIX file and the file will be stored at $HOME/myexpos/xfs-interface/ directory. The arguments <start_block> and <end_block> denotes the range of blocks to be copied (including both). <unix_filename> specifies the destination UNIX file to which the contents are copied. Dumping Disk Data Structures to a UNIX File \u00b6 The command dump is used to dump/export the disk data structures (inode table and root file) to the predefined UNIX files as follows. The files are dumped to $HOME/myexpos/xfs-interface/ directory. Syntax : dump --inodeusertable Semantics : It copies the contents of inode table and user table to an external UNIX file named inodeusertable.txt. Syntax : dump --rootfile Semantics : It copies the contents of root file to an external UNIX file named rootfile.txt. Batch Mode Execution of Instructions \u00b6 Syntax : run <pathname> Semantics : It executes the set of xfs-interface commands specified in the <pathname> , sequentially. Note that, the set of commands in the file should be separated by a new line. For example, a batch file that loads timer, disk and console interrupt handlers might appear appear as below: load --int=timer $HOME/myexpos/spl/spl_programs/timer.xsm load --int=disk $HOME/myexpos/spl/spl_programs/disk.xsm load --int=console $HOME/myexpos/spl/spl_programs/console.xsm Exit Interface \u00b6 Syntax : exit Semantics : It quits the interface. XFS-Interface Instructions for NEXSM \u00b6 The following are the modifications to the XFS-interface for NEXSM: Syntax : load --os=primary <pathname> Semantics : Loads OS startup code for the primary core to the recognised XFS disk blocks . Syntax : load --os=secondary <pathname> Semantics : Loads OS startup code for the secondary core to the recognised XFS disk blocks . Syntax : load --int=\\[4-19\\] <pathname> Semantics : Loads the specified Interrupt routine to the recognised XFS disk blocks . Syntax : load --module \\[0-11\\] <pathname> Semantics : Loads the specified Module to the recognised XFS disk blocks .","title":"XFS Interface"},{"location":"support-tools/xfs-interface/#help","text":"Syntax : help Semantics : It displays the general syntax and function of all the commands.","title":"Help"},{"location":"support-tools/xfs-interface/#disk-formatting","text":"Syntax : fdisk Semantics : It is used to create the disk (\u201ddisk.xfs\u201d) or to format the disk if already created. On a newly created/formatted disk default entries for the Disk Free List , Inode Table , Root File and User Table are initialized according to the XFS implementation for the XSM machine. These include entries for the root file in the Inode table, entry for the root file itself in the root file, entry for the special users \"root\" and \"system\" in the user table etc.","title":"Disk Formatting"},{"location":"support-tools/xfs-interface/#loading-files","text":"The command load is used to load files from the UNIX filesystem to the XFS disk. The type of the file that is loaded is specified by the first argument. The second argument <pathname> is the path to the UNIX file which is to be loaded to the filesystem. The command checks the size of the executable/data file , allocates the required number of blocks for the file, updates the disk free list and creates the corresponding inode table and root file entries for the file. xfs-interface recognizes the disk blocks designated for the timer, console and disk interrupt handlers, the exception handler, idle process, the shell code, OS modules and the OS startup code by the eXpOS implementation on the XSM machine and loads these modules to the appropriate places. The various load commands are listed below : Syntax : load --exec <pathname> Semantics : Loads an executable file to XFS disk after allocating sufficient disk blocks and creating inode table and root file entries. Syntax : load --data <pathname> Semantics : Loads a data file to XFS disk after allocating sufficient disk blocks and creating inode table and root file entries. Syntax : load --init <pathname> Semantics : Loads INIT/Login code to the recognised XFS disk blocks . Note Login code will be the INIT code in Multi User mode implementation of eXpOS. Syntax : load --os <pathname> Semantics : Loads OS startup code to the recognised XFS disk blocks . Syntax : load --idle <pathname> Semantics : Loads Idle code to the recognised XFS disk blocks . Syntax : load --shell <pathname> Semantics : Loads Shell code to the recognised XFS disk blocks . Syntax : load --library <pathname> Semantics : Loads Library to the recognised XFS disk blocks . Syntax : load --int=timer <pathname> Semantics : Loads Timer Interrupt routine to the recognised XFS disk blocks . Syntax : load --int=disk <pathname> Semantics : Loads Disk Interrupt routine to the recognised XFS disk blocks . Syntax : load --int=console <pathname> Semantics : Loads Console Interrupt routine to the recognised XFS disk blocks . Syntax : load --int=[4-18] <pathname> Semantics : Loads the specified Interrupt routine to the recognised XFS disk blocks . Syntax : load --exhandler <pathname> Semantics : Loads exception handler routine to the recognised XFS disk blocks . Syntax : load --module [0-7] <pathname> Semantics : Loads a module to the the recognised XFS disk blocks .","title":"Loading Files"},{"location":"support-tools/xfs-interface/#exporting-files","text":"The command export is used to export data files from the XFS disk to the UNIX filesystem. The argument <xfs_filename> specifies the file which is to be exported and the argument <pathname> specifies the UNIX file to which it is to be exported. The command searches the inode table entries for the data file and copies all the blocks corresponding to the file to the UNIX file specified. Note that if the argument is not given the file will be stored at $HOME/myexpos/xfs-interface/ and named as <xfs_filename> . Syntax : export <xfs_filename> <pathname> Semantics : Exports a data file from XFS disk to UNIX file system.","title":"Exporting Files"},{"location":"support-tools/xfs-interface/#removing-files","text":"The command rm is used to remove files from the XFS disk. The argument <xfs_filename> specifies the file which is to be removed. The command searches the inode table entries for the file (executable/data file) and clears the blocks corresponding to the file, updates the disk free list and removes root file and inode table entries. Only data and executable files can be removed. Syntax : rm <xfs_filename> Semantics : Removes an executable/data file from XFS disk.","title":"Removing Files"},{"location":"support-tools/xfs-interface/#listing-files","text":"Syntax : ls Semantics : It lists all the files which are loaded into the filesystem. The size of the file is also displayed in number of words. This is done by traversing through the inode table entries.","title":"Listing Files"},{"location":"support-tools/xfs-interface/#display-disk-free-list","text":"Syntax : df Semantics : It displays the Disk Free List . It also displays the total number of blocks and the number of free blocks.","title":"Display Disk Free List"},{"location":"support-tools/xfs-interface/#display-file-contents","text":"Syntax : cat <xfs_filename> Semantics : It displays the contents of a file in the filesystem. The inode table entries are searched to get the blocks corresponding to the file and then the blocks are displayed.","title":"Display File Contents"},{"location":"support-tools/xfs-interface/#copying-disk-blocks-to-a-unix-file","text":"Syntax : copy <start_block> <end_block> <unix_filename> Semantics : It copies the contents of specified block(s) in the filesystem to an external UNIX file and the file will be stored at $HOME/myexpos/xfs-interface/ directory. The arguments <start_block> and <end_block> denotes the range of blocks to be copied (including both). <unix_filename> specifies the destination UNIX file to which the contents are copied.","title":"Copying Disk Blocks to a UNIX File"},{"location":"support-tools/xfs-interface/#dumping-disk-data-structures-to-a-unix-file","text":"The command dump is used to dump/export the disk data structures (inode table and root file) to the predefined UNIX files as follows. The files are dumped to $HOME/myexpos/xfs-interface/ directory. Syntax : dump --inodeusertable Semantics : It copies the contents of inode table and user table to an external UNIX file named inodeusertable.txt. Syntax : dump --rootfile Semantics : It copies the contents of root file to an external UNIX file named rootfile.txt.","title":"Dumping Disk Data Structures to a UNIX File"},{"location":"support-tools/xfs-interface/#batch-mode-execution-of-instructions","text":"Syntax : run <pathname> Semantics : It executes the set of xfs-interface commands specified in the <pathname> , sequentially. Note that, the set of commands in the file should be separated by a new line. For example, a batch file that loads timer, disk and console interrupt handlers might appear appear as below: load --int=timer $HOME/myexpos/spl/spl_programs/timer.xsm load --int=disk $HOME/myexpos/spl/spl_programs/disk.xsm load --int=console $HOME/myexpos/spl/spl_programs/console.xsm","title":"Batch Mode Execution of Instructions"},{"location":"support-tools/xfs-interface/#exit-interface","text":"Syntax : exit Semantics : It quits the interface.","title":"Exit Interface"},{"location":"support-tools/xfs-interface/#xfs-interface-instructions-for-nexsm","text":"The following are the modifications to the XFS-interface for NEXSM: Syntax : load --os=primary <pathname> Semantics : Loads OS startup code for the primary core to the recognised XFS disk blocks . Syntax : load --os=secondary <pathname> Semantics : Loads OS startup code for the secondary core to the recognised XFS disk blocks . Syntax : load --int=\\[4-19\\] <pathname> Semantics : Loads the specified Interrupt routine to the recognised XFS disk blocks . Syntax : load --module \\[0-11\\] <pathname> Semantics : Loads the specified Module to the recognised XFS disk blocks .","title":"XFS-Interface Instructions for NEXSM"},{"location":"support-tools/xsm-simulator/","text":"Introduction \u00b6 The XSM (eXperimental String Machine) Simulator is used to simulate the XSM hardware. Within your XSM directory, use the following command to run the simulator ./xsm [--timer #1] [--disk #2] [--console #3] [--debug] Syntax : --timer value Semantics : This flag sets the number of user mode instructions after which timer interrupt is triggered to the value specified. --timer 0 disables the timer. The range of value is from 0 to 1024. Default Value : 20 Syntax : --disk value Semantics : This flag sets the number of user mode instructions after which the disk interrupt is triggered to the value specified. The range of value is from 20 to 1024. Note that count begins only after a LOAD or STORE machine instruction gets executed. Default Value : 20 Syntax : --console value Semantics : This flag sets the number of user mode instructions after which console interrupt is triggered to the value specified. The range of value is from 20 to 1024. Note that count begins only after a IN machine instruction gets executed. Default Value : 20 Syntax : --debug Semantics : This flag sets the machine into DEBUG mode when it encounters a BRKP machine instruction. Any BRKP instruction in the program will be ignored by the machine if this flag is not set. Further details are given in the section below. The machine instruction INI gets enabled only in DEBUG mode. Debugging \u00b6 The --debug flag is used to debug the running machine. When this flag is set and the machine encounters a breakpoint instruction, the machine enters the DEBUG mode. In this mode a prompt is displayed which allows the user to enter commands to inspect the state of the machine. The commands in DEBUG mode are : Syntax : step / s Semantics : The execution proceeds by a single step. Syntax : step <N> / s <N> Semantics : The execution proceeds by N number of steps. Syntax : continue / c Semantics : The execution proceeds till the next breakpoint (BRKP) instruction. Syntax : continue <N> / c <N> Semantics : The execution proceeds till the next N'th occurance of the breakpoint (BRKP) instruction. Syntax : reg / r Semantics : Displays the contents of all the machine registers namely IP, SP, BP, PTBR, PTLR, EIP, EC, EPN, EMA, R0-R19 in that order. Syntax : reg <register_name> / r <register_name> Semantics : Displays the contents of the specified register. Sample usage: r R5, reg PTLR Syntax : mem <page_num> / m <page_num> Semantics : Writes the contents of the memory page <page_num> to the file \"mem\" in the XSM folder. Sample usage: mem 5, m 20 Syntax : mem <page_num_1> <page_num_2> / m <page_num_1> <page_num_2> Semantics : Writes the contents of the memory from pages <page_num_1> to <page_num_2> to the file \"mem\" in XSM folder. Sample usage: mem 5 8, m 0 10 Syntax : pcb / p Semantics : Displays the Process Table entry of the current process. Syntax : pcb <pid> / p <pid> Semantics : Displays the Process Table entry of the process with the given <pid> . Syntax : pagetable / pt Semantics : Displays the Page Table at the location pointed by PTBR (Page Table Base Register). Syntax : pagetable <pid> / pt <pid> Semantics : Displays the <pid>th Page Table. Syntax : diskmaptable / dmt Semantics : Displays the Disk Map Table of the current process. Syntax : diskmaptable <pid> / dmt <pid> Semantics : Displays the Disk Map Table of the process with the given <pid> . Syntax : resourcetable / rt Semantics : Displays the Per-process Resource Table of the current process. Syntax : resourcetable <pid> / rt <pid> Semantics : Displays the Per-process Resource Table of the process with the given <pid> . Syntax : filetable / ft Semantics : Displays the Open File Table. Syntax : semtable / st Semantics : Displays the Semaphore Table. Syntax : memfreelist / mf Semantics : Displays the Memory Free List. Syntax : filestatus / fst Semantics : Displays the File Status Table. Syntax : diskstatus / dst Semantics : Displays the Disk Status Table. Syntax : systemstatus / sst Semantics : Displays the System Status Table. Syntax : terminalstatus / tst Semantics : Displays the Terminal Status Table. Syntax : buffertable / bt Semantics : Displays the Buffer Table. Syntax : inodetable / it Semantics : Displays the memory copy of the Inode Table. Syntax : usertable / ut Semantics : Displays the memory copy of the User Table. Syntax : diskfreelist / df Semantics : Displays the memory copy of the Disk Free List. Syntax : rootfile / rf Semantics : Displays the memory copy of the Root File. Syntax : location <address> / l <address> Semantics : Displays the content at memory address after address translation. Syntax : val <address> / v <address> Semantics : Displays the content at memory address without address translation. Syntax : watch <physical_address> / w <physical_address> Semantics : Sets a watch point to this address. Watch point is used to track changes of a particular memory location. Whenever a word which is watched is altered, program execution is stopped and the debug interface is invoked. Atmost 16 watch points can be set. Syntax : watchclear / wc Semantics : Clears all the watch points. Syntax : list / ls Semantics : List 10 instructions before and after the current instruction . Syntax : page <address> / pg <address> Semantics : Displays the Page Number and Offset for the given <address> . Syntax : exit / e Semantics : Exits the debug prompt and halts the machine. Syntax : help / h Semantics : Displays commands in brief. Syntax : accesslocktable / alt Semantics : Displays the Access Lock Table. (Only available on NEXSM simulator used in Stage 28 of Roadmap ) Note Simply pressing the Return key at the debug prompt will re-execute the previous command.","title":"XSM Simulator"},{"location":"support-tools/xsm-simulator/#introduction","text":"The XSM (eXperimental String Machine) Simulator is used to simulate the XSM hardware. Within your XSM directory, use the following command to run the simulator ./xsm [--timer #1] [--disk #2] [--console #3] [--debug] Syntax : --timer value Semantics : This flag sets the number of user mode instructions after which timer interrupt is triggered to the value specified. --timer 0 disables the timer. The range of value is from 0 to 1024. Default Value : 20 Syntax : --disk value Semantics : This flag sets the number of user mode instructions after which the disk interrupt is triggered to the value specified. The range of value is from 20 to 1024. Note that count begins only after a LOAD or STORE machine instruction gets executed. Default Value : 20 Syntax : --console value Semantics : This flag sets the number of user mode instructions after which console interrupt is triggered to the value specified. The range of value is from 20 to 1024. Note that count begins only after a IN machine instruction gets executed. Default Value : 20 Syntax : --debug Semantics : This flag sets the machine into DEBUG mode when it encounters a BRKP machine instruction. Any BRKP instruction in the program will be ignored by the machine if this flag is not set. Further details are given in the section below. The machine instruction INI gets enabled only in DEBUG mode.","title":"Introduction"},{"location":"support-tools/xsm-simulator/#debugging","text":"The --debug flag is used to debug the running machine. When this flag is set and the machine encounters a breakpoint instruction, the machine enters the DEBUG mode. In this mode a prompt is displayed which allows the user to enter commands to inspect the state of the machine. The commands in DEBUG mode are : Syntax : step / s Semantics : The execution proceeds by a single step. Syntax : step <N> / s <N> Semantics : The execution proceeds by N number of steps. Syntax : continue / c Semantics : The execution proceeds till the next breakpoint (BRKP) instruction. Syntax : continue <N> / c <N> Semantics : The execution proceeds till the next N'th occurance of the breakpoint (BRKP) instruction. Syntax : reg / r Semantics : Displays the contents of all the machine registers namely IP, SP, BP, PTBR, PTLR, EIP, EC, EPN, EMA, R0-R19 in that order. Syntax : reg <register_name> / r <register_name> Semantics : Displays the contents of the specified register. Sample usage: r R5, reg PTLR Syntax : mem <page_num> / m <page_num> Semantics : Writes the contents of the memory page <page_num> to the file \"mem\" in the XSM folder. Sample usage: mem 5, m 20 Syntax : mem <page_num_1> <page_num_2> / m <page_num_1> <page_num_2> Semantics : Writes the contents of the memory from pages <page_num_1> to <page_num_2> to the file \"mem\" in XSM folder. Sample usage: mem 5 8, m 0 10 Syntax : pcb / p Semantics : Displays the Process Table entry of the current process. Syntax : pcb <pid> / p <pid> Semantics : Displays the Process Table entry of the process with the given <pid> . Syntax : pagetable / pt Semantics : Displays the Page Table at the location pointed by PTBR (Page Table Base Register). Syntax : pagetable <pid> / pt <pid> Semantics : Displays the <pid>th Page Table. Syntax : diskmaptable / dmt Semantics : Displays the Disk Map Table of the current process. Syntax : diskmaptable <pid> / dmt <pid> Semantics : Displays the Disk Map Table of the process with the given <pid> . Syntax : resourcetable / rt Semantics : Displays the Per-process Resource Table of the current process. Syntax : resourcetable <pid> / rt <pid> Semantics : Displays the Per-process Resource Table of the process with the given <pid> . Syntax : filetable / ft Semantics : Displays the Open File Table. Syntax : semtable / st Semantics : Displays the Semaphore Table. Syntax : memfreelist / mf Semantics : Displays the Memory Free List. Syntax : filestatus / fst Semantics : Displays the File Status Table. Syntax : diskstatus / dst Semantics : Displays the Disk Status Table. Syntax : systemstatus / sst Semantics : Displays the System Status Table. Syntax : terminalstatus / tst Semantics : Displays the Terminal Status Table. Syntax : buffertable / bt Semantics : Displays the Buffer Table. Syntax : inodetable / it Semantics : Displays the memory copy of the Inode Table. Syntax : usertable / ut Semantics : Displays the memory copy of the User Table. Syntax : diskfreelist / df Semantics : Displays the memory copy of the Disk Free List. Syntax : rootfile / rf Semantics : Displays the memory copy of the Root File. Syntax : location <address> / l <address> Semantics : Displays the content at memory address after address translation. Syntax : val <address> / v <address> Semantics : Displays the content at memory address without address translation. Syntax : watch <physical_address> / w <physical_address> Semantics : Sets a watch point to this address. Watch point is used to track changes of a particular memory location. Whenever a word which is watched is altered, program execution is stopped and the debug interface is invoked. Atmost 16 watch points can be set. Syntax : watchclear / wc Semantics : Clears all the watch points. Syntax : list / ls Semantics : List 10 instructions before and after the current instruction . Syntax : page <address> / pg <address> Semantics : Displays the Page Number and Offset for the given <address> . Syntax : exit / e Semantics : Exits the debug prompt and halts the machine. Syntax : help / h Semantics : Displays commands in brief. Syntax : accesslocktable / alt Semantics : Displays the Access Lock Table. (Only available on NEXSM simulator used in Stage 28 of Roadmap ) Note Simply pressing the Return key at the debug prompt will re-execute the previous command.","title":"Debugging"},{"location":"test-programs/","text":"Test Program 1 (Shell version-II without multiuser) \u00b6 Input Executable file name/string \"Shutdown\" Output Executes given xsm program/halt system if input is \"Shutdown\" Description : shell version II without the multiuser The code for the test program can be found here Test Program 2 \u00b6 Input An integer N and N integers. Output N integers entered in the input. Description : The program given below implements a linked list for integers. The program reads an integer N from the console. It then creates a linked list and inserts N integers entered from console into the linked list in the same order. The program traverses the linked list and prints data to the console. The code for the test program can be found here Test Program 3 \u00b6 Input - Output Integers 1 to 100, not necessarily in the order. Description : The program creates a linked list with numbers 1 to 100 in them. The program invokes fork to create a child process. The parent and the child process reads from the shared linked list with different pointers and prints the data read to the console. Parent process prints the even numbers 2, 4, 6, 8.. and child process prints 1, 3, 5 .. The code for the test program can be found here Test Program 4 (Reader-Writer Program) \u00b6 Input - Output Integers from 1 to 100, but not necessarily in sequential order. Description : The reader-writer program provides below has two writers and one reader. The parent process will create two child processes by invoking fork . The parent and two child processes share a buffer of one word. At a time only one process can read/write to this buffer. To acheive this, these three processes use a shared semaphore. A writer process can write to the buffer if it is empty and the reader process can only read from the buffer if it is full. Before the word in the buffer is overwritten the reader process must read it and print the word to the console. The parent process is the reader process and its two children are writers. One child process writes even numbers from 1 to 100 and other one writes odd numbers from 1 to 100 to the buffer. The parent process reads the numbers and prints them on to the console. The code for the test program can be found here Test Program 5 \u00b6 Input Name of a data file (String) Output Content of the given file Description : The program takes names of data files as input and opens the file first. It then forks to create a child process. The content of the file with shared open instance (shared LSEEK) will be printed to the terminal concurrently by parent and child. To synchronize the use open instance between parent and child a semaphore is used. The code for the test program can be found here Test Program 6 \u00b6 Input A file name (String) and permission (Integer) Output Integers from 1 to 100, but not necessarily in sequential order. Description : The program takes a file name and permission as input and creates a new file with given inputs. It then forks to create two child processes. Similar to Reader-Writer program seen before, the two child processes act as writers and parent as reader. A file open instances is shared between two writers and there is separate open instance of the same file for reader. Two writers will write numbers from 1 to 100 to file - one writer will write even numbers other will write odd numbers and reader will read from the file and print to the console concurrently. To synchronize the use of the shared open instance between two writers a semaphore is used. The code for the test program can be found here Test Program 7 (Extended Shell) \u00b6 Input Built in shell command/ Name of XSM executable file (String) Output Ouput of corresponding to shell command or executable file. Description : Shell program given below reads command from console. If the command is halt, then program will invoke Shutdown system call. If the command is built in shell command, then shell will read suitable number of arguments from the console and corresponding system call is invoked from shell itself. If the command is an executable file, shell will fork and exec with the given executable file. Note that the shell program should fit in 2 blocks/pages provided in disk/memory organization . The program given below is optimized to fits in 2 blocks/pages. In order to optimize the code, the program violates some of the type checkings. Even with type checking errors, the program will still compile and execute correctly. Also some system calls are invoked with arguments, even though the system call does not need any arguments. This will not cause any problem as these arguments will simply be ignored in the corresponding system call. The code for the test program can be found here Test Program 8 \u00b6 Input Delay Parameter Output 8 integers - PID*100 to PID*100+7. Description : The program given in above link will first read a delay parameter and then, call the Fork system call and create 12 processes. Each process prints numbers from PID*100 to PID*100 + 7. After printing each number, a delay function is called with the the delay parameter provided. The code for the test program can be found here Test Program 9 \u00b6 Input - Output Out of 12 processes created, if N processes complete execution, then N data files each containing 100 consecutive integers (PID-3)*100+1 to (PID-3)*100+100 are created. Description : The program will create a file with name \"num.dat\" with open permission. Integers 1 to 1200 are written to this file and file is closed. The program will then invoke Fork system call four times, back to back to create 12 processes and Exec system call is invoked with file \"pgm1.xsm\". The program for \"pgm1.xsm\" is provided here . The code for the test program can be found here Test Program 10 \u00b6 Input - Output (For each 12 proceesses) A file will be created containing 100 consecutive numbers (PID-3)*100+1 to (PID-3)*100+100 Description : This program can not be run individualy. The test program 9 will invoke Exec with below given program with name \"pgm1.xsm\". Make sure to compile and save this program as \"pgm1.xsm\". Below given program will create a new file according to the PID of the process and read 100 numbers from file \"num.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 consecutive numbers (PID-3)*100+1 to PID-3)*100+100. The code for the test program can be found here Test Program 11 \u00b6 Input - Output Out of 12 processes created, if N processes complete execution, then N data files each containing 100 consecutive integers from X*1000+1 to X*1000+100 (where X \u2208 {3,4..14}) are created. Description : The program will create a file with name \"numbers.dat\" with open permission and open the file. The program also invokes Semget to acquire a shared semaphore. The program will then invoke Fork system call four times, back to back to create 12 processes. The 12 processes now share a file open instance and a semaphore. Each process will write 100 numbers consecutatively (PID*1000+1 to PID*1000+100) to the file \"numbers.dat\". Exec system call is invoked with file \"pgm2.xsm\". The program for \"pgm2.xsm\" is provided here . The code for the test program can be found here Test Program 12 \u00b6 Input - Output (For each 12 proceesses) A file will be created containing 100 consecutive numbers from data file \"numbers.dat\". Description : This program can not be run individualy. Test program 11 will invoke Exec with below given program with name \"pgm2.xsm\". Make sure to compile and save this program as \"pgm2.xsm\". Below given program will create a new file according to the PID of the process and read 100 numbers from file \"numbers.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 numbers each X*1000 -X*1000+99, where X=[3,4..14]. The numbers written by a process in the newly created file need not be the same numbers the process has written in \"numbers.dat\" file. The code for the test program can be found here Test Program 13 \u00b6 Input - Output (For each 8 processes with PID = 2 to 9) Return values from Fork system call and integers from PID*100 to PID*100+9. Description : This program calls fork 3 times creating 8 child processes. Each process prints the value returned from the last Fork system call and Exec system call is invoked with file \"child.xsm\". The \"child.xsm\" program stores numbers from PID*100 to PID*100+9 onto a linked list and prints them to the console. The code for the parent.expl can be found here and the code for the child.expl can be found here Test Program 14 (Merge Sort) \u00b6 Input - Output Print numbers from 1 to 64 in ascending order. Description : These two ExpL programs perform merge sort in two different ways. The first one is done in a sequential manner and the second one, in a concurrent approach. Values from 1 to 64 are stored in decreasing order in a linked list and are sorted using a recursive merge sort function. In the concurrent approach, the process is forked and the merge sort function is called recursively for the two sub-lists from the two child processes. The code for the Sequential approach can be found here and the code for the Concurrent approach can be found here Test Program 15 (Merge Files) \u00b6 Input - Output Creates a file merge.dat with numbers from 1 to 2048. Description : The ExpL program first creates 4 files with values from s to 4*c+s, where s=[1..and c=[0..511]. The program then, merges the 4 files taking 2 at a time, and finally, creates a merge.dat file containing numbers from 1 to 2048. The code for the test program can be found here Test Program 16 (Merge Sort with Files) \u00b6 Input - Output Creates a file merge.dat with numbers from 1 to 512 and also prints them. Description : The first ExpL program, merge.expl , first stores numbers from 1 to 512 in a random order into a file merge.dat . It then forks and executes m_store.expl which creates 8 files temp{i}.dat , where i=1..8 and stores 64 numbers each from merge.expl . Then, all the temporary files are sorted by executing m_sort.expl . Next, the first ExpL program forks and executes m_merge.expl which merges all the temporary files back into merge.dat and finally, prints the contents from 1 to 512 in ascending order. The test programs are merge.expl , m_store.expl , m_sort.expl and m_merge.expl","title":"Test Programs"},{"location":"test-programs/#test-program-1-shell-version-ii-without-multiuser","text":"Input Executable file name/string \"Shutdown\" Output Executes given xsm program/halt system if input is \"Shutdown\" Description : shell version II without the multiuser The code for the test program can be found here","title":"Test Program 1 (Shell version-II without multiuser)"},{"location":"test-programs/#test-program-2","text":"Input An integer N and N integers. Output N integers entered in the input. Description : The program given below implements a linked list for integers. The program reads an integer N from the console. It then creates a linked list and inserts N integers entered from console into the linked list in the same order. The program traverses the linked list and prints data to the console. The code for the test program can be found here","title":"Test Program 2"},{"location":"test-programs/#test-program-3","text":"Input - Output Integers 1 to 100, not necessarily in the order. Description : The program creates a linked list with numbers 1 to 100 in them. The program invokes fork to create a child process. The parent and the child process reads from the shared linked list with different pointers and prints the data read to the console. Parent process prints the even numbers 2, 4, 6, 8.. and child process prints 1, 3, 5 .. The code for the test program can be found here","title":"Test Program 3"},{"location":"test-programs/#test-program-4-reader-writer-program","text":"Input - Output Integers from 1 to 100, but not necessarily in sequential order. Description : The reader-writer program provides below has two writers and one reader. The parent process will create two child processes by invoking fork . The parent and two child processes share a buffer of one word. At a time only one process can read/write to this buffer. To acheive this, these three processes use a shared semaphore. A writer process can write to the buffer if it is empty and the reader process can only read from the buffer if it is full. Before the word in the buffer is overwritten the reader process must read it and print the word to the console. The parent process is the reader process and its two children are writers. One child process writes even numbers from 1 to 100 and other one writes odd numbers from 1 to 100 to the buffer. The parent process reads the numbers and prints them on to the console. The code for the test program can be found here","title":"Test Program 4 (Reader-Writer Program)"},{"location":"test-programs/#test-program-5","text":"Input Name of a data file (String) Output Content of the given file Description : The program takes names of data files as input and opens the file first. It then forks to create a child process. The content of the file with shared open instance (shared LSEEK) will be printed to the terminal concurrently by parent and child. To synchronize the use open instance between parent and child a semaphore is used. The code for the test program can be found here","title":"Test Program 5"},{"location":"test-programs/#test-program-6","text":"Input A file name (String) and permission (Integer) Output Integers from 1 to 100, but not necessarily in sequential order. Description : The program takes a file name and permission as input and creates a new file with given inputs. It then forks to create two child processes. Similar to Reader-Writer program seen before, the two child processes act as writers and parent as reader. A file open instances is shared between two writers and there is separate open instance of the same file for reader. Two writers will write numbers from 1 to 100 to file - one writer will write even numbers other will write odd numbers and reader will read from the file and print to the console concurrently. To synchronize the use of the shared open instance between two writers a semaphore is used. The code for the test program can be found here","title":"Test Program 6"},{"location":"test-programs/#test-program-7-extended-shell","text":"Input Built in shell command/ Name of XSM executable file (String) Output Ouput of corresponding to shell command or executable file. Description : Shell program given below reads command from console. If the command is halt, then program will invoke Shutdown system call. If the command is built in shell command, then shell will read suitable number of arguments from the console and corresponding system call is invoked from shell itself. If the command is an executable file, shell will fork and exec with the given executable file. Note that the shell program should fit in 2 blocks/pages provided in disk/memory organization . The program given below is optimized to fits in 2 blocks/pages. In order to optimize the code, the program violates some of the type checkings. Even with type checking errors, the program will still compile and execute correctly. Also some system calls are invoked with arguments, even though the system call does not need any arguments. This will not cause any problem as these arguments will simply be ignored in the corresponding system call. The code for the test program can be found here","title":"Test Program 7 (Extended Shell)"},{"location":"test-programs/#test-program-8","text":"Input Delay Parameter Output 8 integers - PID*100 to PID*100+7. Description : The program given in above link will first read a delay parameter and then, call the Fork system call and create 12 processes. Each process prints numbers from PID*100 to PID*100 + 7. After printing each number, a delay function is called with the the delay parameter provided. The code for the test program can be found here","title":"Test Program 8"},{"location":"test-programs/#test-program-9","text":"Input - Output Out of 12 processes created, if N processes complete execution, then N data files each containing 100 consecutive integers (PID-3)*100+1 to (PID-3)*100+100 are created. Description : The program will create a file with name \"num.dat\" with open permission. Integers 1 to 1200 are written to this file and file is closed. The program will then invoke Fork system call four times, back to back to create 12 processes and Exec system call is invoked with file \"pgm1.xsm\". The program for \"pgm1.xsm\" is provided here . The code for the test program can be found here","title":"Test Program 9"},{"location":"test-programs/#test-program-10","text":"Input - Output (For each 12 proceesses) A file will be created containing 100 consecutive numbers (PID-3)*100+1 to (PID-3)*100+100 Description : This program can not be run individualy. The test program 9 will invoke Exec with below given program with name \"pgm1.xsm\". Make sure to compile and save this program as \"pgm1.xsm\". Below given program will create a new file according to the PID of the process and read 100 numbers from file \"num.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 consecutive numbers (PID-3)*100+1 to PID-3)*100+100. The code for the test program can be found here","title":"Test Program 10"},{"location":"test-programs/#test-program-11","text":"Input - Output Out of 12 processes created, if N processes complete execution, then N data files each containing 100 consecutive integers from X*1000+1 to X*1000+100 (where X \u2208 {3,4..14}) are created. Description : The program will create a file with name \"numbers.dat\" with open permission and open the file. The program also invokes Semget to acquire a shared semaphore. The program will then invoke Fork system call four times, back to back to create 12 processes. The 12 processes now share a file open instance and a semaphore. Each process will write 100 numbers consecutatively (PID*1000+1 to PID*1000+100) to the file \"numbers.dat\". Exec system call is invoked with file \"pgm2.xsm\". The program for \"pgm2.xsm\" is provided here . The code for the test program can be found here","title":"Test Program 11"},{"location":"test-programs/#test-program-12","text":"Input - Output (For each 12 proceesses) A file will be created containing 100 consecutive numbers from data file \"numbers.dat\". Description : This program can not be run individualy. Test program 11 will invoke Exec with below given program with name \"pgm2.xsm\". Make sure to compile and save this program as \"pgm2.xsm\". Below given program will create a new file according to the PID of the process and read 100 numbers from file \"numbers.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 numbers each X*1000 -X*1000+99, where X=[3,4..14]. The numbers written by a process in the newly created file need not be the same numbers the process has written in \"numbers.dat\" file. The code for the test program can be found here","title":"Test Program 12"},{"location":"test-programs/#test-program-13","text":"Input - Output (For each 8 processes with PID = 2 to 9) Return values from Fork system call and integers from PID*100 to PID*100+9. Description : This program calls fork 3 times creating 8 child processes. Each process prints the value returned from the last Fork system call and Exec system call is invoked with file \"child.xsm\". The \"child.xsm\" program stores numbers from PID*100 to PID*100+9 onto a linked list and prints them to the console. The code for the parent.expl can be found here and the code for the child.expl can be found here","title":"Test Program 13"},{"location":"test-programs/#test-program-14-merge-sort","text":"Input - Output Print numbers from 1 to 64 in ascending order. Description : These two ExpL programs perform merge sort in two different ways. The first one is done in a sequential manner and the second one, in a concurrent approach. Values from 1 to 64 are stored in decreasing order in a linked list and are sorted using a recursive merge sort function. In the concurrent approach, the process is forked and the merge sort function is called recursively for the two sub-lists from the two child processes. The code for the Sequential approach can be found here and the code for the Concurrent approach can be found here","title":"Test Program 14 (Merge Sort)"},{"location":"test-programs/#test-program-15-merge-files","text":"Input - Output Creates a file merge.dat with numbers from 1 to 2048. Description : The ExpL program first creates 4 files with values from s to 4*c+s, where s=[1..and c=[0..511]. The program then, merges the 4 files taking 2 at a time, and finally, creates a merge.dat file containing numbers from 1 to 2048. The code for the test program can be found here","title":"Test Program 15 (Merge Files)"},{"location":"test-programs/#test-program-16-merge-sort-with-files","text":"Input - Output Creates a file merge.dat with numbers from 1 to 512 and also prints them. Description : The first ExpL program, merge.expl , first stores numbers from 1 to 512 in a random order into a file merge.dat . It then forks and executes m_store.expl which creates 8 files temp{i}.dat , where i=1..8 and stores 64 numbers each from merge.expl . Then, all the temporary files are sorted by executing m_sort.expl . Next, the first ExpL program forks and executes m_merge.expl which merges all the temporary files back into merge.dat and finally, prints the contents from 1 to 512 in ascending order. The test programs are merge.expl , m_store.expl , m_sort.expl and m_merge.expl","title":"Test Program 16 (Merge Sort with Files)"},{"location":"test-programs/test-program-01/","text":"Input Executable file name/string \"Shutdown\" Output Executes given xsm program/halt system if input is \"Shutdown\" Description : shell version II without the multiuser int main() { decl int temp, pid, a; string input; enddecl begin a=1; while(a == 1) do temp = exposcall(\"Write\",-2,\"---Enter---\"); temp = exposcall(\"Read\",-1, input); if(input != \"Shutdown\") then pid = exposcall(\"Fork\"); if(pid < 0) then temp = exposcall(\"Write\",-2, \"Fork Failure\"); continue; endif; if(pid != 0) then temp = exposcall(\"Wait\",pid); else temp = exposcall(\"Exec\",input); if(temp != 0) then temp = exposcall(\"Write\",-2, \"BAD COMMAND\"); break; endif; endif; else temp = exposcall(\"Shutdown\"); break; endif; endwhile; return 0; end }","title":"Program 1"},{"location":"test-programs/test-program-02/","text":"Input An integer N and N integers. Output N integers entered in the input. Description : The program given below implements a linked list for integers. The program reads an integer N from the console. It then creates a linked list and inserts N integers entered from console into the linked list in the same order. The program traverses the linked list and prints data to the console. type List { int data; List next; } endtype decl List head; enddecl int main() { decl int length, x, temp; List p, q; enddecl begin x = exposcall(\"Heapset\"); head=null; x = exposcall(\"Read\",-1,length); q = head; while (length!=0) do temp = exposcall(\"Read\",-1,x); p= exposcall(\"Alloc\",2); p.data=x; p.next=null; if (head == null) then head=p; q=p; else q.next=p; q=q.next; endif; length=length-1; endwhile; p=head; while(p!=null) do x=p.data; temp= exposcall(\"Write\",-2,x); p=p.next; endwhile; return 0; end }","title":"Program 2"},{"location":"test-programs/test-program-03/","text":"Input - Output Integers 1 to 100, not necessarily in the order. Description : The program creates a linked list with numbers 1 to 100 in them. The program invokes fork to create a child process. The parent and the child process reads from the shared linked list with different pointers and prints the data read to the console. Parent process prints the even numbers 2, 4, 6, 8.. and child process prints 1, 3, 5 .. type List { int data; List next; } endtype decl List head; int x, pid, temp, length; enddecl int main() { decl List p, q; int i; enddecl begin temp = exposcall(\"Heapset\"); head = null; q = head; length=1; while (length <= 100) do p = exposcall(\"Alloc\",2); p.data = length; p.next = null; if (head == null) then head = p; q = p; else q.next = p; q = q.next; endif; length = length+1; endwhile; pid = exposcall(\"Fork\"); if(pid == 0) then p = head; while(p != null) do x = p.data; temp = exposcall(\"Write\",-2,x); p = p.next; if(p == null) then break; endif; p = p.next; endwhile; else q = head.next; while(q != null) do x = q.data; temp = exposcall(\"Write\",-2,x); q = q.next; if(q == null) then break; endif; q = q.next; endwhile; endif; return 0; end }","title":"Program 3"},{"location":"test-programs/test-program-04/","text":"Input - Output Integers from 1 to 100, but not necessarily in sequential order. Description : The reader-writer program provides below has two writers and one reader. The parent process will create two child processes by invoking fork . The parent and two child processes share a buffer of one word. At a time only one process can read/write to this buffer. To acheive this, these three processes use a shared semaphore. A writer process can write to the buffer if it is empty and the reader process can only read from the buffer if it is full. Before the word in the buffer is overwritten the reader process must read it and print the word to the console. The parent process is the reader process and its two children are writers. One child process writes even numbers from 1 to 100 and other one writes odd numbers from 1 to 100 to the buffer. The parent process reads the numbers and prints them on to the console. type Share { int isempty; int data; } endtype decl Share head; enddecl int main() { decl int temp, x, pidone, pidtwo, semid, iter, counter; enddecl begin x = exposcall(\"Heapset\"); semid = exposcall(\"Semget\"); head = exposcall(\"Alloc\", 2); head.isempty = 1; pidone = exposcall(\"Fork\"); if (pidone == 0) then iter = 1; while(iter <= 100) do temp = exposcall(\"SemLock\", semid); temp = head.isempty; if(temp == 1) then head.data = iter; head.isempty = 0; iter = iter + 2; endif; temp = exposcall(\"SemUnLock\", semid); counter = 0; while(counter < 50) do counter = counter + 1; endwhile; endwhile; else pidtwo = exposcall(\"Fork\"); if(pidtwo == 0) then iter = 2; while(iter <= 100) do temp = exposcall(\"SemLock\", semid); temp = head.isempty; if(temp == 1) then head.data = iter; head.isempty = 0; iter = iter + 2; endif; temp = exposcall(\"SemUnLock\", semid); endwhile; else iter = 1; while(iter <= 100) do temp = exposcall(\"SemLock\", semid); temp = head.isempty; if(temp == 0) then x = head.data; head.isempty = 1; temp = exposcall(\"Write\", -2, x); iter = iter + 1; endif; temp = exposcall(\"SemUnLock\", semid); endwhile; endif; endif; temp = exposcall(\"Semrelease\", semid); return 0; end }","title":"Program 4"},{"location":"test-programs/test-program-05/","text":"Input Name of a data file (String) Output Content of the given file Description : The program takes names of data files as input and opens the file first. It then forks to create a child process. The content of the file with shared open instance (shared LSEEK) will be printed to the terminal concurrently by parent and child. To synchronize the use open instance between parent and child a semaphore is used. decl int i, semid, pid, data, temp, filedis, a; string filename; enddecl int main() { begin temp = exposcall(\"Read\",-1,filename); filedis = exposcall(\"Open\", \"numbers.dat\"); semid = exposcall(\"Semget\"); pid = exposcall(\"Fork\"); a = 0; data = -1; if(pid > 0) then while(a != -2) do temp = exposcall(\"SemLock\", semid); a = exposcall(\"Read\",filedis,data); temp = exposcall(\"Write\",-2,data); temp = exposcall(\"SemUnLock\", semid); endwhile; temp = exposcall(\"Semrelease\", semid); else while(a != -2) do temp = exposcall(\"SemLock\", semid); a = exposcall(\"Read\",filedis,data); temp = exposcall(\"Write\",-2,data); temp = exposcall(\"SemUnLock\", semid); endwhile; temp = exposcall(\"Semrelease\", semid); endif; return 0; end }","title":"Program 5"},{"location":"test-programs/test-program-06/","text":"Input A file name (String) and permission (Integer) Output Integers from 1 to 100, but not necessarily in sequential order. Description : The program takes a file name and permission as input and creates a new file with given inputs. It then forks to create two child processes. Similar to Reader-Writer program seen before, the two child processes act as writers and parent as reader. A file open instances is shared between two writers and there is separate open instance of the same file for reader. Two writers will write numbers from 1 to 100 to file - one writer will write even numbers other will write odd numbers and reader will read from the file and print to the console concurrently. To synchronize the use of the shared open instance between two writers a semaphore is used. int main() { decl int temp, x, a, pidone, pidtwo, semid, iter, data, permission, fd; string filename; enddecl begin temp=exposcall(\"Read\",-1,filename); temp=exposcall(\"Read\",-1,permission); temp=exposcall(\"Create\",filename, permission); pidone = exposcall(\"Fork\"); if (pidone != 0 ) then fd=exposcall(\"Open\",filename); iter=1; while(iter <= 100) do a=exposcall(\"Read\",fd, data); if(a!=-2) then temp=exposcall(\"Write\",-2, data); iter=iter+1; endif; endwhile; else semid = exposcall(\"Semget\"); fd=exposcall(\"Open\",filename); pidtwo = exposcall(\"Fork\"); if(pidtwo == 0) then iter = 1; while(iter <= 100) do temp = exposcall(\"SemLock\", semid); temp=exposcall(\"Write\",fd, iter); temp = exposcall(\"SemUnLock\", semid); iter=iter+2; endwhile; else iter = 2; while(iter <= 100) do temp = exposcall(\"SemLock\", semid); temp=exposcall(\"Write\",fd, iter); temp = exposcall(\"SemUnLock\", semid); iter=iter+2; endwhile; endif; temp = exposcall(\"Semrelease\", semid); endif; return 0; end }","title":"Program 6"},{"location":"test-programs/test-program-07/","text":"Input Built in shell command/ Name of XSM executable file (String) Output Ouput of corresponding to shell command or executable file. Description : Shell program given below reads command from console. If the command is halt, then program will invoke Shutdown system call. If the command is built in shell command, then shell will read suitable number of arguments from the console and corresponding system call is invoked from shell itself. If the command is an executable file, shell will fork and exec with the given executable file. Note that the shell program should fit in 2 blocks/pages provided in disk/memory organization . The program given below is optimized to fits in 2 blocks/pages. In order to optimize the code, the program violates some of the type checkings. Even with type checking errors, the program will still compile and execute correctly. Also some system calls are invoked with arguments, even though the system call does not need any arguments. This will not cause any problem as these arguments will simply be ignored in the corresponding system call. int main() { decl int temp, pid, a, flag, retcom; string input, username, password; enddecl begin a=1; while(a == 1) do temp = exposcall(\"Write\",-2, \"---Enter---\"); temp = exposcall(\"Read\",-1, input); flag=0; if(input == \"Logout\" OR input == \"Shutdown\") then flag=1; endif; if(input == \"Remusr\" OR input == \"Getuid\" OR input == \"Getuname\") then flag=1; temp = exposcall(\"Read\",-1, username); endif; if(input == \"Newusr\" OR input == \"Setpwd\") then flag=1; temp = exposcall(\"Read\",-1, username); temp = exposcall(\"Read\",-1, password); endif; if(flag==1) then retcom = exposcall(input, username, password); if(retcom < 0) then temp = exposcall(\"Write\",-2, \"BAD COMMAND\"); else if(input == \"Getuid\" OR input == \"Getuname\") then temp = exposcall(\"Write\",-2, retcom); endif; endif; else pid = exposcall(\"Fork\"); if(pid < 0) then temp = exposcall(\"Write\",-2, \"Fork Fail\"); continue; endif; if(pid != 0) then temp = exposcall(\"Wait\",pid); else temp = exposcall(\"Exec\",input); if(temp != 0) then temp = exposcall(\"Write\",-2, \"BAD COMMAND\"); break; endif; endif; endif; endwhile; return 0; end }","title":"Program 7"},{"location":"test-programs/test-program-08/","text":"Input Delay Parameter Output 8 integers - PID*100 to PID*100+7. Description : The program given in above link will first read a delay parameter and then, call the Fork system call and create 12 processes. Each process prints numbers from PID*100 to PID*100 + 7. After printing each number, a delay function is called with the the delay parameter provided. decl int temp, data, pid, count, delay; int delayFunc(int delay); enddecl int delayFunc(int delay) { decl int num; enddecl begin num = 0; while(num < delay) do num = num + 1; endwhile; return 0; end } int main() { begin read(delay); pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); if(pid < 0) then write(\"No PCB\"); endif; pid = exposcall(\"Getpid\"); count = 0; while(count < 8) do data = pid*100 + count; write(data); temp = delayFunc(delay); count = count + 1; endwhile; return 0; end }","title":"Program 8"},{"location":"test-programs/test-program-09/","text":"Input - Output Out of 12 processes created, if N processes complete execution, then N data files each containing 100 consecutive integers (PID-3)*100+1 to (PID-3)*100+100 are created. Description : The program will create a file with name \"num.dat\" with open permission. Integers 1 to 1200 are written to this file and file is closed. The program will then invoke Fork system call four times, back to back to create 12 processes and Exec system call is invoked with file \"pgm1.xsm\". The program for \"pgm1.xsm\" is provided here . int main() { decl int temp, fd, permission, iter, pid; string filename; enddecl begin filename=\"num.dat\"; permission=1; temp=exposcall(\"Create\",filename,permission); fd=exposcall(\"Open\",filename); if(fd>=0) then iter=1; while(iter<=1200) do temp=exposcall(\"Write\",fd, iter); iter=iter+1; endwhile; temp=exposcall(\"Close\",fd); pid=exposcall(\"Fork\"); pid=exposcall(\"Fork\"); pid=exposcall(\"Fork\"); pid=exposcall(\"Fork\"); temp = exposcall(\"Exec\",\"pgm1.xsm\"); else temp=exposcall(\"Write\",-2, \"OPEN FAIL\"); endif; return 0; end }","title":"Program 9"},{"location":"test-programs/test-program-10/","text":"Input - Output (For each 12 proceesses) A file will be created containing 100 consecutive numbers (PID-3)*100+1 to (PID-3)*100+100 Description : This program can not be run individualy. The test program 9 will invoke Exec with below given program with name \"pgm1.xsm\". Make sure to compile and save this program as \"pgm1.xsm\". Below given program will create a new file according to the PID of the process and read 100 numbers from file \"num.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 consecutive numbers (PID-3)*100+1 to PID-3)*100+100. int main() { decl int temp, fdread, fdwrite, permission, pid, offset, data, iter; string filename; enddecl begin pid=exposcall(\"Getpid\"); if(pid==3) then filename=\"3.dat\"; endif; if(pid==4) then filename=\"4.dat\"; endif; if(pid==5) then filename=\"5.dat\"; endif; if(pid==6) then filename=\"6.dat\"; endif; if(pid==7) then filename=\"7.dat\"; endif; if(pid==8) then filename=\"8.dat\"; endif; if(pid==9) then filename=\"9.dat\"; endif; if(pid==10) then filename=\"10.dat\"; endif; if(pid==11) then filename=\"11.dat\"; endif; if(pid==12) then filename=\"12.dat\"; endif; if(pid==13) then filename=\"13.dat\"; endif; if(pid==14) then filename=\"14.dat\"; endif; permission=1; temp=exposcall(\"Create\",filename,permission); fdwrite=exposcall(\"Open\",filename); fdread=exposcall(\"Open\",\"num.dat\"); if(fdread>=0 AND fdwrite>=0) then offset=(pid-3)*100; temp=exposcall(\"Seek\",fdread,offset); iter=0; while(iter<100) do temp=exposcall(\"Read\", fdread, data); temp=exposcall(\"Write\", fdwrite, data); iter=iter+1; endwhile; temp=exposcall(\"Close\", fdread); temp=exposcall(\"Close\", fdwrite); else temp=exposcall(\"Write\", -2, \"OPEN FAIL\"); endif; return 0; end }","title":"Program 10"},{"location":"test-programs/test-program-11/","text":"Input - Output Out of 12 processes created, if N processes complete execution, then N data files each containing 100 consecutive integers from X*1000+1 to X*1000+100 (where X \u2208 {3,4..14}) are created. Description : The program will create a file with name \"numbers.dat\" with open permission and open the file. The program also invokes Semget to acquire a shared semaphore. The program will then invoke Fork system call four times, back to back to create 12 processes. The 12 processes now share a file open instance and a semaphore. Each process will write 100 numbers consecutatively (PID*1000+1 to PID*1000+100) to the file \"numbers.dat\". Exec system call is invoked with file \"pgm2.xsm\". The program for \"pgm2.xsm\" is provided here . decl int fd, temp, permission, data, semid, iter, pid, endval, count; string filename; enddecl int main() { begin filename=\"numbers.dat\"; permission=1; temp = exposcall(\"Create\",filename, permission); semid = exposcall(\"Semget\"); fd=exposcall(\"Open\",filename); if(fd>=0) then pid=exposcall(\"Fork\"); pid=exposcall(\"Fork\"); pid=exposcall(\"Fork\"); pid=exposcall(\"Fork\"); if(pid<0) then temp=exposcall(\"Write\", -2, \"NO PCB\"); endif; pid=exposcall(\"Getpid\"); data=pid*1000+1; endval=data+99; temp=exposcall(\"SemLock\", semid); while(data<=endval) do temp=exposcall(\"Write\", fd, data); data=data+1; endwhile; temp=exposcall(\"SemUnLock\", semid); temp=exposcall(\"Close\", fd); else temp=exposcall(\"Write\", -2, \"OPEN FAIL\"); endif; temp=exposcall(\"Exec\", \"pgm2.xsm\"); return 0; end }","title":"Program 11"},{"location":"test-programs/test-program-12/","text":"Input - Output (For each 12 proceesses) A file will be created containing 100 consecutive numbers from data file \"numbers.dat\". Description : This program can not be run individualy. Test program 11 will invoke Exec with below given program with name \"pgm2.xsm\". Make sure to compile and save this program as \"pgm2.xsm\". Below given program will create a new file according to the PID of the process and read 100 numbers from file \"numbers.dat\" from offset (PID-3)*100 to (PID-3)*100+99 and write to newly created file. After successful execution, there should be 12 data files each containing 100 numbers each X*1000 -X*1000+99, where X=[3,4..14]. The numbers written by a process in the newly created file need not be the same numbers the process has written in \"numbers.dat\" file. decl int data; int fdread, fdwrite, temp, permission, offset, pid, iter; string filename, newfile; enddecl int main() { begin fdread=exposcall(\"Open\", \"numbers.dat\"); pid=exposcall(\"Getpid\"); if(pid==3) then newfile=\"three.dat\"; endif; if(pid==4) then newfile=\"four.dat\"; endif; if(pid==5) then newfile=\"five.dat\"; endif; if(pid==6) then newfile=\"six.dat\"; endif; if(pid==7) then newfile=\"seven.dat\"; endif; if(pid==8) then newfile=\"eight.dat\"; endif; if(pid==9) then newfile=\"nine.dat\"; endif; if(pid==10) then newfile=\"ten.dat\"; endif; if(pid==11) then newfile=\"eleven.dat\"; endif; if(pid==12) then newfile=\"twelve.dat\"; endif; if(pid==13) then newfile=\"thirteen.dat\"; endif; if(pid==14) then newfile=\"fourteen.dat\"; endif; temp=exposcall(\"Create\", newfile, 1); fdwrite=exposcall(\"Open\", newfile); if(fdread>=0 AND fdwrite>=0) then offset=(pid-3)*100; temp=exposcall(\"Seek\",fdread, offset); iter=0; while(iter<=99) do temp=exposcall(\"Read\",fdread, data); temp=exposcall(\"Write\",fdwrite, data); iter=iter+1; endwhile; temp=exposcall(\"Close\",fdread); temp=exposcall(\"Close\",fdwrite); else temp=exposcall(\"Write\",-2, \"OPEN FAIL\"); endif; return 0; end }","title":"Program 12"},{"location":"test-programs/test-program-13/","text":"Input - Output (For each 8 processes with PID = 2 to 9) Return values from Fork system call and integers from PID*100 to PID*100+9. Description : This program calls fork 3 times creating 8 child processes. Each process prints the value returned from the last Fork system call and Exec system call is invoked with file \"child.xsm\". The \"child.xsm\" program stores numbers from PID*100 to PID*100+9 onto a linked list and prints them to the console. parent.expl \u00b6 int main() { decl int temp,pid; enddecl begin pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); if(pid==-1) then temp=exposcall(\"Write\", -2, \"Fork Error\"); else temp=exposcall(\"Write\", -2, pid); endif; temp = exposcall(\"Exec\", \"child.xsm\"); return 0; end } child.expl \u00b6 type List { int data; List next; } endtype decl List head, p, q; enddecl int main() { decl int x, temp, pid, counter; enddecl begin x = initialize(); pid = exposcall(\"Getpid\"); head=null; counter=0; while(counter<10) do p=alloc(); p.data=pid*100 + counter; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; counter=counter+1; endwhile; p=head; while(p!=null) do write(p.data); p=p.next; endwhile; return 0; end }","title":"Program 13"},{"location":"test-programs/test-program-13/#parentexpl","text":"int main() { decl int temp,pid; enddecl begin pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); pid = exposcall(\"Fork\"); if(pid==-1) then temp=exposcall(\"Write\", -2, \"Fork Error\"); else temp=exposcall(\"Write\", -2, pid); endif; temp = exposcall(\"Exec\", \"child.xsm\"); return 0; end }","title":"parent.expl"},{"location":"test-programs/test-program-13/#childexpl","text":"type List { int data; List next; } endtype decl List head, p, q; enddecl int main() { decl int x, temp, pid, counter; enddecl begin x = initialize(); pid = exposcall(\"Getpid\"); head=null; counter=0; while(counter<10) do p=alloc(); p.data=pid*100 + counter; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; counter=counter+1; endwhile; p=head; while(p!=null) do write(p.data); p=p.next; endwhile; return 0; end }","title":"child.expl"},{"location":"test-programs/test-program-14/","text":"Input - Output Print numbers from 1 to 64 in ascending order. Description : These two ExpL programs perform merge sort in two different ways. The first one is done in a sequential manner and the second one, in a concurrent approach. Values from 1 to 64 are stored in decreasing order in a linked list and are sorted using a recursive merge sort function. In the concurrent approach, the process is forked and the merge sort function is called recursively for the two sub-lists from the two child processes. Merge Sort - Sequential \u00b6 type List { int data; List next; } endtype decl List head; List mergeSort(List top); List merge(List a, List b); enddecl List mergeSort(List top) { decl List slow, fast, a, b; enddecl begin if((top!=null) AND (top.next!=null)) then slow=top; fast=top.next; //Divide the list into two parts while(fast!=null) do fast=fast.next; if(fast!=null) then slow=slow.next; fast=fast.next; endif; endwhile; a=top; b=slow.next; slow.next=null; //Recursively call merge sort a=mergeSort(a); b=mergeSort(b); //Merge the two lists top=merge(a, b); endif; return top; end } List merge(List a, List b) { decl List result; enddecl begin result=null; if(a==null) then result=b; endif; if(b==null) then result=a; endif; if(a!=null AND b!=null) then if(a.data<=b.data) then result=a; result.next=merge(a.next, b); else result=b; result.next=merge(a, b.next); endif; endif; return result; end } int main() { decl int x, counter; List p, q; enddecl begin x = initialize(); //Storing values in descending order head=null; counter=0; while(counter<64) do p=alloc(); p.data=64-counter; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; counter=counter+1; endwhile; //Calling Merge Sort head=mergeSort(head); //Printing Values p=head; while(p!=null) do write(p.data); p=p.next; endwhile; return 1; end } Merge Sort - Concurrent \u00b6 type List { int data; List next; } Share { List link; } endtype decl int x, semid; List head; List mergeSort(List top); List merge(List a, List b); enddecl List mergeSort(List top) { decl int len, pid; List slow, fast, a, b; Share s; enddecl begin len=1; if((top!=null) AND (top.next!=null)) then x=exposcall(\"SemLock\", semid); slow=top; fast=top.next; //Divide the list into two parts while(fast!=null) do fast=fast.next; len=len+1; if(fast!=null) then slow=slow.next; fast=fast.next; len=len+1; endif; endwhile; a=top; b=slow.next; slow.next=null; x=exposcall(\"SemUnLock\", semid); //If size less than 4, don't Fork if(len<=4) then a=mergeSort(a); b=mergeSort(b); else x=exposcall(\"SemLock\", semid); s=alloc(); x=exposcall(\"SemUnLock\", semid); pid=exposcall(\"Fork\"); //If Fork is not possible, do sequential if(pid==-1) then a=mergeSort(a); b=mergeSort(b); else s.link=null; //Sort from two different process if(pid!=0) then a=mergeSort(a); else b=mergeSort(b); s.link=b; //Store head in shared location x=exposcall(\"Exit\"); endif; x=exposcall(\"Wait\", pid); b=s.link; endif; x=exposcall(\"SemLock\", semid); free(s); x=exposcall(\"SemUnLock\", semid); endif; //Merge the two lists x=exposcall(\"SemLock\", semid); top=merge(a, b); x=exposcall(\"SemUnLock\", semid); endif; return top; end } List merge(List a, List b) { decl List result; enddecl begin result=null; if(a==null) then result=b; endif; if(b==null) then result=a; endif; if(a!=null AND b!=null) then if(a.data<=b.data) then result=a; result.next=merge(a.next, b); else result=b; result.next=merge(a, b.next); endif; endif; return result; end } int main() { decl int x, counter; List p, q; enddecl begin x = initialize(); semid = exposcall(\"Semget\"); //Storing values in descending order head=null; counter=0; while(counter<64) do p=alloc(); p.data=64-counter; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; counter=counter+1; endwhile; //Calling Merge Sort head=mergeSort(head); //Printing Values p=head; while(p!=null) do write(p.data); p=p.next; endwhile; x = exposcall(\"Semrelease\"); return 1; end }","title":"Program 14"},{"location":"test-programs/test-program-14/#merge-sort-sequential","text":"type List { int data; List next; } endtype decl List head; List mergeSort(List top); List merge(List a, List b); enddecl List mergeSort(List top) { decl List slow, fast, a, b; enddecl begin if((top!=null) AND (top.next!=null)) then slow=top; fast=top.next; //Divide the list into two parts while(fast!=null) do fast=fast.next; if(fast!=null) then slow=slow.next; fast=fast.next; endif; endwhile; a=top; b=slow.next; slow.next=null; //Recursively call merge sort a=mergeSort(a); b=mergeSort(b); //Merge the two lists top=merge(a, b); endif; return top; end } List merge(List a, List b) { decl List result; enddecl begin result=null; if(a==null) then result=b; endif; if(b==null) then result=a; endif; if(a!=null AND b!=null) then if(a.data<=b.data) then result=a; result.next=merge(a.next, b); else result=b; result.next=merge(a, b.next); endif; endif; return result; end } int main() { decl int x, counter; List p, q; enddecl begin x = initialize(); //Storing values in descending order head=null; counter=0; while(counter<64) do p=alloc(); p.data=64-counter; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; counter=counter+1; endwhile; //Calling Merge Sort head=mergeSort(head); //Printing Values p=head; while(p!=null) do write(p.data); p=p.next; endwhile; return 1; end }","title":"Merge Sort - Sequential"},{"location":"test-programs/test-program-14/#merge-sort-concurrent","text":"type List { int data; List next; } Share { List link; } endtype decl int x, semid; List head; List mergeSort(List top); List merge(List a, List b); enddecl List mergeSort(List top) { decl int len, pid; List slow, fast, a, b; Share s; enddecl begin len=1; if((top!=null) AND (top.next!=null)) then x=exposcall(\"SemLock\", semid); slow=top; fast=top.next; //Divide the list into two parts while(fast!=null) do fast=fast.next; len=len+1; if(fast!=null) then slow=slow.next; fast=fast.next; len=len+1; endif; endwhile; a=top; b=slow.next; slow.next=null; x=exposcall(\"SemUnLock\", semid); //If size less than 4, don't Fork if(len<=4) then a=mergeSort(a); b=mergeSort(b); else x=exposcall(\"SemLock\", semid); s=alloc(); x=exposcall(\"SemUnLock\", semid); pid=exposcall(\"Fork\"); //If Fork is not possible, do sequential if(pid==-1) then a=mergeSort(a); b=mergeSort(b); else s.link=null; //Sort from two different process if(pid!=0) then a=mergeSort(a); else b=mergeSort(b); s.link=b; //Store head in shared location x=exposcall(\"Exit\"); endif; x=exposcall(\"Wait\", pid); b=s.link; endif; x=exposcall(\"SemLock\", semid); free(s); x=exposcall(\"SemUnLock\", semid); endif; //Merge the two lists x=exposcall(\"SemLock\", semid); top=merge(a, b); x=exposcall(\"SemUnLock\", semid); endif; return top; end } List merge(List a, List b) { decl List result; enddecl begin result=null; if(a==null) then result=b; endif; if(b==null) then result=a; endif; if(a!=null AND b!=null) then if(a.data<=b.data) then result=a; result.next=merge(a.next, b); else result=b; result.next=merge(a, b.next); endif; endif; return result; end } int main() { decl int x, counter; List p, q; enddecl begin x = initialize(); semid = exposcall(\"Semget\"); //Storing values in descending order head=null; counter=0; while(counter<64) do p=alloc(); p.data=64-counter; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; counter=counter+1; endwhile; //Calling Merge Sort head=mergeSort(head); //Printing Values p=head; while(p!=null) do write(p.data); p=p.next; endwhile; x = exposcall(\"Semrelease\"); return 1; end }","title":"Merge Sort - Concurrent"},{"location":"test-programs/test-program-15/","text":"Input - Output Creates a file merge.dat with numbers from 1 to 2048. Description : The ExpL program first creates 4 files with values from s to 4*c+s, where s=[1..and c=[0..511]. The program then, merges the 4 files taking 2 at a time, and finally, creates a merge.dat file containing numbers from 1 to 2048. decl int store(str file, int start); int merge(str out, str in1, str in2); enddecl //Storing 512 numbers in file int store(str file, int start) { decl int x, fp, counter, val; enddecl begin //Create and open the file x=exposcall(\"Create\", file); fp=exposcall(\"Open\", file, 1); //Store the numbers into the file counter=0; while(counter<512) do val=4*counter+start; x=exposcall(\"Write\", fp, val); counter=counter+1; endwhile; //Close the file x=exposcall(\"Close\", fp); write(\"Stored\"); return 0; end } //Merging files \"in1\" and \"in2\" into \"out\" int merge(str out, str in1, str in2) { decl int fp, fp1, fp2; int x, a, b, w1, w2; enddecl begin //Create and open output file x=exposcall(\"Create\", out, 1); fp=exposcall(\"Open\", out); //Open both the input files fp1=exposcall(\"Open\", in1); fp2=exposcall(\"Open\", in2); //Read the first number from both input files //and store them in w1 and w2 a=exposcall(\"Read\", fp1, w1); b=exposcall(\"Read\", fp2, w2); //Store min(w1,w2) in output file and //read the next number until one //file reaches end of file while(a!=-2 AND b!=-2) do if(w1<=w2) then x=exposcall(\"Write\", fp, w1); a=exposcall(\"Read\", fp1, w1); else x=exposcall(\"Write\", fp, w2); b=exposcall(\"Read\", fp2, w2); endif; endwhile; //If second input file ends, //copy the contents from first input file //to the output file while(a!=-2) do x=exposcall(\"Write\", fp, w1); a=exposcall(\"Read\", fp1, w1); endwhile; //If first input file ends, //copy the contents from second input file //to the output file while(b!=-2) do x=exposcall(\"Write\", fp, w2); b=exposcall(\"Read\", fp2, w2); endwhile; //Close all the files x=exposcall(\"Close\", fp); x=exposcall(\"Close\", fp1); x=exposcall(\"Close\", fp2); //Delete the input files x=exposcall(\"Delete\", in1); x=exposcall(\"Delete\", in2); write(\"Merged\"); return 0; end } int main() { decl int x, pid1, pid2, fp; enddecl begin pid1=exposcall(\"Fork\"); if(pid1!=0) then pid2=exposcall(\"Fork\"); if(pid2!=0) then //Store the numbers into \"temp1.dat\" x=store(\"temp1.dat\", 1); x=exposcall(\"Wait\", pid2); else //Store the numbers into \"temp2.dat\" x=store(\"temp2.dat\", 2); x=exposcall(\"Exit\"); endif; //Merge \"temp1.dat\" and \"temp2.dat\" into \"tempa.dat\" x=merge(\"tempa.dat\", \"temp1.dat\", \"temp2.dat\"); x=exposcall(\"Wait\", pid1); else pid2=exposcall(\"Fork\"); if(pid2!=0) then //Store the numbers into \"temp3.dat\" x=store(\"temp3.dat\", 3); x=exposcall(\"Wait\", pid2); else //Store the numbers into \"temp4.dat\" x=store(\"temp4.dat\", 4); x=exposcall(\"Exit\"); endif; //Merge \"temp3.dat\" and \"temp4.dat\" into \"tempb.dat\" x=merge(\"tempb.dat\", \"temp3.dat\", \"temp4.dat\"); x=exposcall(\"Exit\"); endif; //Merge \"tempa.dat\" and \"tempb.dat\" into \"merge.dat\" //which contains numbers from 1 to 2048 in sorted order x=merge(\"merge.dat\", \"tempa.dat\", \"tempb.dat\"); return 1; end }","title":"Program 15"},{"location":"test-programs/test-program-16/","text":"Input - Output Creates a file merge.dat with numbers from 1 to 512 and also prints them. Description : The first ExpL program, merge.expl , first stores numbers from 1 to 512 in a random order into a file merge.dat . It then forks and executes m_store.expl which creates 8 files temp{i}.dat , where i=1..8 and stores 64 numbers each from merge.expl . Then, all the temporary files are sorted by executing m_sort.expl . Next, the first ExpL program forks and executes m_merge.expl which merges all the temporary files back into merge.dat and finally, prints the contents from 1 to 512 in ascending order. merge.expl \u00b6 int main() { decl int x, fp, counter, word, a, pid; enddecl begin x=initialize(); x=exposcall(\"Create\", \"merge.dat\", 1); fp=exposcall(\"Open\", \"merge.dat\"); counter=0; while(counter<512) do word=512-counter; x=exposcall(\"Write\", fp, word); counter=counter+1; endwhile; write(\"Created\"); pid=exposcall(\"Fork\"); if(pid!=0) then x=exposcall(\"Wait\", pid); else x=exposcall(\"Exec\", \"m_store.xsm\"); endif; pid=exposcall(\"Fork\"); if(pid!=0) then x=exposcall(\"Wait\", pid); else x=exposcall(\"Exec\", \"m_merge.xsm\"); endif; a=exposcall(\"Seek\", fp, 0); a=exposcall(\"Read\", fp, word); while(a!=-2) do write(word); a=exposcall(\"Read\", fp, word); endwhile; x=exposcall(\"Close\", fp); return 1; end } m_store.expl \u00b6 decl int store(str file, int start); enddecl int store(str file, int start) { decl int x, fp, fp1, a, word, counter; enddecl begin x=exposcall(\"Create\", file, 1); fp=exposcall(\"Open\", \"merge.dat\"); fp1=exposcall(\"Open\", file); x=exposcall(\"Seek\", fp, start); counter=0; a=exposcall(\"Read\", fp, word); while(a!=-2 AND counter<64) do x=exposcall(\"Write\", fp1, word); a=exposcall(\"Read\", fp, word); counter=counter+1; endwhile; x=exposcall(\"Close\", fp); x=exposcall(\"Close\", fp1); return 0; end } int main() { decl int x, pid, pid1, pid2; str file; enddecl begin x=initialize(); pid=exposcall(\"Fork\"); if(pid!=0) then while(pid<13) do x=exposcall(\"Wait\", pid); pid=pid+1; endwhile; else x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); pid=exposcall(\"Getpid\"); if(pid==5) then file=\"temp1.dat\"; endif; if(pid==6) then file=\"temp2.dat\"; endif; if(pid==7) then file=\"temp3.dat\"; endif; if(pid==8) then file=\"temp4.dat\"; endif; if(pid==9) then file=\"temp5.dat\"; endif; if(pid==10) then file=\"temp6.dat\"; endif; if(pid==11) then file=\"temp7.dat\"; endif; if(pid==12) then file=\"temp8.dat\"; endif; pid=(pid-5)*64; x=store(file, pid); x=exposcall(\"Exit\"); endif; write(\"Stored\"); pid=exposcall(\"Fork\"); if(pid!=0) then while(pid<13) do x=exposcall(\"Wait\", pid); pid=pid+1; endwhile; else x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); x=exposcall(\"Exec\", \"m_sort.xsm\"); endif; write(\"Sorted\"); return 1; end } m_sort.expl \u00b6 type List { int data; List next; } Share { List link; } endtype decl int x, semid, fp; List head; List mergeSort(List top); List merge(List a, List b); enddecl List mergeSort(List top) { decl int pid; List slow, fast, a, b; Share s; enddecl begin if((top!=null) AND (top.next!=null)) then slow=top; fast=top.next; while(fast!=null) do fast=fast.next; if(fast!=null) then slow=slow.next; fast=fast.next; endif; endwhile; a=top; b=slow.next; slow.next=null; a=mergeSort(a); b=mergeSort(b); top=merge(a, b); endif; return top; end } List merge(List a, List b) { decl List result; enddecl begin result=null; if(a==null) then result=b; endif; if(b==null) then result=a; endif; if(a!=null AND b!=null) then if(a.data<=b.data) then result=a; result.next=merge(a.next, b); else result=b; result.next=merge(a, b.next); endif; endif; return result; end } int main() { decl int x, counter, pid, fp, a, word; str file; List p, q; enddecl begin x=initialize(); semid=exposcall(\"Semget\"); pid=exposcall(\"Getpid\"); if(pid==5) then file=\"temp1.dat\"; endif; if(pid==6) then file=\"temp2.dat\"; endif; if(pid==7) then file=\"temp3.dat\"; endif; if(pid==8) then file=\"temp4.dat\"; endif; if(pid==9) then file=\"temp5.dat\"; endif; if(pid==10) then file=\"temp6.dat\"; endif; if(pid==11) then file=\"temp7.dat\"; endif; if(pid==12) then file=\"temp8.dat\"; endif; fp=exposcall(\"Open\", file); head=null; counter=0; a=exposcall(\"Read\", fp, word); while(counter<64) do p=alloc(); p.data=word; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; a=exposcall(\"Read\", fp, word); counter=counter+1; endwhile; head=mergeSort(head); x=exposcall(\"Seek\", fp, 0); p=head; while(p!=null) do word=p.data; x=exposcall(\"Write\", fp, word); p=p.next; endwhile; x=exposcall(\"Close\", fp); x=exposcall(\"Semrelease\"); pid=exposcall(\"Getpid\"); x=pid+1; while(x<13) do a=exposcall(\"Wait\",x); x=x+1; endwhile; return 1; end } m_merge.expl \u00b6 decl int merge(str out, str in1, str in2); enddecl int merge(str out, str in1, str in2) { decl int fp, fp1, fp2; int x, a, b, w1, w2; enddecl begin x=exposcall(\"Create\", out, 1); fp=exposcall(\"Open\", out); fp1=exposcall(\"Open\", in1); fp2=exposcall(\"Open\", in2); a=exposcall(\"Read\", fp1, w1); b=exposcall(\"Read\", fp2, w2); while(a!=-2 AND b!=-2) do if(w1<=w2) then x=exposcall(\"Write\", fp, w1); a=exposcall(\"Read\", fp1, w1); else x=exposcall(\"Write\", fp, w2); b=exposcall(\"Read\", fp2, w2); endif; endwhile; while(a!=-2) do x=exposcall(\"Write\", fp, w1); a=exposcall(\"Read\", fp1, w1); endwhile; while(b!=-2) do x=exposcall(\"Write\", fp, w2); b=exposcall(\"Read\", fp2, w2); endwhile; x=exposcall(\"Close\", fp); x=exposcall(\"Close\", fp1); x=exposcall(\"Close\", fp2); x=exposcall(\"Delete\", in1); x=exposcall(\"Delete\", in2); return 0; end } int main() { decl int x, pid, pid1, pid2; enddecl begin x=initialize(); pid1=exposcall(\"Fork\"); if(pid1!=0) then pid2=exposcall(\"Fork\"); if(pid2!=0) then x=merge(\"temp12.dat\", \"temp1.dat\", \"temp2.dat\"); x=exposcall(\"Wait\", pid2); else x=merge(\"temp34.dat\", \"temp3.dat\", \"temp4.dat\"); x=exposcall(\"Exit\"); endif; x=merge(\"temp14.dat\", \"temp12.dat\", \"temp34.dat\"); x=exposcall(\"Wait\", pid1); else pid2=exposcall(\"Fork\"); if(pid2!=0) then x=merge(\"temp56.dat\", \"temp5.dat\", \"temp6.dat\"); x=exposcall(\"Wait\", pid2); else x=merge(\"temp78.dat\", \"temp7.dat\", \"temp8.dat\"); x=exposcall(\"Exit\"); endif; x=merge(\"temp58.dat\", \"temp56.dat\", \"temp78.dat\"); x=exposcall(\"Exit\"); endif; x=merge(\"merge.dat\", \"temp14.dat\", \"temp58.dat\"); write(\"Merged\"); return 1; end }","title":"Program 16"},{"location":"test-programs/test-program-16/#mergeexpl","text":"int main() { decl int x, fp, counter, word, a, pid; enddecl begin x=initialize(); x=exposcall(\"Create\", \"merge.dat\", 1); fp=exposcall(\"Open\", \"merge.dat\"); counter=0; while(counter<512) do word=512-counter; x=exposcall(\"Write\", fp, word); counter=counter+1; endwhile; write(\"Created\"); pid=exposcall(\"Fork\"); if(pid!=0) then x=exposcall(\"Wait\", pid); else x=exposcall(\"Exec\", \"m_store.xsm\"); endif; pid=exposcall(\"Fork\"); if(pid!=0) then x=exposcall(\"Wait\", pid); else x=exposcall(\"Exec\", \"m_merge.xsm\"); endif; a=exposcall(\"Seek\", fp, 0); a=exposcall(\"Read\", fp, word); while(a!=-2) do write(word); a=exposcall(\"Read\", fp, word); endwhile; x=exposcall(\"Close\", fp); return 1; end }","title":"merge.expl"},{"location":"test-programs/test-program-16/#m_storeexpl","text":"decl int store(str file, int start); enddecl int store(str file, int start) { decl int x, fp, fp1, a, word, counter; enddecl begin x=exposcall(\"Create\", file, 1); fp=exposcall(\"Open\", \"merge.dat\"); fp1=exposcall(\"Open\", file); x=exposcall(\"Seek\", fp, start); counter=0; a=exposcall(\"Read\", fp, word); while(a!=-2 AND counter<64) do x=exposcall(\"Write\", fp1, word); a=exposcall(\"Read\", fp, word); counter=counter+1; endwhile; x=exposcall(\"Close\", fp); x=exposcall(\"Close\", fp1); return 0; end } int main() { decl int x, pid, pid1, pid2; str file; enddecl begin x=initialize(); pid=exposcall(\"Fork\"); if(pid!=0) then while(pid<13) do x=exposcall(\"Wait\", pid); pid=pid+1; endwhile; else x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); pid=exposcall(\"Getpid\"); if(pid==5) then file=\"temp1.dat\"; endif; if(pid==6) then file=\"temp2.dat\"; endif; if(pid==7) then file=\"temp3.dat\"; endif; if(pid==8) then file=\"temp4.dat\"; endif; if(pid==9) then file=\"temp5.dat\"; endif; if(pid==10) then file=\"temp6.dat\"; endif; if(pid==11) then file=\"temp7.dat\"; endif; if(pid==12) then file=\"temp8.dat\"; endif; pid=(pid-5)*64; x=store(file, pid); x=exposcall(\"Exit\"); endif; write(\"Stored\"); pid=exposcall(\"Fork\"); if(pid!=0) then while(pid<13) do x=exposcall(\"Wait\", pid); pid=pid+1; endwhile; else x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); x=exposcall(\"Fork\"); x=exposcall(\"Exec\", \"m_sort.xsm\"); endif; write(\"Sorted\"); return 1; end }","title":"m_store.expl"},{"location":"test-programs/test-program-16/#m_sortexpl","text":"type List { int data; List next; } Share { List link; } endtype decl int x, semid, fp; List head; List mergeSort(List top); List merge(List a, List b); enddecl List mergeSort(List top) { decl int pid; List slow, fast, a, b; Share s; enddecl begin if((top!=null) AND (top.next!=null)) then slow=top; fast=top.next; while(fast!=null) do fast=fast.next; if(fast!=null) then slow=slow.next; fast=fast.next; endif; endwhile; a=top; b=slow.next; slow.next=null; a=mergeSort(a); b=mergeSort(b); top=merge(a, b); endif; return top; end } List merge(List a, List b) { decl List result; enddecl begin result=null; if(a==null) then result=b; endif; if(b==null) then result=a; endif; if(a!=null AND b!=null) then if(a.data<=b.data) then result=a; result.next=merge(a.next, b); else result=b; result.next=merge(a, b.next); endif; endif; return result; end } int main() { decl int x, counter, pid, fp, a, word; str file; List p, q; enddecl begin x=initialize(); semid=exposcall(\"Semget\"); pid=exposcall(\"Getpid\"); if(pid==5) then file=\"temp1.dat\"; endif; if(pid==6) then file=\"temp2.dat\"; endif; if(pid==7) then file=\"temp3.dat\"; endif; if(pid==8) then file=\"temp4.dat\"; endif; if(pid==9) then file=\"temp5.dat\"; endif; if(pid==10) then file=\"temp6.dat\"; endif; if(pid==11) then file=\"temp7.dat\"; endif; if(pid==12) then file=\"temp8.dat\"; endif; fp=exposcall(\"Open\", file); head=null; counter=0; a=exposcall(\"Read\", fp, word); while(counter<64) do p=alloc(); p.data=word; p.next=null; if(head==null) then head=p; q=p; else q.next=p; q=q.next; endif; a=exposcall(\"Read\", fp, word); counter=counter+1; endwhile; head=mergeSort(head); x=exposcall(\"Seek\", fp, 0); p=head; while(p!=null) do word=p.data; x=exposcall(\"Write\", fp, word); p=p.next; endwhile; x=exposcall(\"Close\", fp); x=exposcall(\"Semrelease\"); pid=exposcall(\"Getpid\"); x=pid+1; while(x<13) do a=exposcall(\"Wait\",x); x=x+1; endwhile; return 1; end }","title":"m_sort.expl"},{"location":"test-programs/test-program-16/#m_mergeexpl","text":"decl int merge(str out, str in1, str in2); enddecl int merge(str out, str in1, str in2) { decl int fp, fp1, fp2; int x, a, b, w1, w2; enddecl begin x=exposcall(\"Create\", out, 1); fp=exposcall(\"Open\", out); fp1=exposcall(\"Open\", in1); fp2=exposcall(\"Open\", in2); a=exposcall(\"Read\", fp1, w1); b=exposcall(\"Read\", fp2, w2); while(a!=-2 AND b!=-2) do if(w1<=w2) then x=exposcall(\"Write\", fp, w1); a=exposcall(\"Read\", fp1, w1); else x=exposcall(\"Write\", fp, w2); b=exposcall(\"Read\", fp2, w2); endif; endwhile; while(a!=-2) do x=exposcall(\"Write\", fp, w1); a=exposcall(\"Read\", fp1, w1); endwhile; while(b!=-2) do x=exposcall(\"Write\", fp, w2); b=exposcall(\"Read\", fp2, w2); endwhile; x=exposcall(\"Close\", fp); x=exposcall(\"Close\", fp1); x=exposcall(\"Close\", fp2); x=exposcall(\"Delete\", in1); x=exposcall(\"Delete\", in2); return 0; end } int main() { decl int x, pid, pid1, pid2; enddecl begin x=initialize(); pid1=exposcall(\"Fork\"); if(pid1!=0) then pid2=exposcall(\"Fork\"); if(pid2!=0) then x=merge(\"temp12.dat\", \"temp1.dat\", \"temp2.dat\"); x=exposcall(\"Wait\", pid2); else x=merge(\"temp34.dat\", \"temp3.dat\", \"temp4.dat\"); x=exposcall(\"Exit\"); endif; x=merge(\"temp14.dat\", \"temp12.dat\", \"temp34.dat\"); x=exposcall(\"Wait\", pid1); else pid2=exposcall(\"Fork\"); if(pid2!=0) then x=merge(\"temp56.dat\", \"temp5.dat\", \"temp6.dat\"); x=exposcall(\"Wait\", pid2); else x=merge(\"temp78.dat\", \"temp7.dat\", \"temp8.dat\"); x=exposcall(\"Exit\"); endif; x=merge(\"temp58.dat\", \"temp56.dat\", \"temp78.dat\"); x=exposcall(\"Exit\"); endif; x=merge(\"merge.dat\", \"temp14.dat\", \"temp58.dat\"); write(\"Merged\"); return 1; end }","title":"m_merge.expl"},{"location":"tutorials/","text":"XSM Instruction Execution Cycle XSM Interrupts and Exception Handling XSM Unprivileged Mode Execution FileSystem Implementation Multiuser Implementation Process Management Implementation","title":"XSM Tutorials"},{"location":"tutorials/filesystem-implementation/","text":"Prerequisites It is necessary to read the following documentations before starting with this tutorial. User level view of eXpFS file system . Program level interface to different file system calls. Read about file permissions . To implement the file system, one needs to understand the file system data structures that the OS maintains. One should also understand how various file system routines of the OS access and update these data structures. Disk Data structures \u00b6 There are two categories of file data structures. The first category consists of data that remains in the disk even when the machine is shut down (disk data structures\u200b). These are described first: 1. Disk blocks and Disk Free List \u00b6 The\u200b \u200bdata of a file is stored in disk blocks. A file may have up to 4 blocks of data. The OS provides the user with an interface where the user feels that the file is sequentially stored although the actual allocation could be in non-contiguous disk blocks. The Inode table entry (described next) for a file stores the block numbers of the disk blocks which contain the file data. The \u200b disk free list \u200b is a global disk data structure that indicates which disk blocks are allocated and which disk blocks are free. Disk blocks are allocated for a file by the Write \u200bsystem call . When a user program issues a write request, the system call allocates new blocks whenever necessary. (In more detail, the \u200b Write \u200bsystem call routine invokes the \u200b Get Free Block \u200bfunction of the \u200b Memory Manager Module to allocate a disk block.) Disk blocks associated with a file are de-allocated when the file is removed from the file system by the \u200b Delete \u200bsystem call (by invoking the \u200b Release Block \u200bfunction of the \u200b Memory Manager Module .) Whenever blocks are allocated/released, the disk free list is also updated to indicate the allocation status. The following disk data structures contain \u200b meta-data \u200bcorresponding to each file in the system. Inode table\u200b \u200band the root file are data structures of this kind. 2. Inode Table \u00b6 Inode table is a global data structure that contains an entry for each file stored in the file system. When a file is created using the \u200b Create \u200bsystem call or loaded into the disk using XFS-interface, a new Inode entry is created for the file. The inode entry of a file stores the following attributes of the file: 1) filename, 2) file size, 3) user-id of the owner of the file, 4) file type (data/executable/root), 5) file access permissions and 6) the block numbers of the disk blocks allocated to a file (maximum four blocks). When a file is created by the \u200b Create \u200bsystem call, no disk blocks are allocated for the file, and only an Inode entry is created. Hence the file size will be set to 0 initially. Filename and access permissions are supplied as arguments to \u200b Create \u200bsystem call and are set accordingly. eXpOS allows only data files to be created using \u200b Create \u200bsystem call. Hence, the file type of any file created using the Create system call will be set to DATA. (Executable files can only be externally loaded into the file system using \u200b xfs-interface). The user-id of the process executing Create \u200bsystem call will set as the owner of the file. (The user-id of a process is the user-id of the user logged into the system currently. eXpOS is a \u200b single terminal system .\u200b Only one user can login into the system at a time and run user processes). As noted previously, as data is written into the file by the \u200b Write \u200bsystem call, new disk blocks may be allocated. Whenever a block is allocated for a file, the block number is recorded in the Inode table. A file can be created with \u200b Exclusive Access / Open Access permission. The access permission is given as an argument to \u200b Create \u200b system call. If a file is created with exclusive access, the \u200b Delete and \u200b Write \u200b system calls must fail if executed by any process whose user-id is not equal to root, or the owner of the file. In other words, other users except the root shall not be permitted to modify or delete such files. When a file has open access permission, all users are allowed to perform any operation on the file. 3. Root File \u00b6 The root file stores human readable information about each file in the file system. The eXpFS file system does not support a hierarchical directory structure and all files are listed at a single level. Each file has an entry in the \u200b root file . The kth entry in the root file corresponds to the file whose index in the Inode table is k. The root file entry for a file contains filename, file size, file-type, user-name and access permissions. Thus, part of the the data in the Inode table is duplicated in the root file. The reason for this duplication is that root file is designed to be readable by user programs using the \u200b Read \u200bsystem call (unlike the inode table, which is accessed exclusively by OS routines only). An application readable root file allows implementation of commands like \u201cls\u201d (see Unix command \u201cls\u201d ) as user mode programs. Write \u200band \u200b Delete system calls are not permitted on the root file. The only data in the root file entry of a file that is not present in the inode table is the user name of the owner of the file. The inode table entry of a file contains a user-id of the owner. The user-id value can be used to index into the user table (described below) to find the username corresponding to the user-id. When a file is created, the Create system call must initialize the root file entries of the file along with the Inode table entries. Similarly, when the file size is changed in the Inode table by a write to the file (in the \u200b Write \u200b system call), the file size value in the root file also needs to be updated. 4. User Table \u00b6 User table contains the names of each user who has an account in the system. Though user table is not a data structure associated with the file system, one needs to understand a little bit about this data structure for the file system implementation. The details of how and when user table entries are created are not relevant to the file system implementation. For the present purpose, it suffices to understand that each user has an entry in the user table. The entry for a user in the user table consists of a) username and b) encrypted password. The OS assigns a \u200b user-id \u200b to each user. \u200b The user-id of a user is the index of the user\u2019s entry in the user table.\u200b The first two entries of the table (corresponding to user-id 0 and 1) are reserved for special users \u200b kernel and\u200b root \u200b. When a process executes the \u200b Create \u200b system call to create a file, \u200b Create system call looks up the process table entry of the calling process to find the user-id of the process executing \u200b Create and sets the user-id field in the Inode table. The system call then looks up the user table entry corresponding to the user-id and finds out the username and sets the user name field in the root file entry created for the file. Transient data structures \u00b6 The second category of data structures are transient - they are \"alive\" only when the OS is running (in-memory data structures). These data structures are described below: When the OS is running, user processes can Open/Read/Write an already created file. \u200b When a file is opened by a process using the \u200b Open system call, a new \u201copen instance\u201d is created. The OS keeps track of the number of open instances of a file at all times. If a file is opened multiple times (by the same or a different process), each \u200b Open \u200b call results in creation of a fresh open instance. Associated with each open instance\u200b \u200bof a file, there is a \u200b seek pointer \u200b, which is initialized to the beginning of the file (value 0) by the \u200b Open \u200b system call. Whenever the file is read from/written into, the update is done to the position in the file corresponding to the seek value, and the seek value is incremented. \u200b If a process opens a file and subsequently invokes the \u200b Fork system call, the seek pointer is shared between the parent and the child. Hence, subsequent to the fork, if either the parent or the child executes \u200b Read / Write \u200b system call on the open instance, their common shared seek pointer advances. Finally, the (shared) seek pointer value can be modified (by either process) using the \u200b Seek system call. This is the mechanism through which the OS allows multiple processes to share access to a file. Suppose a process closes an open instance using the \u200b Close \u200b system call, the \u200b Close \u200b system call first checks whether the open instance is shared by other (child/parent/sibling) processes. In that case, the OS simply decrements the \u201cshare count\u201d of the open instance. If the last process that shared an open instance closes the file, then the share count reaches zero and the open instance is closed. To implement this somewhat intricate file access and sharing mechanism, the OS maintains two global file data structures - the \u200b file status table \u200b (also called the inode status table), and the open file table \u200b. Moreover, for each process the OS maintains a \u200b per-process resource table\u200b , which contains information pertaining to the open instances of files of the particular process. The OS further maintains a \u200b buffer cache\u200b which is used for caching data blocks of files in current use. A \u200b buffer table \u200b is used to manage the data related to the buffer cache. These data structures are described below. Read the description of open file table and file status table before reading further. 1. File (Inode) Status Table \u00b6 File (Inode) status table contains an entry for each file in the file system. The index of a file\u2019s Inode table entry and file status table entry will be the same. That is, if a file\u2019s entry occurs - say - 10th in the inode table, its entry in the file (inode) status table will be the 10th one as well. The purpose of the table is two-fold 1) To keep track of how many times each file has been opened using the \u200b open \u200b system call. 2) To provide a mechanism for processes to \u200b lock a file before making updates to the file\u2019s data/metadata. Every time a file is opened by (any) process using the \u200b Open \u200b system call, the \u200b file open count field in the corresponding file status table entry is incremented. Thus, the table gives the global count of the number of open instances of a file. Second, when a process enters a file system call and tries to access a file, the system call code must first lock access to the file to ensure that till the system call is completed, no other process is allowed to execute any file system call that accesses the file\u2019s data/metadata. This is necessary to ensure safety under concurrent execution. The system call locks the file by setting locking-PID field of the file status table to the PID of the process executing the system call. Upon completion of the system call, the system call code must unlock the file before returning to user mode. The \u200b Acquire Inode and Release Inode \u200bfunctions of the \u200b Resource Manager Module are designed to handle file access regulation (locking). The SPL constant FILE_STATUS_TABLE is set to the beginning address of the file status table in memory (see memory organization ). 2. Open File Table \u00b6 As noted earlier, If a process opens a file using the \u200b Open \u200b system call and subsequently execute a \u200b Fork \u200b system call, the open instance of the file is shared between the parent and the child. If the child (or the parent) further execute \u200b fork , more processes will share the same open instance. Hence, there must be a mechanism to keep track of the count of processes sharing the same open instance of a file. Open file table is the data structure which keeps track of this count. Whenever a file is opened by a process, an open file table entry is created for the open instance. The entry contains three fields: a)\u200b The index of the inode table of the file. b\u200b) The count of the number of processes sharing the open instance, which will be set to 1 when the file is opened as only one process is sharing the open instance. When the process executes a \u200b Fork \u200b system call, the share count is incremented to reflect the correct number of processes sharing the open instance. (Note: Do not confuse this count with the file open count in the file status table.) c)\u200b The seek pointer for the open instance is stored in the open file table. Any read/write operation on this open instance must read from / write into this position of the file and advance the pointer. When a file is opened, the seek position is set to 0. Note that the seek pointer is shared between all processes sharing the open instance. The SPL constant OPEN_FILE_TABLE is set to the beginning address of the open file table in memory (see memory organization ). When a process executes a \u200b Read / Write \u200b system call on an open instance, the system call handler, along with the data read/write operation on the file, advances the seek pointer in the open file table entry corresponding to the open instance. 3. Per-Process Resource Table \u00b6 When a process opens a file, a new entry is created for the open instance in the per process resource table of the process. This entry contains two fields: a)\u200b A flag indicating whether the entry corresponds to a file or a semaphore. b)\u200b Index of the open file table /semaphore table entry of the open file / semaphore instance. Here we will be concerned only about the case when the entry corresponds to an open file. The \u200b Open system call returns the index of an entry in the resource table as the file descriptor to the user. Any \u200b Read / Write / Seek / Close \u200b system call on the open instance of a file must be given this file descriptor as the argument. \u200b Read / Write / Seek / Close \u200b system calls use the descriptor value passed as argument to identify the open instance (determined uniquely by the open file table index associated with the file descriptor). When a process forks a child, Fork system call copies the entries of the resource table of the parent to the resource table of the child. Thus, the child inherits the open instances of files from the parent. As an example, consider the following scenario. Let process B be a child of process A. Assume that an open instance of a file by name myfile.dat be shared by A and B. Suppose the inode index of myfile.dat is 5. Assume that the open file table index for the open instance is - say 2. The following figure shows the various table entries for the open instance. File data structures entries in the above scenario In addition to the above data structures, the OS maintains the following global data structures: 4.\u200b \u200b Memory buffer Cache \u00b6 Whenever a process tries to \u200b Read / Write \u200b into a file, the relevant block of the file is first brought into a disk buffer in memory and the read/write is performed on the copy of the block stored in the buffer. The OS maintains 4 memory buffer pages as cache (and will be numbered 0,1,2,3. The buffers are in memory pages 71, 72, 73, 74 - see memory organization ). A simple buffering scheme will be used here. When there is a request for the ith disk block, it will be brought to the buffer with number ( i mod 4 ). If the buffer is presently containing another disk block, then the OS must check whether the disk block needs a write-back (dirty) before loading the requested block. This will be described soon. 5.\u200b \u200b Buffer Table \u00b6 The buffer table is used for managing the buffer cache. The table contains one entry per each buffer page. The entry for a buffer contains: a) \u200bThe block number of the disk block currently stored in the buffer page. If the buffer is unallocated, the disk block number is set to -1. b\u200b) A flag indicating whether the block was modified after loading (dirty). c) \u200bThe PID of the process that has locked the buffer page. (-1 if no process has locked the buffer.) The locking PID field requires some explanation. When a process tries to do read/write into certain data block of a file using \u200b Read / Write system call, the system call must first determine the buffer number to which the block must be loaded (using the formula indicated above) and lock the buffer before initiating disk to buffer data transfer. This is to prevent other processes from concurrently trying to load other blocks into the same buffer page. To understand the dynamics of how file system calls operate with the above data structures, let us consider an example. Suppose a process executes a \u200b Write \u200b into the open instance of a file. The Write system call uses the file descriptor (received as input argument) to find the index of the open file table entry corresponding to the descriptor. From the open file table entry, \u200b Write gets the seek pointer (using open file table) and index of the the inode table entry for the file. Next it locks the Inode (using \u200b Acquire Inode \u200b function of the \u200b Resource Manager Module ). It then determines the disk block to which data must be written (using the seek position and the Inode table entry of the file). Now, Write invokes the \u200b Buffered Write function of \u200b File Manager Module to perform the write. Buffered Write first calculates the buffer number corresponding to the block number and locks the buffer (invoking the \u200b Acquire Buffer \u200b function of the \u200b Resource Manager Module ). It then checks whether the disk block to be written into is already present in the buffer. If not, the disk block has to be loaded first into the buffer. However, if the buffer is currently containing another disk block and if the disk block is dirty, then the disk block must be written back first. The buffer table entry for the buffer will help \u200b Buffered Write to determine whether the buffer is free, or if not free whether write back is required. Write Back is performed using the \u200b Disk Store function of the \u200b Device Manager Module . (\u200b Disk Store function makes another resource lock - calls the \u200b Acquire Disk function of the \u200b Resource Manager Module before disk commit is done). Finally, after getting the buffer page free for use, \u200b Buffered Write \u200b brings the required disk block into the buffer page using the \u200b Disk Load function of the \u200b Device Manager Module . Now Buffered Write can write the data into the buffer. Since the contents of the block has been modified, Buffered Write sets the \u200b dirty bit \u200b in the buffer table entry for the buffer. Note that Write \u200b does not\u200b \u200bstore the modified buffer back to the disk. The modifications are committed only when a subsequent write operation requires the buffer to be loaded with a different disk block. The OS also commits back all dirty buffers to the disk before shutdown. A \u200b Read operation is similar, except that the \u200b dirty bit is not set \u200b as the page is not modified. The execution of \u200b Read / Write \u200b system calls involves a sequence of resource acquisitions - namely inode, buffer and disk. The resources are acquired in the order Inode-buffer-disk and must be released in the reverse order when the actions are completed. This avoids circular wait - a sufficient condition for deadlock prevention. 6.\u200b In-Memory Copy of Disk data structures \u00b6 Finally, the OS maintains an in-memory copy of all the disk data structures - viz., inode table, user table, root file and the disk free list. While the OS is running, a new user could be created or a file could be created/modified/deleted. In such cases, the update is made into the memory copy of the corresponding data structures and not the disk copy. The OS must write back the memory copy of all disk data structures and all dirty buffers to the disk before the system is shutdown. The file system implementation described here is \u200b not crash resilient \u200b. This means, if the OS crashes before (or during) such write back, the memory-copy to disk updates may be partial and the disk data structures may end up in inconsistent state. In such case, one or more files may be corrupted and the disk may require reformatting.","title":"FileSystem Implementation"},{"location":"tutorials/filesystem-implementation/#disk-data-structures","text":"There are two categories of file data structures. The first category consists of data that remains in the disk even when the machine is shut down (disk data structures\u200b). These are described first:","title":"Disk Data structures"},{"location":"tutorials/filesystem-implementation/#1-disk-blocks-and-disk-free-list","text":"The\u200b \u200bdata of a file is stored in disk blocks. A file may have up to 4 blocks of data. The OS provides the user with an interface where the user feels that the file is sequentially stored although the actual allocation could be in non-contiguous disk blocks. The Inode table entry (described next) for a file stores the block numbers of the disk blocks which contain the file data. The \u200b disk free list \u200b is a global disk data structure that indicates which disk blocks are allocated and which disk blocks are free. Disk blocks are allocated for a file by the Write \u200bsystem call . When a user program issues a write request, the system call allocates new blocks whenever necessary. (In more detail, the \u200b Write \u200bsystem call routine invokes the \u200b Get Free Block \u200bfunction of the \u200b Memory Manager Module to allocate a disk block.) Disk blocks associated with a file are de-allocated when the file is removed from the file system by the \u200b Delete \u200bsystem call (by invoking the \u200b Release Block \u200bfunction of the \u200b Memory Manager Module .) Whenever blocks are allocated/released, the disk free list is also updated to indicate the allocation status. The following disk data structures contain \u200b meta-data \u200bcorresponding to each file in the system. Inode table\u200b \u200band the root file are data structures of this kind.","title":"1. Disk blocks and Disk Free List"},{"location":"tutorials/filesystem-implementation/#2-inode-table","text":"Inode table is a global data structure that contains an entry for each file stored in the file system. When a file is created using the \u200b Create \u200bsystem call or loaded into the disk using XFS-interface, a new Inode entry is created for the file. The inode entry of a file stores the following attributes of the file: 1) filename, 2) file size, 3) user-id of the owner of the file, 4) file type (data/executable/root), 5) file access permissions and 6) the block numbers of the disk blocks allocated to a file (maximum four blocks). When a file is created by the \u200b Create \u200bsystem call, no disk blocks are allocated for the file, and only an Inode entry is created. Hence the file size will be set to 0 initially. Filename and access permissions are supplied as arguments to \u200b Create \u200bsystem call and are set accordingly. eXpOS allows only data files to be created using \u200b Create \u200bsystem call. Hence, the file type of any file created using the Create system call will be set to DATA. (Executable files can only be externally loaded into the file system using \u200b xfs-interface). The user-id of the process executing Create \u200bsystem call will set as the owner of the file. (The user-id of a process is the user-id of the user logged into the system currently. eXpOS is a \u200b single terminal system .\u200b Only one user can login into the system at a time and run user processes). As noted previously, as data is written into the file by the \u200b Write \u200bsystem call, new disk blocks may be allocated. Whenever a block is allocated for a file, the block number is recorded in the Inode table. A file can be created with \u200b Exclusive Access / Open Access permission. The access permission is given as an argument to \u200b Create \u200b system call. If a file is created with exclusive access, the \u200b Delete and \u200b Write \u200b system calls must fail if executed by any process whose user-id is not equal to root, or the owner of the file. In other words, other users except the root shall not be permitted to modify or delete such files. When a file has open access permission, all users are allowed to perform any operation on the file.","title":"2. Inode Table"},{"location":"tutorials/filesystem-implementation/#3-root-file","text":"The root file stores human readable information about each file in the file system. The eXpFS file system does not support a hierarchical directory structure and all files are listed at a single level. Each file has an entry in the \u200b root file . The kth entry in the root file corresponds to the file whose index in the Inode table is k. The root file entry for a file contains filename, file size, file-type, user-name and access permissions. Thus, part of the the data in the Inode table is duplicated in the root file. The reason for this duplication is that root file is designed to be readable by user programs using the \u200b Read \u200bsystem call (unlike the inode table, which is accessed exclusively by OS routines only). An application readable root file allows implementation of commands like \u201cls\u201d (see Unix command \u201cls\u201d ) as user mode programs. Write \u200band \u200b Delete system calls are not permitted on the root file. The only data in the root file entry of a file that is not present in the inode table is the user name of the owner of the file. The inode table entry of a file contains a user-id of the owner. The user-id value can be used to index into the user table (described below) to find the username corresponding to the user-id. When a file is created, the Create system call must initialize the root file entries of the file along with the Inode table entries. Similarly, when the file size is changed in the Inode table by a write to the file (in the \u200b Write \u200b system call), the file size value in the root file also needs to be updated.","title":"3. Root File"},{"location":"tutorials/filesystem-implementation/#4-user-table","text":"User table contains the names of each user who has an account in the system. Though user table is not a data structure associated with the file system, one needs to understand a little bit about this data structure for the file system implementation. The details of how and when user table entries are created are not relevant to the file system implementation. For the present purpose, it suffices to understand that each user has an entry in the user table. The entry for a user in the user table consists of a) username and b) encrypted password. The OS assigns a \u200b user-id \u200b to each user. \u200b The user-id of a user is the index of the user\u2019s entry in the user table.\u200b The first two entries of the table (corresponding to user-id 0 and 1) are reserved for special users \u200b kernel and\u200b root \u200b. When a process executes the \u200b Create \u200b system call to create a file, \u200b Create system call looks up the process table entry of the calling process to find the user-id of the process executing \u200b Create and sets the user-id field in the Inode table. The system call then looks up the user table entry corresponding to the user-id and finds out the username and sets the user name field in the root file entry created for the file.","title":"4. User Table"},{"location":"tutorials/filesystem-implementation/#transient-data-structures","text":"The second category of data structures are transient - they are \"alive\" only when the OS is running (in-memory data structures). These data structures are described below: When the OS is running, user processes can Open/Read/Write an already created file. \u200b When a file is opened by a process using the \u200b Open system call, a new \u201copen instance\u201d is created. The OS keeps track of the number of open instances of a file at all times. If a file is opened multiple times (by the same or a different process), each \u200b Open \u200b call results in creation of a fresh open instance. Associated with each open instance\u200b \u200bof a file, there is a \u200b seek pointer \u200b, which is initialized to the beginning of the file (value 0) by the \u200b Open \u200b system call. Whenever the file is read from/written into, the update is done to the position in the file corresponding to the seek value, and the seek value is incremented. \u200b If a process opens a file and subsequently invokes the \u200b Fork system call, the seek pointer is shared between the parent and the child. Hence, subsequent to the fork, if either the parent or the child executes \u200b Read / Write \u200b system call on the open instance, their common shared seek pointer advances. Finally, the (shared) seek pointer value can be modified (by either process) using the \u200b Seek system call. This is the mechanism through which the OS allows multiple processes to share access to a file. Suppose a process closes an open instance using the \u200b Close \u200b system call, the \u200b Close \u200b system call first checks whether the open instance is shared by other (child/parent/sibling) processes. In that case, the OS simply decrements the \u201cshare count\u201d of the open instance. If the last process that shared an open instance closes the file, then the share count reaches zero and the open instance is closed. To implement this somewhat intricate file access and sharing mechanism, the OS maintains two global file data structures - the \u200b file status table \u200b (also called the inode status table), and the open file table \u200b. Moreover, for each process the OS maintains a \u200b per-process resource table\u200b , which contains information pertaining to the open instances of files of the particular process. The OS further maintains a \u200b buffer cache\u200b which is used for caching data blocks of files in current use. A \u200b buffer table \u200b is used to manage the data related to the buffer cache. These data structures are described below. Read the description of open file table and file status table before reading further.","title":"Transient data structures"},{"location":"tutorials/filesystem-implementation/#1-file-inode-status-table","text":"File (Inode) status table contains an entry for each file in the file system. The index of a file\u2019s Inode table entry and file status table entry will be the same. That is, if a file\u2019s entry occurs - say - 10th in the inode table, its entry in the file (inode) status table will be the 10th one as well. The purpose of the table is two-fold 1) To keep track of how many times each file has been opened using the \u200b open \u200b system call. 2) To provide a mechanism for processes to \u200b lock a file before making updates to the file\u2019s data/metadata. Every time a file is opened by (any) process using the \u200b Open \u200b system call, the \u200b file open count field in the corresponding file status table entry is incremented. Thus, the table gives the global count of the number of open instances of a file. Second, when a process enters a file system call and tries to access a file, the system call code must first lock access to the file to ensure that till the system call is completed, no other process is allowed to execute any file system call that accesses the file\u2019s data/metadata. This is necessary to ensure safety under concurrent execution. The system call locks the file by setting locking-PID field of the file status table to the PID of the process executing the system call. Upon completion of the system call, the system call code must unlock the file before returning to user mode. The \u200b Acquire Inode and Release Inode \u200bfunctions of the \u200b Resource Manager Module are designed to handle file access regulation (locking). The SPL constant FILE_STATUS_TABLE is set to the beginning address of the file status table in memory (see memory organization ).","title":"1. File (Inode) Status Table"},{"location":"tutorials/filesystem-implementation/#2-open-file-table","text":"As noted earlier, If a process opens a file using the \u200b Open \u200b system call and subsequently execute a \u200b Fork \u200b system call, the open instance of the file is shared between the parent and the child. If the child (or the parent) further execute \u200b fork , more processes will share the same open instance. Hence, there must be a mechanism to keep track of the count of processes sharing the same open instance of a file. Open file table is the data structure which keeps track of this count. Whenever a file is opened by a process, an open file table entry is created for the open instance. The entry contains three fields: a)\u200b The index of the inode table of the file. b\u200b) The count of the number of processes sharing the open instance, which will be set to 1 when the file is opened as only one process is sharing the open instance. When the process executes a \u200b Fork \u200b system call, the share count is incremented to reflect the correct number of processes sharing the open instance. (Note: Do not confuse this count with the file open count in the file status table.) c)\u200b The seek pointer for the open instance is stored in the open file table. Any read/write operation on this open instance must read from / write into this position of the file and advance the pointer. When a file is opened, the seek position is set to 0. Note that the seek pointer is shared between all processes sharing the open instance. The SPL constant OPEN_FILE_TABLE is set to the beginning address of the open file table in memory (see memory organization ). When a process executes a \u200b Read / Write \u200b system call on an open instance, the system call handler, along with the data read/write operation on the file, advances the seek pointer in the open file table entry corresponding to the open instance.","title":"2. Open File Table"},{"location":"tutorials/filesystem-implementation/#3-per-process-resource-table","text":"When a process opens a file, a new entry is created for the open instance in the per process resource table of the process. This entry contains two fields: a)\u200b A flag indicating whether the entry corresponds to a file or a semaphore. b)\u200b Index of the open file table /semaphore table entry of the open file / semaphore instance. Here we will be concerned only about the case when the entry corresponds to an open file. The \u200b Open system call returns the index of an entry in the resource table as the file descriptor to the user. Any \u200b Read / Write / Seek / Close \u200b system call on the open instance of a file must be given this file descriptor as the argument. \u200b Read / Write / Seek / Close \u200b system calls use the descriptor value passed as argument to identify the open instance (determined uniquely by the open file table index associated with the file descriptor). When a process forks a child, Fork system call copies the entries of the resource table of the parent to the resource table of the child. Thus, the child inherits the open instances of files from the parent. As an example, consider the following scenario. Let process B be a child of process A. Assume that an open instance of a file by name myfile.dat be shared by A and B. Suppose the inode index of myfile.dat is 5. Assume that the open file table index for the open instance is - say 2. The following figure shows the various table entries for the open instance. File data structures entries in the above scenario In addition to the above data structures, the OS maintains the following global data structures:","title":"3. Per-Process Resource Table"},{"location":"tutorials/filesystem-implementation/#4-memory-buffer-cache","text":"Whenever a process tries to \u200b Read / Write \u200b into a file, the relevant block of the file is first brought into a disk buffer in memory and the read/write is performed on the copy of the block stored in the buffer. The OS maintains 4 memory buffer pages as cache (and will be numbered 0,1,2,3. The buffers are in memory pages 71, 72, 73, 74 - see memory organization ). A simple buffering scheme will be used here. When there is a request for the ith disk block, it will be brought to the buffer with number ( i mod 4 ). If the buffer is presently containing another disk block, then the OS must check whether the disk block needs a write-back (dirty) before loading the requested block. This will be described soon.","title":"4.\u200b \u200b Memory buffer Cache"},{"location":"tutorials/filesystem-implementation/#5-buffer-table","text":"The buffer table is used for managing the buffer cache. The table contains one entry per each buffer page. The entry for a buffer contains: a) \u200bThe block number of the disk block currently stored in the buffer page. If the buffer is unallocated, the disk block number is set to -1. b\u200b) A flag indicating whether the block was modified after loading (dirty). c) \u200bThe PID of the process that has locked the buffer page. (-1 if no process has locked the buffer.) The locking PID field requires some explanation. When a process tries to do read/write into certain data block of a file using \u200b Read / Write system call, the system call must first determine the buffer number to which the block must be loaded (using the formula indicated above) and lock the buffer before initiating disk to buffer data transfer. This is to prevent other processes from concurrently trying to load other blocks into the same buffer page. To understand the dynamics of how file system calls operate with the above data structures, let us consider an example. Suppose a process executes a \u200b Write \u200b into the open instance of a file. The Write system call uses the file descriptor (received as input argument) to find the index of the open file table entry corresponding to the descriptor. From the open file table entry, \u200b Write gets the seek pointer (using open file table) and index of the the inode table entry for the file. Next it locks the Inode (using \u200b Acquire Inode \u200b function of the \u200b Resource Manager Module ). It then determines the disk block to which data must be written (using the seek position and the Inode table entry of the file). Now, Write invokes the \u200b Buffered Write function of \u200b File Manager Module to perform the write. Buffered Write first calculates the buffer number corresponding to the block number and locks the buffer (invoking the \u200b Acquire Buffer \u200b function of the \u200b Resource Manager Module ). It then checks whether the disk block to be written into is already present in the buffer. If not, the disk block has to be loaded first into the buffer. However, if the buffer is currently containing another disk block and if the disk block is dirty, then the disk block must be written back first. The buffer table entry for the buffer will help \u200b Buffered Write to determine whether the buffer is free, or if not free whether write back is required. Write Back is performed using the \u200b Disk Store function of the \u200b Device Manager Module . (\u200b Disk Store function makes another resource lock - calls the \u200b Acquire Disk function of the \u200b Resource Manager Module before disk commit is done). Finally, after getting the buffer page free for use, \u200b Buffered Write \u200b brings the required disk block into the buffer page using the \u200b Disk Load function of the \u200b Device Manager Module . Now Buffered Write can write the data into the buffer. Since the contents of the block has been modified, Buffered Write sets the \u200b dirty bit \u200b in the buffer table entry for the buffer. Note that Write \u200b does not\u200b \u200bstore the modified buffer back to the disk. The modifications are committed only when a subsequent write operation requires the buffer to be loaded with a different disk block. The OS also commits back all dirty buffers to the disk before shutdown. A \u200b Read operation is similar, except that the \u200b dirty bit is not set \u200b as the page is not modified. The execution of \u200b Read / Write \u200b system calls involves a sequence of resource acquisitions - namely inode, buffer and disk. The resources are acquired in the order Inode-buffer-disk and must be released in the reverse order when the actions are completed. This avoids circular wait - a sufficient condition for deadlock prevention.","title":"5.\u200b \u200b Buffer Table"},{"location":"tutorials/filesystem-implementation/#6-in-memory-copy-of-disk-data-structures","text":"Finally, the OS maintains an in-memory copy of all the disk data structures - viz., inode table, user table, root file and the disk free list. While the OS is running, a new user could be created or a file could be created/modified/deleted. In such cases, the update is made into the memory copy of the corresponding data structures and not the disk copy. The OS must write back the memory copy of all disk data structures and all dirty buffers to the disk before the system is shutdown. The file system implementation described here is \u200b not crash resilient \u200b. This means, if the OS crashes before (or during) such write back, the memory-copy to disk updates may be partial and the disk data structures may end up in inconsistent state. In such case, one or more files may be corrupted and the disk may require reformatting.","title":"6.\u200b In-Memory Copy of Disk data structures"},{"location":"tutorials/multiuser-implementation/","text":"Prerequisites It is necessary to read the following documentations before starting with this tutorial. User level specification of eXpOS multi-user model . Multi-user system call specification . Specification of Shell commands and system utilities . eXpOS implements a very primitive support for multiple users to login into the system. eXpOS supports only one terminal. Hence, only one user is permitted to login into the system at one time and another user can login only after the current user logs out. The OS permits only a maximum of 16 users to be created. Of these 16, two are default users - the kernel and the root . The OS maintains a single disk data structure, the user table - for storing information pertaining to the users in the system. The user table contains 16 entries. Each entry contains just two fields - a username and an encrypted password . The OS maintains one entry per user. The OS also assigns a user-id to each user. The user-id of a user is the index of the user\u2019s entry in the user table. (Hence there is no field for storing the user-id of a user in the user table.) Thus, the first entry in the user table corresponds to user-id = 0, the next user has userid = 1 and so on. The user table is stored in 32 words of disk block 4 in the disk. Note that the user table appears at the end of the Inode table in the disk. (See disk organization ). eXpOS assumes that the machine provides some kind of password encryption mechanism. The XSM machine provides the ENCRYPT to convert a text password to encrypted form. (The SPL instruction encrypt gets translated to the above machine instruction). When the xfs-disk is formatted using the FDISK command of the XFS-interface, the user table is initialized with valid entries for the two default users - kernel and the root. The first two entries of the user table are assigned to kernel and root. Consequently, the user-id of kernel is 0 and the user-id of root is 1. All other entries are initialized to -1 (invalid entry). Among the two default users, kernel is a non-loggable user . Hence, kernel has no password set initially by FDISK. The root user is assigned a default password \u201croot\u201d (without quotes) by FDISK. This means that the encrypted form of the string \u201croot\u201d (without quotes) is stored in the user table entry corresponding to root. To understand the dynamics of user management, we need to look at the steps taken by the OS during startup. At the time of OS startup, the OS loads the disk block containing the user table into memory page 60 (see memory organization ). The OS startup code hand creates three processes - the idle process (PID=0), the INIT process (PID=1) and the SHELL process (PID=2). The INIT process of eXpOS is called the login process . The user-id of the idle process and the login process are set to 0 in their respective process table entries. Hence, both processes are treated as special \u201ckernel processes\u201d. The user-id of the shell process will be set to the user who has logged into the system. Login and Shell Processes \u00b6 The login process executes a loop and asks the user to enter a login name and (unencrypted) text password . The login process supplies these arguments to the Login system call. Login system call checks whether there is an entry in the user table corresponding to the login name given. If so, it encrypts the text password given as argument (using the ENCRYPT instruction) and matches the result with the encrypted password stored in the user table entry of the user. If either check fails, then Login system call returns an error code. In this case, the login process announces \u201clogin failure\u201d and continues to ask for another username and password. Note that the first user to login after running FDISK must be the root user with the password \u201croot\u201d (without quotes). If the username and password matches a user, the Login system call sets the shell program ready for execution. The shell program\u2019s code is pre-loaded into the memory. The stack pages are allocated for the shell process and page table entries for PID=2 are set to these values during boot time. Hence, the effective work of Login is to just set the process ready to run. The shell process is assigned user-id of the logged in user and its Parent PID is set to the PID of the login process. Hence, the shell process runs the shell in the context of the logged in user . Consequently, any other program executed by the shell will also execute in the context of the same user as the Fork system call copies the user-id of the parent to the child. The login process has done its work for the time being, and will go into sleep waiting for the exit of the shell process spawned for the user (essentially doing the work of Wait system call as well internally). After waking up (which can happen only when the shell executes the Logout system call), Login process resumes execution by asking for the username and password of the next user. Note that login runs in an infinite loop and never terminates. The shell is always executed with PID = 2. Once the shell process starts execution from the context of a user, system calls for process management, file management, interprocess communication and process synchronization work in the normal way. As the shell program is a special system program supplied by the OS designer, by design, it never executes the Exit system call. The only way in which the shell can wake up the login process is to execute the Logout system call. The shell executes the Logout system call when the user enters the shell command \u201clogout\u201d. Logout system call terminates all processes of the current user (including the shell) and wakes up the login process so that the next user may be logged in. Hence Logout system call, in effect, does the work of the Exit system call on all currently active processes of the currently logged in user. eXpOS specification stipulates that the Logout system call can be executed only by the shell process (PID = 2). Multi-user system calls \u00b6 eXpOS system calls for user management are: Newusr - to create a new user Remusr - to remove a user Setpwd - set the password of a user Getuid - to get the user-id of the currently logged in user Getuname - to get the username of the currently logged in user Login - to login a user Logout - logout the current user Shutdown - to shutdown the system after committing the memory copies of all disk data structures into the disk Among these, Newusr , Remusr and Shutdown can be executed from the shell of the root user only and Setpwd and Logout can be executed from the shell process of any user . Only the root user is permitted to change the password of other users using the Setpwd system call. (See specification .) The security model guaranteed to the user by the above scheme is the following. A user may run any eXpFS executable program using the shell, and the program will be to access any file which the user has access to. The program can also spawn more processes, all running with permissions allowed for the logged in user. The program cannot delete or write into files which the user does not have write permission. The program is also not allowed to do things that \u201charm the user\u2019s account\u201d - like changing the user\u2019s password etc., or tamper with the accounts of other users. The only way for a user to change one\u2019s password is to do so using the shell. One user cannot change the password of others. A normal user can log out of the system using the shell, but cannot shut down the system. The system administrator, root , can run programs that access, modify or delete the files of any user. The root can also use the shell to delete a user\u2019s account. (Note: The Remusr system call requires that all files owned by a user must be deleted before the account can be deleted. This is necessary to ensure that the system is not left with \u201cabandoned\u201d files when a user\u2019s account is deleted). The root is permitted to change the password of any user. Root is the only user who is authorized to run the shell command to shutdown the system. Also see the specification of the eXpOS shell .","title":"MultiUser Implementation"},{"location":"tutorials/multiuser-implementation/#login-and-shell-processes","text":"The login process executes a loop and asks the user to enter a login name and (unencrypted) text password . The login process supplies these arguments to the Login system call. Login system call checks whether there is an entry in the user table corresponding to the login name given. If so, it encrypts the text password given as argument (using the ENCRYPT instruction) and matches the result with the encrypted password stored in the user table entry of the user. If either check fails, then Login system call returns an error code. In this case, the login process announces \u201clogin failure\u201d and continues to ask for another username and password. Note that the first user to login after running FDISK must be the root user with the password \u201croot\u201d (without quotes). If the username and password matches a user, the Login system call sets the shell program ready for execution. The shell program\u2019s code is pre-loaded into the memory. The stack pages are allocated for the shell process and page table entries for PID=2 are set to these values during boot time. Hence, the effective work of Login is to just set the process ready to run. The shell process is assigned user-id of the logged in user and its Parent PID is set to the PID of the login process. Hence, the shell process runs the shell in the context of the logged in user . Consequently, any other program executed by the shell will also execute in the context of the same user as the Fork system call copies the user-id of the parent to the child. The login process has done its work for the time being, and will go into sleep waiting for the exit of the shell process spawned for the user (essentially doing the work of Wait system call as well internally). After waking up (which can happen only when the shell executes the Logout system call), Login process resumes execution by asking for the username and password of the next user. Note that login runs in an infinite loop and never terminates. The shell is always executed with PID = 2. Once the shell process starts execution from the context of a user, system calls for process management, file management, interprocess communication and process synchronization work in the normal way. As the shell program is a special system program supplied by the OS designer, by design, it never executes the Exit system call. The only way in which the shell can wake up the login process is to execute the Logout system call. The shell executes the Logout system call when the user enters the shell command \u201clogout\u201d. Logout system call terminates all processes of the current user (including the shell) and wakes up the login process so that the next user may be logged in. Hence Logout system call, in effect, does the work of the Exit system call on all currently active processes of the currently logged in user. eXpOS specification stipulates that the Logout system call can be executed only by the shell process (PID = 2).","title":"Login and Shell Processes"},{"location":"tutorials/multiuser-implementation/#multi-user-system-calls","text":"eXpOS system calls for user management are: Newusr - to create a new user Remusr - to remove a user Setpwd - set the password of a user Getuid - to get the user-id of the currently logged in user Getuname - to get the username of the currently logged in user Login - to login a user Logout - logout the current user Shutdown - to shutdown the system after committing the memory copies of all disk data structures into the disk Among these, Newusr , Remusr and Shutdown can be executed from the shell of the root user only and Setpwd and Logout can be executed from the shell process of any user . Only the root user is permitted to change the password of other users using the Setpwd system call. (See specification .) The security model guaranteed to the user by the above scheme is the following. A user may run any eXpFS executable program using the shell, and the program will be to access any file which the user has access to. The program can also spawn more processes, all running with permissions allowed for the logged in user. The program cannot delete or write into files which the user does not have write permission. The program is also not allowed to do things that \u201charm the user\u2019s account\u201d - like changing the user\u2019s password etc., or tamper with the accounts of other users. The only way for a user to change one\u2019s password is to do so using the shell. One user cannot change the password of others. A normal user can log out of the system using the shell, but cannot shut down the system. The system administrator, root , can run programs that access, modify or delete the files of any user. The root can also use the shell to delete a user\u2019s account. (Note: The Remusr system call requires that all files owned by a user must be deleted before the account can be deleted. This is necessary to ensure that the system is not left with \u201cabandoned\u201d files when a user\u2019s account is deleted). The root is permitted to change the password of any user. Root is the only user who is authorized to run the shell command to shutdown the system. Also see the specification of the eXpOS shell .","title":"Multi-user system calls"},{"location":"tutorials/process-management-implementation/","text":"Prerequisites It is necessary to read the following documentations before starting with this tutorial. eXpOS process - user level specification . Program level interface to different process system calls eXpOS ABI . XSM unprivileged mode execution tutorial. When a program is loaded from the disk and executed by the \u200b Exec \u200b system call, the system call code loads the program into memory and sets up the \u200b address space \u200b for a process. A process in execution can spawn more processes using the \u200b Fork \u200b system call. A process is terminated using the \u200b Exit \u200b system call. This tutorial will focus on the data structures related to the implementation of these system calls. In order to manage processes, the OS needs to arrange memory for two categories of data: a)\u200b The space to store the process. Stated technically, the OS must allocate \u200b physical memory pages \u200b into which the logical address space of the process must be mapped into. The OS maintains a per-process page table \u200b for keeping track of the physical memory to logical memory mapping. The OS also allocates a \u200b user area page \u200b for each process to create space for a kernel stack for the process. (to be described below). b)\u200b The space to store \u200b metadata \u200b related to each process. The data structures for meta-data are 1. \u200b process table\u200b , 2.\u200b per-process resource tables \u200b and 3. \u200b Per-process disk map tables\u200b . (Strictly speaking, per-process page tables contain metadata, and should have been listed here, but the explanation is easier with the present ordering.) Before, getting to these data structures, we need to have a quick look into how an executable program is stored in the disk and how the OS maintains metadata of executable programs in the disk. The OS maintains in the disk a global data structure called \u200b Inode table \u200b in which each file in the disk has an entry. The only way in which an executable file can be loaded into the eXpFS disk is to load it externally using \u200b xfs-interface . Hence, the Inode table entry for an executable file is set when the file is loaded into the disk by xfs-interface \u200b to the following values. a)\u200b File type will be set to EXEC. b) Name of the file as given, c) Size of the file calculated from the content size c) User Id of the owner of the file \u2013 will be set to 0 (Kernal), d) File permissions \u2013 will not be set (eXpOS does not permit application programsto modify/delete executable files using OS system calls) e) Disk blocks into which xfs-interface places the contents of the file. The maximum number of blocks for an executable file is 4. The values of file size \u200b of the file and disk blocks containing the file are of relevance to process management. Now we describe how the OS manages processes in memory. Physical Memory \u00b6 An XEXE executable file will contain the \u200b code \u200b of the program (along with a small eight word \u200bheader\u200b in the beginning). As noted above, the size of an executable file is limited to maximum 4 disk blocks. Hence, to load the contents of an executable file into memory, the OS will need to allocate a maximum 4 pages of physical memory. To understand how memory allocation for a program is done, we look at the \u200b Exec system call .\u200b The \u200b Exec \u200b system call takes as argument an executable file\u2019s name and allocates memory for loading the executable file. It then loads the program into the allocated memory and sets it up for execution. When the loaded code is executed, the code will require more memory. Hence, each process is given a \u200b memory address space \u200b called the logical or virtual address space of the process. The eXpOS ABI stipulates that the address space of a process starts from logical address 0 and ends at logical address 5119 (10 pages \u2013 numbered logical page 0 to logical page 9 of the process.) Physical pages are allocated using \u200b GetFreePage \u200bfunction of the \u200b Memory Manager Module . The memory pages allocated to a process need not be contiguous. Hence, \u200b there must be a table for each process that describes the mapping of logical pages to physical pages .\u200b This table is called the \u200b per-process page table\u200b . The code of the executable program will contain reference to logical addresses, which has to be translated to physical addresses when the program is executed. This translation is done by the \u200b paging hardware\u200b of the XSM machine. This documentation assumes that the user is familiar with paging hardware (see XSM tutorial for more details). Hence, we will not describe page tables or the details of paging here. What is important here is the fact that the mapping of logical pages to physical pages is maintained in the per-process page table. The OS expects that the application program logically divides the 10 page logical address space of a process into four parts a) \u200b library \u200b (logical pages 0 and 1), b) \u200b heap (logical pages 2, 3), c) \u200b code \u200b (or sometimes called \u201ctext\u201d in OS jargon) (logical pages 4,5,6,7) and d) \u200b stack \u200b (logical pages 8,9). (These conventions are listed out in the ABI documentation and application programs (or program compilers) are expected to follow these regulations when preparing the executable file). The \u200b Exec system call uses the \u200b DiskLoad function of the \u200b Device Manager Module \u200b to load the contents of the executable file specified into logical pages 4,5,6 and 7. (That is, the disk blocks will be loaded to the physical pages corresponding to these logical pages). Logical pages 0 and 1 are mapped to the eXpOS \u200b run time library\u200b . The OS pre-loads the library into memory pages 63 and 64 at boot time. The \u200b Exec system call sets the page table entries for the logical pages 0 and 1 of each process to physical pages 63 and 64. Pages are allocated using the GetFreePage \u200b function of the \u200bMemory Manager Module\u200b for stack and heap regions of memory during program loading. Control flow diagram for Exec system call In actual implementation, code and heap pages may not be allocated at the time of program loading, but may be allocated dynamically through a \u200b lazy strategy on demand . This makes use of the \u200b exception handling mechanism\u200b provided by the machine, and will be introduced in the road-map at appropriate stages. For simplicity of exposition, we assume here that all pages are allocated at load time. When a process invokes interrupt handlers, a separate stack (called the \u200b kernel stack \u200b of the process) is used for kernel mode handler execution. Interrupt handlers may invoke other kernel module functions. During such calls, the call addresses are stored in the kernel stack. To make space for the kernel stack, a separate page is allocated (this page is not part of the address space as this page is visible only to the kernel). This page is called the \u200b user-area page\u200b of the process. Since one page is more than sufficient for the kernel stack, some part of the user area page can be used for other purposes. Hence, the user area page is divided into two parts. One part is allocated for the \u200b kernel stack of the process. The other part stores the \u200b per-process resource table \u200b of the process (to be described below). There are some issues that were left out in the above description. \u200b Exec system call can be run only by an existing process. The system call overlays the existing program with the newly loaded program and continues to run with the same process id and user id. From an implementation point of view, this means that the newly loaded program uses the same process data structures - process table, page table, resource table and disk map table - of process that invokes \u200b Exec . Part of the contents of these tables that define attributes of the process like the process id and user id are also retained. After completion of its work, \u200b Exec \u200b system call transfers control to the starting address newly loaded code, so that the newly loaded program begins execution immediately in the RUNNING state . This summarizes how memory allocation for processes is carried out. Next we describe the data structures that store the metadata of each process. Process Table \u00b6 The process table is a global data structure that has an entry for each process. Each process is assigned a unique \u200b process id \u200b (called PID). The PID of a process is the index of the process's entry in the process table. The fields of the process table entries include\u200b user-id \u200b of the user executing the process (the semantics of user-id will not be discussed here), pointer to the \u200b page table of the process, index of the inode \u200b of the executable file that is loaded as the process, index of the \u200b user area page\u200b etc. The field \u200b input-buffer \u200b is a one word buffer used to store data read from terminal by the process. The field tick \u200b is used to keep track of \u201chow long\u201d the process has been in the memory (and will not be discussed here). Most of the fields are self explanatory and are described here . Per Process Disk Map table \u00b6 We have already seen that a process requires upto 11 pages of memory (10 page logical address space plus 1 user area page). Of these, the first two pages - corresponding to the library - will always remain loaded in memory. The OS may \u200b swap out \u200b heap, stack and user area pages into the swap area to make memory available for other processes. Similarly, the process may not maintain one or more code pages in memory. (There is no need to swap out code pages as the executable file is present in the disk.) The disk map table contains information about the disk block to which a page is stored when it is not present in the memory. Details of disk map table is given here . Per Process Resource Table \u00b6 A process may open files or semaphores using \u200b Open and \u200bSemget system calls respectively. These system calls return a file/semaphore \u200b descriptor \u200b which is used to access the file/semaphore. Moreover, associated which each such descriptor, there is a open file table entry / semaphore table entry whose index is maintained by the OS. The descriptors and open file table/semaphore table indices of files/semaphores opened/acquired by a process are stored in the per process resource table . We now describe process creation - the \u200b Fork \u200b system call, which will clarify how these data structures are set up. \u200b Fork \u200b allocates a new process table entry for a process using the \u200bGetPCBEntry \u200b function of the \u200b Process Manager Module . GetPCBEntry function copies the index of the new entry into the PID field of the process table. The PTLR field indicates the size (number of pages) of the address space allocated for the process. eXpOS sets the address space size uniformly to 10 pages for all processes. Hence this field is set to 10 by the GetPCBEntry function. The value of PTLR is copied to the PTLR register of the machine when the process is scheduled for execution. The machine uses this value to generate an exception if a process tries to generate an address beyond its address space. The start address of the page table of each process is fixed by eXpOS design. The \u200b GetPCBEntry function sets this value appropriately when it allocates a new process table entry. A newly created process (called the \u200b child process in OS jargon) inherits the User-ID of the process which invoked \u200b Fork \u200b (called the \u200b parent process\u200b). The \u200bchild shares parent's code and heap pages\u200b . Hence, Fork system call copies the page table entries corresponding to the heap and code pages of the parent into the corresponding page table entries of the child. The disk map table entries corresponding to these pages are also copied from the parent to the child. Fork \u200b allocates new stack pages for the child (using the \u200b GetFreePage function of the Memory \u200b Manager Module) and sets the page table entries for stack pages of the child process to the newly allocated pages. However, \u200b Fork \u200b then copies the contents of the parent's stack into the child's stack pages. Since the stack and the code pages are either same or identical, the child and the parent resumes execution from the same instruction in their code. (There are minor details of differences \u2013 to state one, the parent and the child differ in the return value stored in the stack by the \u200b Fork \u200b system call. We ignore the differences for now.) \u200b Fork allocates a new user area page for the child. Thus, the child gets its own kernel stack. The child process inherits all open file and semaphore descriptors of the parent. Hence \u200b Fork \u200b copies the open file descriptors from the resource table of the parent to the child. After initializing process meta-data in child\u2019s process table and setting up the address space of the child, Fork sets the state of the child process as CREATED \u200b. After completing the work, \u200b Fork returns to the parent and the parent process continues execution immediately. The OS scheduler will put the child to execution in due course of round robin scheduling. Control flow diagram for Fork system call The \u200b Exit system call results in\u200b termination \u200b of a process. Exit calls the \u200b Exit Process function of the process manager module to release all the memory (and swap pages if any) pages allocated to the process and close all open file and semaphore instances. The data structures allocated to the process are also released. \u200b Exit \u200b finally invokes the scheduler to run other processes. The first two processes - IDLE and INIT are hand created by the OS during boot loading. All further processes created through Fork operations from the INIT process and its descendent processes.","title":"Process Management Implementation"},{"location":"tutorials/process-management-implementation/#physical-memory","text":"An XEXE executable file will contain the \u200b code \u200b of the program (along with a small eight word \u200bheader\u200b in the beginning). As noted above, the size of an executable file is limited to maximum 4 disk blocks. Hence, to load the contents of an executable file into memory, the OS will need to allocate a maximum 4 pages of physical memory. To understand how memory allocation for a program is done, we look at the \u200b Exec system call .\u200b The \u200b Exec \u200b system call takes as argument an executable file\u2019s name and allocates memory for loading the executable file. It then loads the program into the allocated memory and sets it up for execution. When the loaded code is executed, the code will require more memory. Hence, each process is given a \u200b memory address space \u200b called the logical or virtual address space of the process. The eXpOS ABI stipulates that the address space of a process starts from logical address 0 and ends at logical address 5119 (10 pages \u2013 numbered logical page 0 to logical page 9 of the process.) Physical pages are allocated using \u200b GetFreePage \u200bfunction of the \u200b Memory Manager Module . The memory pages allocated to a process need not be contiguous. Hence, \u200b there must be a table for each process that describes the mapping of logical pages to physical pages .\u200b This table is called the \u200b per-process page table\u200b . The code of the executable program will contain reference to logical addresses, which has to be translated to physical addresses when the program is executed. This translation is done by the \u200b paging hardware\u200b of the XSM machine. This documentation assumes that the user is familiar with paging hardware (see XSM tutorial for more details). Hence, we will not describe page tables or the details of paging here. What is important here is the fact that the mapping of logical pages to physical pages is maintained in the per-process page table. The OS expects that the application program logically divides the 10 page logical address space of a process into four parts a) \u200b library \u200b (logical pages 0 and 1), b) \u200b heap (logical pages 2, 3), c) \u200b code \u200b (or sometimes called \u201ctext\u201d in OS jargon) (logical pages 4,5,6,7) and d) \u200b stack \u200b (logical pages 8,9). (These conventions are listed out in the ABI documentation and application programs (or program compilers) are expected to follow these regulations when preparing the executable file). The \u200b Exec system call uses the \u200b DiskLoad function of the \u200b Device Manager Module \u200b to load the contents of the executable file specified into logical pages 4,5,6 and 7. (That is, the disk blocks will be loaded to the physical pages corresponding to these logical pages). Logical pages 0 and 1 are mapped to the eXpOS \u200b run time library\u200b . The OS pre-loads the library into memory pages 63 and 64 at boot time. The \u200b Exec system call sets the page table entries for the logical pages 0 and 1 of each process to physical pages 63 and 64. Pages are allocated using the GetFreePage \u200b function of the \u200bMemory Manager Module\u200b for stack and heap regions of memory during program loading. Control flow diagram for Exec system call In actual implementation, code and heap pages may not be allocated at the time of program loading, but may be allocated dynamically through a \u200b lazy strategy on demand . This makes use of the \u200b exception handling mechanism\u200b provided by the machine, and will be introduced in the road-map at appropriate stages. For simplicity of exposition, we assume here that all pages are allocated at load time. When a process invokes interrupt handlers, a separate stack (called the \u200b kernel stack \u200b of the process) is used for kernel mode handler execution. Interrupt handlers may invoke other kernel module functions. During such calls, the call addresses are stored in the kernel stack. To make space for the kernel stack, a separate page is allocated (this page is not part of the address space as this page is visible only to the kernel). This page is called the \u200b user-area page\u200b of the process. Since one page is more than sufficient for the kernel stack, some part of the user area page can be used for other purposes. Hence, the user area page is divided into two parts. One part is allocated for the \u200b kernel stack of the process. The other part stores the \u200b per-process resource table \u200b of the process (to be described below). There are some issues that were left out in the above description. \u200b Exec system call can be run only by an existing process. The system call overlays the existing program with the newly loaded program and continues to run with the same process id and user id. From an implementation point of view, this means that the newly loaded program uses the same process data structures - process table, page table, resource table and disk map table - of process that invokes \u200b Exec . Part of the contents of these tables that define attributes of the process like the process id and user id are also retained. After completion of its work, \u200b Exec \u200b system call transfers control to the starting address newly loaded code, so that the newly loaded program begins execution immediately in the RUNNING state . This summarizes how memory allocation for processes is carried out. Next we describe the data structures that store the metadata of each process.","title":"Physical Memory"},{"location":"tutorials/process-management-implementation/#process-table","text":"The process table is a global data structure that has an entry for each process. Each process is assigned a unique \u200b process id \u200b (called PID). The PID of a process is the index of the process's entry in the process table. The fields of the process table entries include\u200b user-id \u200b of the user executing the process (the semantics of user-id will not be discussed here), pointer to the \u200b page table of the process, index of the inode \u200b of the executable file that is loaded as the process, index of the \u200b user area page\u200b etc. The field \u200b input-buffer \u200b is a one word buffer used to store data read from terminal by the process. The field tick \u200b is used to keep track of \u201chow long\u201d the process has been in the memory (and will not be discussed here). Most of the fields are self explanatory and are described here .","title":"Process Table"},{"location":"tutorials/process-management-implementation/#per-process-disk-map-table","text":"We have already seen that a process requires upto 11 pages of memory (10 page logical address space plus 1 user area page). Of these, the first two pages - corresponding to the library - will always remain loaded in memory. The OS may \u200b swap out \u200b heap, stack and user area pages into the swap area to make memory available for other processes. Similarly, the process may not maintain one or more code pages in memory. (There is no need to swap out code pages as the executable file is present in the disk.) The disk map table contains information about the disk block to which a page is stored when it is not present in the memory. Details of disk map table is given here .","title":"Per Process Disk Map table"},{"location":"tutorials/process-management-implementation/#per-process-resource-table","text":"A process may open files or semaphores using \u200b Open and \u200bSemget system calls respectively. These system calls return a file/semaphore \u200b descriptor \u200b which is used to access the file/semaphore. Moreover, associated which each such descriptor, there is a open file table entry / semaphore table entry whose index is maintained by the OS. The descriptors and open file table/semaphore table indices of files/semaphores opened/acquired by a process are stored in the per process resource table . We now describe process creation - the \u200b Fork \u200b system call, which will clarify how these data structures are set up. \u200b Fork \u200b allocates a new process table entry for a process using the \u200bGetPCBEntry \u200b function of the \u200b Process Manager Module . GetPCBEntry function copies the index of the new entry into the PID field of the process table. The PTLR field indicates the size (number of pages) of the address space allocated for the process. eXpOS sets the address space size uniformly to 10 pages for all processes. Hence this field is set to 10 by the GetPCBEntry function. The value of PTLR is copied to the PTLR register of the machine when the process is scheduled for execution. The machine uses this value to generate an exception if a process tries to generate an address beyond its address space. The start address of the page table of each process is fixed by eXpOS design. The \u200b GetPCBEntry function sets this value appropriately when it allocates a new process table entry. A newly created process (called the \u200b child process in OS jargon) inherits the User-ID of the process which invoked \u200b Fork \u200b (called the \u200b parent process\u200b). The \u200bchild shares parent's code and heap pages\u200b . Hence, Fork system call copies the page table entries corresponding to the heap and code pages of the parent into the corresponding page table entries of the child. The disk map table entries corresponding to these pages are also copied from the parent to the child. Fork \u200b allocates new stack pages for the child (using the \u200b GetFreePage function of the Memory \u200b Manager Module) and sets the page table entries for stack pages of the child process to the newly allocated pages. However, \u200b Fork \u200b then copies the contents of the parent's stack into the child's stack pages. Since the stack and the code pages are either same or identical, the child and the parent resumes execution from the same instruction in their code. (There are minor details of differences \u2013 to state one, the parent and the child differ in the return value stored in the stack by the \u200b Fork \u200b system call. We ignore the differences for now.) \u200b Fork allocates a new user area page for the child. Thus, the child gets its own kernel stack. The child process inherits all open file and semaphore descriptors of the parent. Hence \u200b Fork \u200b copies the open file descriptors from the resource table of the parent to the child. After initializing process meta-data in child\u2019s process table and setting up the address space of the child, Fork sets the state of the child process as CREATED \u200b. After completing the work, \u200b Fork returns to the parent and the parent process continues execution immediately. The OS scheduler will put the child to execution in due course of round robin scheduling. Control flow diagram for Fork system call The \u200b Exit system call results in\u200b termination \u200b of a process. Exit calls the \u200b Exit Process function of the process manager module to release all the memory (and swap pages if any) pages allocated to the process and close all open file and semaphore instances. The data structures allocated to the process are also released. \u200b Exit \u200b finally invokes the scheduler to run other processes. The first two processes - IDLE and INIT are hand created by the OS during boot loading. All further processes created through Fork operations from the INIT process and its descendent processes.","title":"Per Process Resource Table"},{"location":"tutorials/xsm-instruction-cycle/","text":"This tutorial will help you to understand the architectural features of the XSM machine necessary to for implementing the eXpOS operating system. These features will be used by the eXpOS kernel. The CPU of the XSM machine contains 20 general-purpose registers R0-R19, each of which can store an integer or a string. (see XSM specification ). Along with these are the registers stack pointer (SP), base pointer (BP) and instruction pointer (IP). There are other special purpose registers: PTBR, PTLR, EIP, EC, EPN, EMA and four ports P0, P1, P2, P3. We will discuss the roles of these soon. The machine's memory consists of 65536 memory words. Each word can store an integer or a string. The memory is divided into pages of 512 words each. Thus memory addresses 0 to 511 belong to page 0, 512-1023 belong to page 1 and so on. The last (page 127) contain memory addresses 65024 to 65535. The memory is word addressable. This means that XSM provides instructions that allows you to access any memory word. For instance, the instruction \"MOV R0, [1345]\" transfers the contents of memory location 1345 to register R0. The machine also has a disk having 512 blocks. Each disk block can store 512 words. Thus the total storage capacity is 512 x 512 = 262144 words. However, the disk is block addressable and not word addressable. XSM provides just three instructions to manipulate the disk \u2013 LOAD, LOADI and STORE. These instructions can be used to transfer a disk block to a memory page or back. Suppose we want to access the 10th word of block 12, then the only way to do so is to first transfer the 12th block to some memory page and then access the corresponding memory address. Apart from disk and memory, the machine also has three devices \u2013 an I/O Console, a timer and disk controller. We will discuss them later. The organisation of the XSM machine is given here The machine can operate in two fundamental modes of execution \u2013 privileged and unprivileged . When the machine gets powered on, it begins execution in the privileged mode. We will discuss unprivileged mode later and assume privileged mode execution in the following. Note The ExpOS documentation (unfortunately) uses the words \"kernel mode\" for privileged mode and \"user mode\" for unprivileged mode execution. This terminology arose because the OS kernel code runs in privileged mode and application programs run in unprivileged mode. However \"kernel\" and \"user\" are OS level abstractions, not connected to the machine, and the terminology is not used in this document while referring to architectural concepts. Boot-up \u00b6 What happens when the machine is powered on? All registers will be set to value zero. In particular, IP register also assumes value 0. Once powered on, the machine will start repeatedly executing the following fetch-execute cycle in privileged mode. Transfer the contents of two memory locations starting at the address stored in IP register to the CPU. The XSM machine treats the contents read like a machine instruction. This action is called the instruction fetch cycle. The next step is the execute cycle where the instruction fetched in Step 1 is executed by the machine. What happens here depends on the instruction. (See XSM instruction set .) For example, if the instruction fetched is \"MOV R0, [1256]\", the execute cycle action will result in the contents of memory location 1256 being transferred to register R0. If the instruction fetched is \"JMP 1110\", the value of the IP register will be set to 1110. The final step is to set the instruction pointer to the next instruction to be executed. Since each XSM instruction is two words, IP will normally be incremented by 2. There are exceptions to this rule. For instance in the case of \"JMP 1110\", IP is set to 1110 and hence not incremented. Thus the next fetch must be from 1110. After Step 3, the machine loops back to Step 1. Also see Wiki Link . When the machine is just powered on, IP value is 0. Hence, the first instruction will be fetched from memory locations 0 and 1. The XSM machine has a boot ROM containing just two instructions: Location Instruction Instruction semantics 0 LOADI 1, 0 Load contents of disk block 0 to memory page 1 2 JMP 512 Change IP value to 512 The bootstrap code is hard coded into a boot ROM so that the memory contents are not lost even after machine shutdown. This is necessary because when the machine is powered on, there must be some meaningful instruction at address 0 from where the first fetch takes place. Study the above bootstrap code carefully. What it does is to load the contents of disk block 0 to memory page 1 and then set the IP value to 512 so that the next fetch happens from memory address 512. This last step is very important because the machine will fetch contents of memory address 512 and 513 next, decode it assuming there is a valid instruction stored there and execute it and proceed from there. Hence, if you write an XSM assembly language program and store it in block 0 in such a way that your first instruction is stored in the first word of block 0, the machine will execute it immediately after JMP 512. Consequently, your code gets control of the machine, and the fetch-execute cycle continues with your code. You will be writing the OS bootstrap loader and storing it in block 0 in Stage 3 of the eXpOS roadmap. Note The boot ROM actually contains more information than what is written above. The boot ROM contains an interrupt vector table located between addresses 492 to 511. The vector table specifies the physical address to which interrupts must transfer control to. Locations 492,493,494 and 495 stores the addresses of exception handler, timer interrupt handler, disk interrupt handler and console interrupt handler. Location 496 contains the address of the first trap handler - INT 4, location 497 contains address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address and IP is set to this value. Note that the interrupt vector table is hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of the handlers. The figure below gives the layout of Boot ROM. Privileged mode of execution \u00b6 The privileged mode of execution is easy to comprehend. All instructions in the XSM machine instruction set described here will execute in the most natural way in the privileged mode of execution. Most of the instructions like data transfer instructions, arithmetic and logic instructions, and control flow instructions (JMP etc.) are straightforward to understand from the specification and not described here. Instead, we will focus here on the execution semantics of the following four (slightly non-trivial) instructions when executed in privileged mode \u2013 PUSH, POP, CALL and RET. The value of the SP register holds a pivotal role in these operations. The PUSH instruction results in the following actions: Contents of SP gets incremented by 1. The data specified by the PUSH instruction is transferred to the location pointed to by SP. IP gets incremented by 2 to point to the next instruction. Example: MOV SP, 1000 // SP register is loaded with value 1000. PUSH R0 // SP is set to 1001 and contents of R0 is copied to memory address 1001. The POP instruction is a reverse operation to PUSH. The contents of the memory address pointed to by SP will be retrieved to a register specified, and SP is decremented. The CALL instruction results in the following: Increment SP by one. Transfer contents of IP register + 2 to the memory address pointed to by SP. Set IP to the value of register/constant value specified in the CALL instruction. Example: MOV SP, 1000 // SP is set 1000 CALL 21110 // a) Increment SP to1001, b) Copy contents of IP to location 1001 c) MOV 21110 to IP register. As a consequence, the next instruction fetch will happen from address 21110. The RET instruction reverses the actions of a CALL instruction. The contents of address pointed to by SP register is copied to the IP register, and SP is decremented. Since IP is modified, the next instruction is fetched from the newly set value. Finally, we initiate a discussion on the most complicated instruction \u2013 IRET. This instruction can be only executed in privileged mode, but IRET is the only XSM instruction that results in the XSM machine to switch from the privileged mode to unprivileged mode. After an instruction fetch, if the XSM encounters the IRET instruction, the following actions take place: Enable paging and change from privileged mode to unprivileged mode Execute the RET instruction in the unprivileged mode. (The execution semantics now is different, and you must read XSM unpriviliged mode execution to understand how RET works in unprivileged mode). After the IRET instruction, the machine continues fetch-execute cycle, but in the unprivileged mode. Note that the change of machine mode from privileged to unprivileged happens before the actual fetch-execution cycle. Thus, to understand how an instruction works, one needs to know how paging and address translation works.","title":"XSM Instruction Cycle"},{"location":"tutorials/xsm-instruction-cycle/#boot-up","text":"What happens when the machine is powered on? All registers will be set to value zero. In particular, IP register also assumes value 0. Once powered on, the machine will start repeatedly executing the following fetch-execute cycle in privileged mode. Transfer the contents of two memory locations starting at the address stored in IP register to the CPU. The XSM machine treats the contents read like a machine instruction. This action is called the instruction fetch cycle. The next step is the execute cycle where the instruction fetched in Step 1 is executed by the machine. What happens here depends on the instruction. (See XSM instruction set .) For example, if the instruction fetched is \"MOV R0, [1256]\", the execute cycle action will result in the contents of memory location 1256 being transferred to register R0. If the instruction fetched is \"JMP 1110\", the value of the IP register will be set to 1110. The final step is to set the instruction pointer to the next instruction to be executed. Since each XSM instruction is two words, IP will normally be incremented by 2. There are exceptions to this rule. For instance in the case of \"JMP 1110\", IP is set to 1110 and hence not incremented. Thus the next fetch must be from 1110. After Step 3, the machine loops back to Step 1. Also see Wiki Link . When the machine is just powered on, IP value is 0. Hence, the first instruction will be fetched from memory locations 0 and 1. The XSM machine has a boot ROM containing just two instructions: Location Instruction Instruction semantics 0 LOADI 1, 0 Load contents of disk block 0 to memory page 1 2 JMP 512 Change IP value to 512 The bootstrap code is hard coded into a boot ROM so that the memory contents are not lost even after machine shutdown. This is necessary because when the machine is powered on, there must be some meaningful instruction at address 0 from where the first fetch takes place. Study the above bootstrap code carefully. What it does is to load the contents of disk block 0 to memory page 1 and then set the IP value to 512 so that the next fetch happens from memory address 512. This last step is very important because the machine will fetch contents of memory address 512 and 513 next, decode it assuming there is a valid instruction stored there and execute it and proceed from there. Hence, if you write an XSM assembly language program and store it in block 0 in such a way that your first instruction is stored in the first word of block 0, the machine will execute it immediately after JMP 512. Consequently, your code gets control of the machine, and the fetch-execute cycle continues with your code. You will be writing the OS bootstrap loader and storing it in block 0 in Stage 3 of the eXpOS roadmap. Note The boot ROM actually contains more information than what is written above. The boot ROM contains an interrupt vector table located between addresses 492 to 511. The vector table specifies the physical address to which interrupts must transfer control to. Locations 492,493,494 and 495 stores the addresses of exception handler, timer interrupt handler, disk interrupt handler and console interrupt handler. Location 496 contains the address of the first trap handler - INT 4, location 497 contains address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address and IP is set to this value. Note that the interrupt vector table is hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of the handlers. The figure below gives the layout of Boot ROM.","title":"Boot-up"},{"location":"tutorials/xsm-instruction-cycle/#privileged-mode-of-execution","text":"The privileged mode of execution is easy to comprehend. All instructions in the XSM machine instruction set described here will execute in the most natural way in the privileged mode of execution. Most of the instructions like data transfer instructions, arithmetic and logic instructions, and control flow instructions (JMP etc.) are straightforward to understand from the specification and not described here. Instead, we will focus here on the execution semantics of the following four (slightly non-trivial) instructions when executed in privileged mode \u2013 PUSH, POP, CALL and RET. The value of the SP register holds a pivotal role in these operations. The PUSH instruction results in the following actions: Contents of SP gets incremented by 1. The data specified by the PUSH instruction is transferred to the location pointed to by SP. IP gets incremented by 2 to point to the next instruction. Example: MOV SP, 1000 // SP register is loaded with value 1000. PUSH R0 // SP is set to 1001 and contents of R0 is copied to memory address 1001. The POP instruction is a reverse operation to PUSH. The contents of the memory address pointed to by SP will be retrieved to a register specified, and SP is decremented. The CALL instruction results in the following: Increment SP by one. Transfer contents of IP register + 2 to the memory address pointed to by SP. Set IP to the value of register/constant value specified in the CALL instruction. Example: MOV SP, 1000 // SP is set 1000 CALL 21110 // a) Increment SP to1001, b) Copy contents of IP to location 1001 c) MOV 21110 to IP register. As a consequence, the next instruction fetch will happen from address 21110. The RET instruction reverses the actions of a CALL instruction. The contents of address pointed to by SP register is copied to the IP register, and SP is decremented. Since IP is modified, the next instruction is fetched from the newly set value. Finally, we initiate a discussion on the most complicated instruction \u2013 IRET. This instruction can be only executed in privileged mode, but IRET is the only XSM instruction that results in the XSM machine to switch from the privileged mode to unprivileged mode. After an instruction fetch, if the XSM encounters the IRET instruction, the following actions take place: Enable paging and change from privileged mode to unprivileged mode Execute the RET instruction in the unprivileged mode. (The execution semantics now is different, and you must read XSM unpriviliged mode execution to understand how RET works in unprivileged mode). After the IRET instruction, the machine continues fetch-execute cycle, but in the unprivileged mode. Note that the change of machine mode from privileged to unprivileged happens before the actual fetch-execution cycle. Thus, to understand how an instruction works, one needs to know how paging and address translation works.","title":"Privileged mode of execution"},{"location":"tutorials/xsm-interrupts-tutorial/","text":"We have seen that an application program can transfer control to a privileged mode trap handler using the INT instruction. Hardware interrupts (or simply interrupts) are useful to transfer control into handlers that must be run on the occurrence of hardware events. XSM machine supports three hardware interrupts - timer interrupt, disk interrupt and console interrupt. Associated with each interrupt, there is an interrupt handler routine. These handler routines are called timer interrupt handler, disk interrupt handler and the console interrupt handler respectively. The addresses of these handlers are stored in locations 493, 494 and 495 of the ROM and are preset to values 2048, 3072 and 4096. Thus, the OS bootstrap code must load the timer interrupt handler into memory starting from 2048, disk interrupt handler from address 3072 and console interrupt handler from 4096. Timer Interrupt \u00b6 XSM has a timer device which can be set to interrupt the machine at regular intervals of time. You can run the XSM simulator with the option --timer : xsm --timer 10 Then, every time the machine completes executing ten instructions in unprivileged mode, the machine does the following actions: *Push the IP value into the top of the stack. Set IP to value stored in the interrupt vector table entry for the timer interrupt handler. The vector table entry for timer interrupt is located at physical address 493 in page 0 (ROM) of XSM and the value 2048 is preset in this location. Hence, the IP register gets value 2048. The machine then switches to to privileged mode and address translation is disabled. Hence, next instruction will be fetched from physical address 2048. (See Boot ROM and Boot block section in XSM Machine Organization documentation) * Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Note that the action is similar to the INT instruction except that the application does not invoke the timer handler using the INT instruction. In fact, the application does not have any control over the process. Interrupts are disabled when machine runs in the privileged mode so that there are no race conditions. After returning from the timer interrupt handler, the next entry into the handler occurs only after the machine executes another ten instructions in user mode. The timer device can be used to ensure that privileged code gets control of the machine at regular intervals of time. This is necessary to ensure that an application once started is not allowed to run \"forever.\" In a time-sharing environment, the timer handler invokes the scheduler of the OS to do a context switch to a different process when one process has completed its time quantum. Important Note In real machines, timer, disk and console are devices that are external to the CPU. (This is why the XSM machine model draws them outside the machine's CPU). Such devices are generally attached to programmable device-controllers in the computer system's mother-board containing the CPU. These devices are typically either I/O mapped (via ports) or memory mapped and the exact configuration is determined by the hardware manufacturer. The hardware manufacturer supplies a device driver software for each of these device controller. The device driver software is typically loaded into memory along with the OS kernel during machine bootstrap. Thus, the device drivers run as part of the kernel. Each device driver contains a set of functions that can be invoked from the OS kernel. These device driver functions in turn contain code that issues commands to the respective device controller. Finally, the device controller contains the software and hardware necessary to make the device physically behave in the required way based on the commands received. Thus, in a real systems, the OS loads into the memory the timer device's driver during bootstrap. (Here, the driver is assumed to have been pre-loaded into the disk. However modern systems also permit drivers to be loaded at run time without re-booting the OS) After this, some kernel boot code will invoke the appropriate functions of the device driver to perform initial configuration of the timer device so as to interrupt the machine at regular intervals of time. The timer device will have some output wire that (after passing through several intermediate hardware circuits) connects to some interrupt pin of the CPU. The OS bootstrap code will instruct the device driver to configure the device in such manner that the device sends a signal to the interrupt pin at regular intervals of time. Each time such signal is received, the CPU saves the next instruction's IP value to the stack and transfers control to the interrupt routine. Thus, it is important to understand that the XSM machine is a software simulated machine and hence deviates from real systems. No real life CPU comes with hardware that counts the number of instructions and invoke the timer interrupt handler after a pre-set number of instructions as XSM machine does. The same comment holds for the disk and the console interrupts as well. Disk and Console Interrupts \u00b6 The other two interrupt handlers are associated with the disk and the console. The XSM privileged instructions load(page_num,block_num) and store(block_num, page_num) are used for transfer of data from disk to memory and memory to disk. The actual data transfer involves time delay as disk access is slow. On encountering a load/store instruction, the XSM machine will start a disk transfer, increment IP by two and fetch the next instruction without waiting for the data transfer to be completed. When the actual disk-memory data transfer is completed, the disk controller will raise the disk interrupt. Similarly, the IN instruction initiates a console input but will not suspend machine execution till some input is read. Machine execution proceeds to the next instruction in the program. When the user enters data, the data is transferred to port P0, and a console interrupt is raised by the console device. After the execution of each instruction in unprivileged mode, the machine checks whether a pending disk/console/timer interrupt. If so, the machine does the following actions: * Push the IP value into the top of the stack. Set IP to value stored in the interrupt vector table entry for the timer interrupt handler. The vector table entry for timer interrupt is located at physical address 493 in page 0 (ROM) of XSM and the value 2048 is preset in this location. Hence, the IP register gets value 1. The machine then switches to to privileged mode and address translation is disabled. Hence, next instruction will be fetched from physical address 2048. (See Boot ROM and Boot block section in XSM Machine Organization documentation) Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. The XSM machine enables interrupts only when the machine is executing in unprivileged mode. (If a previously initiated load/store/IN operation is completed while XSM is running in privileged mode, the machine waits for next transition to unprivileged mode before processing the interrupt.) Exception handling in XSM \u00b6 What must happen when an application running in unprivileged mode contains an illegal instruction or a divide by zero instruction or an instruction that tries to write data into a logical address outside its address space? Clearly, the machine must not halt, for otherwise, one application will be able to halt the whole system. The correct action must be to transfer control to some privileged mode handler. This privileged mode handler is the exception handler . The exception handler code must start at memory address 1024. (page 2). While an application is running in unprivileged mode on the XSM machine, if any of the following events occur, the XSM machine raises an exception. a) Illegal Memory Access: Occurs when any address generated by the application lies outside its logical address space. This also occurs when the process tries to write into pages whose Write access bit is not set in the page table. Recall that the logical page number generated for a valid instruction should be between 0 and the value of (512 * PTLR) - 1. b) Illegal instructions: Occurs when an application tries to execute an instruction not belonging to the instruction set or when an operand/data in an instruction is not legal. (Example: MOV 4 R0, MOV IP, 4) c) Arithmetic exception: Occurs when there is a division/modulus by zero. (Example: DIV R0, 0) In all the above cases, the typical action is for the exception handler code is to pass control to other privileged mode OS routines to terminate the application and schedule other applications. d) Page fault: This is the most significant exception handling function that must be understood clearly. A page fault occurs if an instruction contains an address whose logical page number is within the range 0 to PTLR-1 and the valid bit in the corresponding page table entry is set to to 0. Page fault exception can occur either during instruction fetch or operand fetch. Suppose during execution of an application, the value of IP reaches value \u2013 say 3000. The next fetch will try to translate the logical address 3000 to physical address using the page table. The logical page number corresponding to address 3000 is 3000 DIV 512 = 5. The machine must look up the page table entry corresponding to logical page 5. If the valid bit for this entry is set to 0, the page reference is invalid. In this case, the machine will raise an exception. The second possibility for a page fault to occur is during operand fetch. Suppose an instruction is successfully fetched \u2013 say MOV R0, [5000]. To execute the instruction, the machine will try to translate the logical address 5000 using page table. As in the previous case, if the page is not valid, then the machine raises an exception. Page fault exception allows the OS to delay allocation of memory pages to a program in execution till the program actually tries to access the page. The OS can set the valid bit of unallocated pages in the address space of the process to 0 and wait for the program to generate a page fault when (and if) the program tries to access the page. The page fault handler can be designed to attach the required memory pages to the program (often loading the page from the disk) so that the program can resume execution. Such \"lazy\" allocation minimizes memory usage and will help the OS to concurrently accomodate more programs in memory than what would be possible without deploying such lazy allocation. This technique is called demand paging . When the machine raises an exception, the following occurs: 1. IP is set to value 1024 and machine switches to privileged mode. Thus, the next instruction will be fetched from the exception handler. 2. The machine sets several CPU registers with values that describe (to the exception handler) the cause of the exception. These are explained below: a) EIP (Exception IP): The logical IP value of the unprivileged mode instruction that caused the exception is stored in this register. For example, if the instruction MOV R0, [5000], fetched from IP=3000 caused an exception because the logical page corresponding to address 5000 (logical page 8) was invalid, the EIP will be loaded with value 3000. b) EPN (Exception Page Number): The contents of this register are valid only in the case of a page fault exception. The logical page number that caused the page fault is stored in this register. In the above example, if MOV R0, [5000] caused a page fault because logical page 8 was invalid, then EPN will have value 8. Note that if the instruction fetch caused a page fault (say IP=3000), then EPN would have contained value 5. c) EC (Exception Cause): The EC register will indicate the cause of the exception \u2013 values are set as below. (i) Page Fault: The value stored in the EC register for this exception is 0. (ii) Illegal instruction: The value stored in the EC register for this exception is 1. (iii) Illegal memory access: The value stored in the EC register for this exception is 2. (iv) Arithmetic exception: The value stored in the EC register for this exception is 3. d) EMA (Exception memory address): The value of this register is relevant only in the case of illegal memory access. The illegal memory which was tried to be accessed is stored in the register. Either the address referred to is outside the range 0 - 512*(PTLR-1) or a write is attempted to a page which is read-only . The XSM interrupt/exception handling documentation gives a more detailed technical description of the actions performed by the machine when interrupts or exceptions occur. You may have a quick look at the documentation now, but refer to relevant sections of the documentation only as and when required.","title":"XSM Interrupts tutorial"},{"location":"tutorials/xsm-interrupts-tutorial/#timer-interrupt","text":"XSM has a timer device which can be set to interrupt the machine at regular intervals of time. You can run the XSM simulator with the option --timer : xsm --timer 10 Then, every time the machine completes executing ten instructions in unprivileged mode, the machine does the following actions: *Push the IP value into the top of the stack. Set IP to value stored in the interrupt vector table entry for the timer interrupt handler. The vector table entry for timer interrupt is located at physical address 493 in page 0 (ROM) of XSM and the value 2048 is preset in this location. Hence, the IP register gets value 2048. The machine then switches to to privileged mode and address translation is disabled. Hence, next instruction will be fetched from physical address 2048. (See Boot ROM and Boot block section in XSM Machine Organization documentation) * Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. Note that the action is similar to the INT instruction except that the application does not invoke the timer handler using the INT instruction. In fact, the application does not have any control over the process. Interrupts are disabled when machine runs in the privileged mode so that there are no race conditions. After returning from the timer interrupt handler, the next entry into the handler occurs only after the machine executes another ten instructions in user mode. The timer device can be used to ensure that privileged code gets control of the machine at regular intervals of time. This is necessary to ensure that an application once started is not allowed to run \"forever.\" In a time-sharing environment, the timer handler invokes the scheduler of the OS to do a context switch to a different process when one process has completed its time quantum. Important Note In real machines, timer, disk and console are devices that are external to the CPU. (This is why the XSM machine model draws them outside the machine's CPU). Such devices are generally attached to programmable device-controllers in the computer system's mother-board containing the CPU. These devices are typically either I/O mapped (via ports) or memory mapped and the exact configuration is determined by the hardware manufacturer. The hardware manufacturer supplies a device driver software for each of these device controller. The device driver software is typically loaded into memory along with the OS kernel during machine bootstrap. Thus, the device drivers run as part of the kernel. Each device driver contains a set of functions that can be invoked from the OS kernel. These device driver functions in turn contain code that issues commands to the respective device controller. Finally, the device controller contains the software and hardware necessary to make the device physically behave in the required way based on the commands received. Thus, in a real systems, the OS loads into the memory the timer device's driver during bootstrap. (Here, the driver is assumed to have been pre-loaded into the disk. However modern systems also permit drivers to be loaded at run time without re-booting the OS) After this, some kernel boot code will invoke the appropriate functions of the device driver to perform initial configuration of the timer device so as to interrupt the machine at regular intervals of time. The timer device will have some output wire that (after passing through several intermediate hardware circuits) connects to some interrupt pin of the CPU. The OS bootstrap code will instruct the device driver to configure the device in such manner that the device sends a signal to the interrupt pin at regular intervals of time. Each time such signal is received, the CPU saves the next instruction's IP value to the stack and transfers control to the interrupt routine. Thus, it is important to understand that the XSM machine is a software simulated machine and hence deviates from real systems. No real life CPU comes with hardware that counts the number of instructions and invoke the timer interrupt handler after a pre-set number of instructions as XSM machine does. The same comment holds for the disk and the console interrupts as well.","title":"Timer Interrupt"},{"location":"tutorials/xsm-interrupts-tutorial/#disk-and-console-interrupts","text":"The other two interrupt handlers are associated with the disk and the console. The XSM privileged instructions load(page_num,block_num) and store(block_num, page_num) are used for transfer of data from disk to memory and memory to disk. The actual data transfer involves time delay as disk access is slow. On encountering a load/store instruction, the XSM machine will start a disk transfer, increment IP by two and fetch the next instruction without waiting for the data transfer to be completed. When the actual disk-memory data transfer is completed, the disk controller will raise the disk interrupt. Similarly, the IN instruction initiates a console input but will not suspend machine execution till some input is read. Machine execution proceeds to the next instruction in the program. When the user enters data, the data is transferred to port P0, and a console interrupt is raised by the console device. After the execution of each instruction in unprivileged mode, the machine checks whether a pending disk/console/timer interrupt. If so, the machine does the following actions: * Push the IP value into the top of the stack. Set IP to value stored in the interrupt vector table entry for the timer interrupt handler. The vector table entry for timer interrupt is located at physical address 493 in page 0 (ROM) of XSM and the value 2048 is preset in this location. Hence, the IP register gets value 1. The machine then switches to to privileged mode and address translation is disabled. Hence, next instruction will be fetched from physical address 2048. (See Boot ROM and Boot block section in XSM Machine Organization documentation) Note If the value in the SP register after incrementing SP is an invalid address (i.e., not in the range 0 to PTLR*512-1) then the machine generates an illegal memory access exception (see section below on exception handling). The machine will re-execute steps (1) and (2) immedietly after retrun to unprivileged mode, before executing any other instruction in unprivileged mode. The XSM machine enables interrupts only when the machine is executing in unprivileged mode. (If a previously initiated load/store/IN operation is completed while XSM is running in privileged mode, the machine waits for next transition to unprivileged mode before processing the interrupt.)","title":"Disk and Console Interrupts"},{"location":"tutorials/xsm-interrupts-tutorial/#exception-handling-in-xsm","text":"What must happen when an application running in unprivileged mode contains an illegal instruction or a divide by zero instruction or an instruction that tries to write data into a logical address outside its address space? Clearly, the machine must not halt, for otherwise, one application will be able to halt the whole system. The correct action must be to transfer control to some privileged mode handler. This privileged mode handler is the exception handler . The exception handler code must start at memory address 1024. (page 2). While an application is running in unprivileged mode on the XSM machine, if any of the following events occur, the XSM machine raises an exception. a) Illegal Memory Access: Occurs when any address generated by the application lies outside its logical address space. This also occurs when the process tries to write into pages whose Write access bit is not set in the page table. Recall that the logical page number generated for a valid instruction should be between 0 and the value of (512 * PTLR) - 1. b) Illegal instructions: Occurs when an application tries to execute an instruction not belonging to the instruction set or when an operand/data in an instruction is not legal. (Example: MOV 4 R0, MOV IP, 4) c) Arithmetic exception: Occurs when there is a division/modulus by zero. (Example: DIV R0, 0) In all the above cases, the typical action is for the exception handler code is to pass control to other privileged mode OS routines to terminate the application and schedule other applications. d) Page fault: This is the most significant exception handling function that must be understood clearly. A page fault occurs if an instruction contains an address whose logical page number is within the range 0 to PTLR-1 and the valid bit in the corresponding page table entry is set to to 0. Page fault exception can occur either during instruction fetch or operand fetch. Suppose during execution of an application, the value of IP reaches value \u2013 say 3000. The next fetch will try to translate the logical address 3000 to physical address using the page table. The logical page number corresponding to address 3000 is 3000 DIV 512 = 5. The machine must look up the page table entry corresponding to logical page 5. If the valid bit for this entry is set to 0, the page reference is invalid. In this case, the machine will raise an exception. The second possibility for a page fault to occur is during operand fetch. Suppose an instruction is successfully fetched \u2013 say MOV R0, [5000]. To execute the instruction, the machine will try to translate the logical address 5000 using page table. As in the previous case, if the page is not valid, then the machine raises an exception. Page fault exception allows the OS to delay allocation of memory pages to a program in execution till the program actually tries to access the page. The OS can set the valid bit of unallocated pages in the address space of the process to 0 and wait for the program to generate a page fault when (and if) the program tries to access the page. The page fault handler can be designed to attach the required memory pages to the program (often loading the page from the disk) so that the program can resume execution. Such \"lazy\" allocation minimizes memory usage and will help the OS to concurrently accomodate more programs in memory than what would be possible without deploying such lazy allocation. This technique is called demand paging . When the machine raises an exception, the following occurs: 1. IP is set to value 1024 and machine switches to privileged mode. Thus, the next instruction will be fetched from the exception handler. 2. The machine sets several CPU registers with values that describe (to the exception handler) the cause of the exception. These are explained below: a) EIP (Exception IP): The logical IP value of the unprivileged mode instruction that caused the exception is stored in this register. For example, if the instruction MOV R0, [5000], fetched from IP=3000 caused an exception because the logical page corresponding to address 5000 (logical page 8) was invalid, the EIP will be loaded with value 3000. b) EPN (Exception Page Number): The contents of this register are valid only in the case of a page fault exception. The logical page number that caused the page fault is stored in this register. In the above example, if MOV R0, [5000] caused a page fault because logical page 8 was invalid, then EPN will have value 8. Note that if the instruction fetch caused a page fault (say IP=3000), then EPN would have contained value 5. c) EC (Exception Cause): The EC register will indicate the cause of the exception \u2013 values are set as below. (i) Page Fault: The value stored in the EC register for this exception is 0. (ii) Illegal instruction: The value stored in the EC register for this exception is 1. (iii) Illegal memory access: The value stored in the EC register for this exception is 2. (iv) Arithmetic exception: The value stored in the EC register for this exception is 3. d) EMA (Exception memory address): The value of this register is relevant only in the case of illegal memory access. The illegal memory which was tried to be accessed is stored in the register. Either the address referred to is outside the range 0 - 512*(PTLR-1) or a write is attempted to a page which is read-only . The XSM interrupt/exception handling documentation gives a more detailed technical description of the actions performed by the machine when interrupts or exceptions occur. You may have a quick look at the documentation now, but refer to relevant sections of the documentation only as and when required.","title":"Exception handling in XSM"},{"location":"tutorials/xsm-unprivileged-tutorial/","text":"XSM Unprivileged Mode Execution \u00b6 In this tutorial we will explain the unprivileged mode execution of XSM machine. Please go through Paging specification and Virtual address space model before reading further. In the privileged mode, a memory address refers to the actual physical memory address. For instance, the instruction sequence: MOV SP, 1000 PUSH R0 The first instruction sets stack pointer register SP to 1000. The PUSH instruction will first increment SP (to value 1001) and then transfers contents of the register R0 to the top of the stack - that is - to the memory location 1001 pointed to by SP. However, PUSH and other unprivileged instructions have a different behaviour when executed in unprivileged mode. PUSH will increment SP to 1001 as before, but the memory address to which contents of R0 is copied is determined in a different way. The machine will treat the contents of SP as a logical address, find out the physical address corresponding to the logical address 1001 using the address translation mechanism of XSM and transfer contents of R0 to that location. We discribe the address translation process below. Address Translation \u00b6 The translation of a logical address to physical address is done completely by the machine's paging hardware. The sequence of steps involved may abstractly be described by the following steps, which will be described in detail with examples soon: Given a logical address \u2013 find the logical page number and offset specified by the address. Search the page table to find the physical page number from the logical page number. Multiply physical page number by page size to find the physical page address . physical address = physical page address + offset . The machine assumes that the PTBR register holds the base(starting) address of the page table in memory. Since PTBR register can be accessed only in privileged mode, your code must have set the PTBR register to store the address of the page table before entering unprivileged mode execution. Moreover, to get the address translation hardware to work the way you want it to, your must write privilaged code to set appropriate values in the page table before executing an IRET instruction to switch the machine to unprivileged mode . Thus, some setup work needs to be done in the privileged mode before a switch to unprivileged mode. How does the machine translate a logical address \u2013 say 1001- to the corresponding physical address? The machine does the following sequence of actions. Let us assume that PTBR contains value \u2013 say 3000, set previously. 1. Calculate, logical_page_number = logical_address DIV page_size \u2003\u2003 \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003= (1001 DIV 512) = 1. 2. Calculate, offset = logical_address MOD page_size = (1001 MOD 512) = 489. 3. Find, the page_table_address = contents of PTBR = 3000. 4. Find, physical_page_number = value stored in address (page_table_address + 2 x logical_page_number) \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003= value stored in address (3000 + 2 x 1) \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003= value stored in address 3002. \u2003\u2003 Suppose that this value is 7. (The minimum value possible is 0 and the maximum value possible is 127 \u2013 why?). 5. Calculate, physical_address = physical_page_number x page_size + offset \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 = 7 x 512 + 489 = 4073. Thus, the instruction PUSH R0 in the code shown in the beginning will transfer contents of R0 to the physical address 4073. There are several points to mention here. The PUSH operation will be successful only if the auxiliary information for logical page number 1 in the page table is set to ensure that the page is valid. Otherwise, the machine will generate an exception, switching back to privileged mode. We will discuss exception handling later. To get a better picture of the unprivileged mode execution, we need to digress briefly to discuss the underlying theoretical concepts. Paging and virtual memory \u00b6 First of all, as an OS designer, why should you learn to run the machine in unprivileged mode at all? An OS will have to allow concurrent execution of other \"user programs\" (or application programs). The OS needs to be careful not to allow one application program to run malicious code that corrupts other user programs or the OS itself. This requires provision to run application programs in a \"less privileged\" mode of execution where only a limited set of instructions can be executed, and only limited memory space and system resources are accessible. Architecture support is needed to achieve this. The architecture support provided by the XSM machine is the support for the XSM virtual machine model . When a program runs in unprivileged mode on the XSM machine, only a restricted machine model is available to the application program. A key architectural technique that supports such a model is paging. Paging allows the OS to provide each application program running in unprivileged mode with a virtual (or logical) address space. The application's access can be restricted to this address space. The virtual address space (or the logical address space) of an application is a contiguous memory address space starting from logical address 0 to a maximum limit set by the OS. Thus the addresses found in the application program's code shall only be between 0 and the maximum limit. Each application's code and data must fit into its logical address space. The OS views this address space as being divided into logical pages of 512 words each. Hence logical addresses 0 to 511 belongs to logical page 0 of the program, logical addresses 512 to 1023 belongs to logical page 1 and so forth. The XSM machine on the other hand has 128 physical pages into which the logical pages of all programs running in the system has to be mapped into. Hence, there needs to be some data structure to map the logical pages of each program to the corresponding physical pages. This data structure is called the page table . The OS maintains a seperate page table for each program that stores the physical page number to which each logical page of the program is mapped to. Note that the page table is a \"meta data\" about a program maintained by the OS. The OS stores the table outside the address space of the process and the process has no access to it. When a program is executed in unpreviliged mode, the logical address must be translated on the fly to the corresponding physical addresses. This requires support from the hardware. XSM paging hardware mechanism provides the requred support. The XSM machine expects that the OS sets up the page table for each program in the memory, adhering to a certain format and set the PTBR/PTLR registers properly before running a program is unpreviliged mode. Next we describe in detail how this must be done. Setting up Paging for an Application \u00b6 Before running an application program in unpreviliged mode, the OS must set up the application's page table data and values of PTLR and PTBR. Note that this set up code must run in previliged mode (why?). The steps are as given below Set the PTLR register to define the address space maximum limit. Set up a valid page table in memory and the PTBR register to the beginning address of the page table of the particular application . Set up the application's stack. Set SP to point to the top of the stack. Compute the physical address corresponding to the logical address in SP. Then, copy the logical address of the first instruction (entry point) that much be fetched after IRET into this physical memory location and execute IRET. We explain each of the above four steps in detail: Step 1: XSM stipulates that the address space limit of an application must be a multiple of XSM page size=512. Suppose, the OS decides that the application must be provided with a virtual address space of 10 pages, then the PTLR register must be set to value 10. In this case, the logical address space of the application will be between 0 and 512x10-1=5119. (The ExpOS kernel that you design sets the address space of every application to 10 pages). While executing in user mode, if an instruction in the application refers to a logical address beyond this limit, the machine will raise an exception. This will result in the machine switching to privileged mode and control transferred to the starting address of the exception handler routine (memory address 1024 \u2013 see Machine Organisation ). For example, if PTLR=10 and if the application contains an instruction like MOV R0, [6000], an exception will be generated because the instructions contain addresses outside the logical address space set by PTLR. As another example, JMP 7000 instruction will result in setting IP to 7000 and in the very next fetch cycle, an exception will be generated because an instruction fetch will be attempted from a logical address beyond the address space. If SP holds value 5119, then a PUSH instruction will similarly result in an exception. Exception handling will be discussed in detail later. Step 2: Once the address space size is determined by PTLR value, a page table has to be set up in the memory for the application to tell the hardware which logical page is mapped to which physical page. The number of entries in the page table is determined by the number of pages allocated to the application. Thus if PTLR=10, then the page table must contain ten entries. Each page table entry requires two memory words and contains information about the corresponding logical page. That is, the first two words of the page table contain information about logical page 0, the next two about logical page 1 and so on. If PTLR=10, the page table of the application will require total 20 memory words. The first word of each page table entry contains the physical page number of the corresponding logical page. The second word stores auxiliary information . The auxiliary information for a page consists of four binary values: a) Reference bit, b) Valid bit, c) Write permission bit, d) Dirty bit. Proper values for Valid (V bit) and the Write permission bit (W bit) must be set by your privileged code of step 2 before starting unprivileged mode execution. We describe these settings below. If the Valid bit is set to 0, the page table entry is considered invalid. In this case, if any logical address accessing the page will generate an exception. If the write permission bit is set to 0, the application will not have write permission to the page. For example, if entry 0 of the page table has valid bit 0, then an instruction like MOV [100], R0 or JMP 112 will generate an exception. If entry 0 of the page table has write permission bit 0, then MOV [100], R0 that modifies the page will raise an exception. However, if the valid bit is 1, MOV R0,[100] or JMP 112 that do not modify the contents of the page will execute normally in unprivileged mode if the write bit is 0. The Reference bit and the Dirty bit are set by the machine. When the application is executing, if an address is generated accessing some logical page, then the reference bit of the page is set automatically to 1 by the machine. For instance, MOV R0, [1500] accesses the logical page 2 and hence the reference bit of the corresponding page table entry will be set to 1 by the machine automatically. The dirty bit is set if the instruction modifies the contents of the page. MOV R0, [1500] does not result in the machine setting the dirty bit for logical page 2 because the instruction does not modify contents of the page. However MOV [1500], R0 sets the dirty bit. Before we move into the next step of setting up the application's stack, we need to figure out what initial setting the application expects from the OS. Basically, there must be some pre-defined convention regarding the initialization of the application's stack between the application and the OS. Similarly the OS should know which is the first instruction that must be executed when the application is run in unpreviliged mode in order to transfer control to that instruction. We digress briefly to discuss these finer details. Loading application to address space \u00b6 Suppose an application contains 3 pages of code. Assume that the first page of the code has been loaded into physical page number 100 and second page to 110. Assume that the third page is not loaded into memory. (The load instruction can be used in the privileged mode to transfer a program in disk to memory). Suppose the first few lines of the application code is as below: MOV R0, 1 MOV R1, 0 L0: CMP R0, 10 JNZ L1 ADD R1, R0 ADD R0, 1 JMP L0 L1: ... JMP addresses are indicated by labels for clarity of understanding. The actual executable code will not have any labels, but will only have logical addresses. Suppose L0 corresponds to logical address \u2013 say 2060, then the address of L1 must be 2070 because each XSM instruction takes two words. Counting backwards, the address of the first instruction must have been 2056. Here we must particularly note something - the application code is designed to be loaded by the OS to start execution from logical address 2056. The code with labels replaced by logical addresses will be as follows: MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 This code will not execute correctly unless loaded as the fifth logical page because jump addresses will be invalid otherwise. Thus, the physical number corresponding to logical page 4 (starting at logical address 2048) must be 100. Assume that the code continues to the next logical pages, the page number for logical page 5 must be set to 110. The valid bit for both entries must be set to 1. The valid bit for logical page 6 must be set to 0 since the page is not valid. As noted previously, setting the valid bit to 0 ensures that the machine will generate an exception if either of instruction fetch or operand fetch is attempted from that page. Finally, since code pages are expected not to be modified during program execution, the Write permission bit must be set to 0. (Setting write permission to 0 for code pages is a necessary exercise. A typical multi-tasking OS will permit several applications to share code pages in memory. It then is the duty of the OS to ensure that one application doesn't modify the shared code to \"hack\" others.) The essential idea to understand here is that each application's code is designed (by some programmer) to be loaded into certain part of its virtual address space. Although paging allows logical pages to be mapped to arbitrary physical pages, the logical page where each region of code must be loaded cannot be changed. (Note: There are architectures that allow application programmers write position independent code that can be loaded anywhere within an application's address space. XSM does not support this feature, and we will not discuss this topic here.) Finally, the page table itself needs to be stored somewhere in memory. Note that the page table is a \"meta data\" maintained by the OS about an application and must not be stored in memory allocated to the logical address space of the program (why?). Let us assume that page table of the application begins at - say - physical address 1000. Then, the entries in the page table must be set as below: Location Entry Desciption 1000 xx page 0 physical page number - irrelevant (not loaded) 1001 ?? page 0 invalid \u2013 what must be the value set here? 1002 xx page 1 physical page number (not loaded) 1003 ?? page 1 invalid \u2013 what must be the value set here? 1004 xx page 2 physical page number (not loaded) 1005 ?? page 2 invalid - what must be the value set here? 1006 xx Page 3 not loaded 1007 ?? Must be set to invalid 1008 100 Page 4 \u2013 loaded to physical page 100 1009 ?? Page 4 \u2013 Valid, Write Only \u2013 what must be set here? 1010 110 Page 5 \u2013 loaded to physical page 110 1011 ?? Page 5 Valid, write only 1012 xx Page not loaded 1013 ?? Invalid 1014 xx Page not loaded 1015 ?? Invalid 1016 xx Page not loaded 1017 ?? Invalid 1018 xx Page not loaded 1019 ?? Invalid Since PTLR=10, the page table requires 20 words. We must set all unloaded pages invalid. The PTBR register must be set to value 1000 (MOV PTBR, 1000). Now address translation for logical page 4 and logical page 5 will correctly translate to physical page 100 and physical page 110. To summarise: a) The valid bit must be set for the pages loaded. b) Logical page to physical page mapping must be set up in the page table correctly c) PTBR register must be set to the start address of the page table. Important Note Suppose you are designing the loader program of an operating system to load and execute unknown applications, how will you figure out where must be code pages of the application loaded? In general, there is no way unless there is a prior agreement with the application programmer. Hence, each operating system publishes an interface specification called Application Binary Interface (ABI) that fixes this and several other matters. In the eXpOS project, the ABI convention is that the application code must be loaded to logical pages 4,5,6 and 7. The details are given in the eXpOS ABI given here . Thus the code area of an eXpOS application will start at address 2048. The above example had followed this eXpOS ABI. Step 3: A minimum of one page must be allocated to each application for maintaining a stack before the application is executed in unprivileged mode in the XSM machine. The IRET instruction (to be discussed next) that changes from privileged mode to unprivileged mode accesses the stack page. The pages allocated for stack must be writable , and hence the write permission for these pages must be set in the page table. Normally an application's run-time data will be stored in the stack . Arguments to function calls in the application and return values are also normally passed through the stack. How the application uses the stack is its concern, but an aspect important to us here is that the INT instruction which allows an application to switch the mode back to the privileged mode, as well as the IRET instruction that allows a mode switch from privileged mode to unprivileged mode, requires the stack. The eXpOS ABI of our concern stipulates that logical pages 8 and 9 of an application must be allocated for the stack. Hence the stack begins at logical address 4096. Therefore, before an application is run for the first time, the stack pointer register SP is set to value 4095 (why not 4096?). Continuing the above example, if the physical pages allocated for the stack are 120 and 121, then the page table starting at address 1000 will be as below: Location Entry Desciption 1000 xx page 0 physical page number - irrelevant (not loaded) 1001 ?? page 0 invalid \u2013 what must be the value set here? 1002 xx page 1 physical page number (not loaded) 1003 ?? page 1 invalid \u2013 what must be the value set here? 1004 xx page 2 physical page number (not loaded) 1005 ?? page 2 invalid - what must be the value set here? 1006 xx Page 3 not loaded 1007 ?? Must be set to invalid 1008 100 Page 4 \u2013 loaded to physical page100 1009 ?? Page 4 \u2013 Valid, Write Only \u2013 what must be set here? 1010 110 Page 5 \u2013 loaded to physical page 110 1011 ?? Page 5 Valid, write only 1012 xx Page not loaded 1013 ?? Invalid 1014 xx Page not loaded 1015 ?? Invalid 1016 120 First stack page 1017 ?? Valid, Write permission on \u2013 what must be set here? 1018 121 Second Stack page 1019 ?? Valid, Write permission on \u2013 what must be set here? Step 4: Initilize the instruction pointer (IP) for the application We must set up the instruction pointer so that the first instruction of the application is fetched and executed from the correct address. Once the application starts execution, it has to manage it's own contol flow, until it transfers control back to the OS by executing an INT instruction. How can the OS figure out the correct logical address to which the the instruction pointer must be initialized? There must be some mechanism by which the application communicates to the OS the logical address of the first instruction from which it must start execution. The OS ABI must specify the interface using which the application can tell the operating system the correct starting address. The way in which the eXpOS ABI does this is as follows. Each eXpOS application can have at most four code pages of machine instructions. An eXpOS compatible XEXE executable file must contain these instructions listed in sequential order. But before the code, the file must contain an eight-word header . The code follows the header. The first word (word 0) must be set to value 0. For the time being, we will be concerned only about the second word (word 1) called entry point . This word must contain the logical address of the first instruction to be executed when the application is run. The values of the remaining six words can be ignored. Coming back to the code in our running example: MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 .. .. The first instruction must begin at address 2056. The contents of an XEXE executable file containing this code (header included) would be as below: 0 2056 0 0 0 0 0 0 MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 .. .. Note that the start address of the code given in our example was specifically designed to be 2056 so that the first instruction starts after eight words from the beginning of logical page 4 (starting at 2048), leaving space for the header in the page. eXpOS ABI stipulates that an XEXE executable file (including the header) must fit into four pages of memory. Thus, an executable file can have an eight-word header plus a maximum of 1020 instructions (Why?). The first executable instruction will be in address 2056. (However, the application might want to start execution from some other address \u2013 say 3000 - in that case, the entry point value must be set to the value 3000.) In the present case, since the above code is designed to start from 2056, the entry point value must be set to 2056. Note It is generally the responsibility of the application programmer to design the application so that the header, entry point value and the code are organized correctly. In the eXpOS system, you will be using the ExpL programming language for writing application programs and the ExpL compiler supplied to you will correctly generate target code and header (including entry point value) properly so that the ABI conventions are satisfied. When the file is loaded into memory, the contents will be mapped to logical pages 4 to 7. In our running example, logical page 4 was mapped to physical page 100, starting at physical address 51200. The second word (51201) will contain the entry point value (in our example \u2013 2056). Thus, when the application is run in unprivileged mode, IP must be set to this value. To do this: Place the entry point value to the top of the stack and set the stack pointer to point to this value. Execute the IRET instruction. The instruction sequence in the specific example above will be: MOV R0, [51201] // move entry point value to a register MOV [61440], R0 // store entry point to first word in the stack = 120x512=61440 MOV SP, 4096 // SP to contain logical addresses, corresponding physical address being 61440. (How?) IRET // Unprivileged mode execution starts. The IRET instruction will first change the mode to unprivileged, then transfer the contents of logical address 4096 (translating to contents of physical address 61440) into the IP register and decrement the stack pointer. Since this value is the entry point (in the above example, 2056), IP will be loaded with this value and next instruction fetch will happen from logical address 2056 (what will be the physical address?). Since then, the fetch-execute cycle continues in the unprivileged mode with paging enabled. A program running in the unprivileged mode may switch the machine back to the privileged mode using the trap instruction INT n. Where n can take values from 4 up to 18 The INT n instruction will result in the following: Increment SP and transfer contents of IP register to the stack. (SP register holds the logical address of the top of the stack). Machine switches to privileged mode. IP is loaded with a value that depends on the value of n. This will be explained below. For example, INT 4 results in IP being loaded with physical address page 10 (address 5120). Since a switch to privileged mode takes place, paging will be disabled, and the next fetch will happen from physical address 5120. Similarly INT 5 will result in next fetch occurring from physical address 6144. There are two concepts to understand here. a) How does the machine map interrupt numbers to addresses? (which interrupt maps to which memory address) b) Why should an application use this instruction? INT 4 to INT 18 instructions are called software interrupts or traps. The XSM machine has an interrupt vector table that maps each interrupt number to a corresponding address (of the interrupt handler). The vector table is stored starting from physical address 492 of memory. Locations 492,493,494 and 495 stores the addresses of the exception handler, the timer interrupt handler, the disk interrupt handler and console interrupt handler. Location 496 contains the address of the first trap handler - INT 4, location 497 contains the address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address, and IP is set to this value. Since the values are hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of the handlers. Why do you need software interrupts? As explained previously, application programs run in unprivileged mode and cannot access memory beyond its virtual address space. If the application wishes to do tasks like input-output or disk access which are not permitted in unprivileged mode, then the OS must provide a \"regulated access mechanism\" through which the application can invoke an OS routine to do the task. The OS routine must be designed to run in privileged mode, must validate the application's request (permissions, etc.), perform the task and then return to the application. OS handlers that can be called from application programs for privileged tasks are known as system call routines. Software interrupts provide hardware support mechanism for implementing system calls. In the eXpOS project, the mapping of each system call to interrupt numbers is given here . (Note that in some cases, the same interrupt handler is designed to handle multiple system calls. In such cases the system call number passed as an argument to the interrupt handler is used to identify the correct service). Typically, the application pushes the input arguments to a system call handler into the stack before executing INT instruction. The handler after doing the corresponding action stores return value in a designated position in the application's stack. The conventions regarding how arguments and return values are passed are stipulated in the ABI . Example: In our running example, suppose the instruction at logical address 2070 is INT 4: 0 2056 0 0 0 0 0 0 MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 INT 4 The INT 4 instruction will push the logical address of the next instruction (2072) into the physical location corresponding to the top of the stack (SP contains logical address of the top of the stack). The INT instruction then sets IP register to address 5120 by refering to the vector table and changes the machine mode to privileged. Hence, the next instruction will be fetched from 5120. Later when the interrupt handler executes an IRET instruction, the IP value (2072) to be popped off the stack so that execution continues with the instruction at logical address 2072. (Note that the above description had assumed that the INT handler has not changed the value of PTBR. What would happen if PTBR is changed?) Note In the eXpOS project, you will have to write code for various trap handlers and store it on the disk. Your bootstrap loader must load these interrupt handlers from the disk to the appropriate memory pages. The eXpOS system has clear specification regarding the disk locations where each interrupt handler must be stored and the memory pages to which the OS bootstrap loader must place each interrupt handler. This is specified in the eXpOS Memory Organisation documentation. This completes our discussion on XSM unprivileged execution mode.","title":"XSM Unprivileged tutorial"},{"location":"tutorials/xsm-unprivileged-tutorial/#xsm-unprivileged-mode-execution","text":"In this tutorial we will explain the unprivileged mode execution of XSM machine. Please go through Paging specification and Virtual address space model before reading further. In the privileged mode, a memory address refers to the actual physical memory address. For instance, the instruction sequence: MOV SP, 1000 PUSH R0 The first instruction sets stack pointer register SP to 1000. The PUSH instruction will first increment SP (to value 1001) and then transfers contents of the register R0 to the top of the stack - that is - to the memory location 1001 pointed to by SP. However, PUSH and other unprivileged instructions have a different behaviour when executed in unprivileged mode. PUSH will increment SP to 1001 as before, but the memory address to which contents of R0 is copied is determined in a different way. The machine will treat the contents of SP as a logical address, find out the physical address corresponding to the logical address 1001 using the address translation mechanism of XSM and transfer contents of R0 to that location. We discribe the address translation process below.","title":"XSM Unprivileged Mode Execution"},{"location":"tutorials/xsm-unprivileged-tutorial/#address-translation","text":"The translation of a logical address to physical address is done completely by the machine's paging hardware. The sequence of steps involved may abstractly be described by the following steps, which will be described in detail with examples soon: Given a logical address \u2013 find the logical page number and offset specified by the address. Search the page table to find the physical page number from the logical page number. Multiply physical page number by page size to find the physical page address . physical address = physical page address + offset . The machine assumes that the PTBR register holds the base(starting) address of the page table in memory. Since PTBR register can be accessed only in privileged mode, your code must have set the PTBR register to store the address of the page table before entering unprivileged mode execution. Moreover, to get the address translation hardware to work the way you want it to, your must write privilaged code to set appropriate values in the page table before executing an IRET instruction to switch the machine to unprivileged mode . Thus, some setup work needs to be done in the privileged mode before a switch to unprivileged mode. How does the machine translate a logical address \u2013 say 1001- to the corresponding physical address? The machine does the following sequence of actions. Let us assume that PTBR contains value \u2013 say 3000, set previously. 1. Calculate, logical_page_number = logical_address DIV page_size \u2003\u2003 \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003= (1001 DIV 512) = 1. 2. Calculate, offset = logical_address MOD page_size = (1001 MOD 512) = 489. 3. Find, the page_table_address = contents of PTBR = 3000. 4. Find, physical_page_number = value stored in address (page_table_address + 2 x logical_page_number) \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003= value stored in address (3000 + 2 x 1) \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003= value stored in address 3002. \u2003\u2003 Suppose that this value is 7. (The minimum value possible is 0 and the maximum value possible is 127 \u2013 why?). 5. Calculate, physical_address = physical_page_number x page_size + offset \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003 = 7 x 512 + 489 = 4073. Thus, the instruction PUSH R0 in the code shown in the beginning will transfer contents of R0 to the physical address 4073. There are several points to mention here. The PUSH operation will be successful only if the auxiliary information for logical page number 1 in the page table is set to ensure that the page is valid. Otherwise, the machine will generate an exception, switching back to privileged mode. We will discuss exception handling later. To get a better picture of the unprivileged mode execution, we need to digress briefly to discuss the underlying theoretical concepts.","title":"Address Translation"},{"location":"tutorials/xsm-unprivileged-tutorial/#paging-and-virtual-memory","text":"First of all, as an OS designer, why should you learn to run the machine in unprivileged mode at all? An OS will have to allow concurrent execution of other \"user programs\" (or application programs). The OS needs to be careful not to allow one application program to run malicious code that corrupts other user programs or the OS itself. This requires provision to run application programs in a \"less privileged\" mode of execution where only a limited set of instructions can be executed, and only limited memory space and system resources are accessible. Architecture support is needed to achieve this. The architecture support provided by the XSM machine is the support for the XSM virtual machine model . When a program runs in unprivileged mode on the XSM machine, only a restricted machine model is available to the application program. A key architectural technique that supports such a model is paging. Paging allows the OS to provide each application program running in unprivileged mode with a virtual (or logical) address space. The application's access can be restricted to this address space. The virtual address space (or the logical address space) of an application is a contiguous memory address space starting from logical address 0 to a maximum limit set by the OS. Thus the addresses found in the application program's code shall only be between 0 and the maximum limit. Each application's code and data must fit into its logical address space. The OS views this address space as being divided into logical pages of 512 words each. Hence logical addresses 0 to 511 belongs to logical page 0 of the program, logical addresses 512 to 1023 belongs to logical page 1 and so forth. The XSM machine on the other hand has 128 physical pages into which the logical pages of all programs running in the system has to be mapped into. Hence, there needs to be some data structure to map the logical pages of each program to the corresponding physical pages. This data structure is called the page table . The OS maintains a seperate page table for each program that stores the physical page number to which each logical page of the program is mapped to. Note that the page table is a \"meta data\" about a program maintained by the OS. The OS stores the table outside the address space of the process and the process has no access to it. When a program is executed in unpreviliged mode, the logical address must be translated on the fly to the corresponding physical addresses. This requires support from the hardware. XSM paging hardware mechanism provides the requred support. The XSM machine expects that the OS sets up the page table for each program in the memory, adhering to a certain format and set the PTBR/PTLR registers properly before running a program is unpreviliged mode. Next we describe in detail how this must be done.","title":"Paging and virtual memory"},{"location":"tutorials/xsm-unprivileged-tutorial/#setting-up-paging-for-an-application","text":"Before running an application program in unpreviliged mode, the OS must set up the application's page table data and values of PTLR and PTBR. Note that this set up code must run in previliged mode (why?). The steps are as given below Set the PTLR register to define the address space maximum limit. Set up a valid page table in memory and the PTBR register to the beginning address of the page table of the particular application . Set up the application's stack. Set SP to point to the top of the stack. Compute the physical address corresponding to the logical address in SP. Then, copy the logical address of the first instruction (entry point) that much be fetched after IRET into this physical memory location and execute IRET. We explain each of the above four steps in detail: Step 1: XSM stipulates that the address space limit of an application must be a multiple of XSM page size=512. Suppose, the OS decides that the application must be provided with a virtual address space of 10 pages, then the PTLR register must be set to value 10. In this case, the logical address space of the application will be between 0 and 512x10-1=5119. (The ExpOS kernel that you design sets the address space of every application to 10 pages). While executing in user mode, if an instruction in the application refers to a logical address beyond this limit, the machine will raise an exception. This will result in the machine switching to privileged mode and control transferred to the starting address of the exception handler routine (memory address 1024 \u2013 see Machine Organisation ). For example, if PTLR=10 and if the application contains an instruction like MOV R0, [6000], an exception will be generated because the instructions contain addresses outside the logical address space set by PTLR. As another example, JMP 7000 instruction will result in setting IP to 7000 and in the very next fetch cycle, an exception will be generated because an instruction fetch will be attempted from a logical address beyond the address space. If SP holds value 5119, then a PUSH instruction will similarly result in an exception. Exception handling will be discussed in detail later. Step 2: Once the address space size is determined by PTLR value, a page table has to be set up in the memory for the application to tell the hardware which logical page is mapped to which physical page. The number of entries in the page table is determined by the number of pages allocated to the application. Thus if PTLR=10, then the page table must contain ten entries. Each page table entry requires two memory words and contains information about the corresponding logical page. That is, the first two words of the page table contain information about logical page 0, the next two about logical page 1 and so on. If PTLR=10, the page table of the application will require total 20 memory words. The first word of each page table entry contains the physical page number of the corresponding logical page. The second word stores auxiliary information . The auxiliary information for a page consists of four binary values: a) Reference bit, b) Valid bit, c) Write permission bit, d) Dirty bit. Proper values for Valid (V bit) and the Write permission bit (W bit) must be set by your privileged code of step 2 before starting unprivileged mode execution. We describe these settings below. If the Valid bit is set to 0, the page table entry is considered invalid. In this case, if any logical address accessing the page will generate an exception. If the write permission bit is set to 0, the application will not have write permission to the page. For example, if entry 0 of the page table has valid bit 0, then an instruction like MOV [100], R0 or JMP 112 will generate an exception. If entry 0 of the page table has write permission bit 0, then MOV [100], R0 that modifies the page will raise an exception. However, if the valid bit is 1, MOV R0,[100] or JMP 112 that do not modify the contents of the page will execute normally in unprivileged mode if the write bit is 0. The Reference bit and the Dirty bit are set by the machine. When the application is executing, if an address is generated accessing some logical page, then the reference bit of the page is set automatically to 1 by the machine. For instance, MOV R0, [1500] accesses the logical page 2 and hence the reference bit of the corresponding page table entry will be set to 1 by the machine automatically. The dirty bit is set if the instruction modifies the contents of the page. MOV R0, [1500] does not result in the machine setting the dirty bit for logical page 2 because the instruction does not modify contents of the page. However MOV [1500], R0 sets the dirty bit. Before we move into the next step of setting up the application's stack, we need to figure out what initial setting the application expects from the OS. Basically, there must be some pre-defined convention regarding the initialization of the application's stack between the application and the OS. Similarly the OS should know which is the first instruction that must be executed when the application is run in unpreviliged mode in order to transfer control to that instruction. We digress briefly to discuss these finer details.","title":"Setting up Paging for an Application"},{"location":"tutorials/xsm-unprivileged-tutorial/#loading-application-to-address-space","text":"Suppose an application contains 3 pages of code. Assume that the first page of the code has been loaded into physical page number 100 and second page to 110. Assume that the third page is not loaded into memory. (The load instruction can be used in the privileged mode to transfer a program in disk to memory). Suppose the first few lines of the application code is as below: MOV R0, 1 MOV R1, 0 L0: CMP R0, 10 JNZ L1 ADD R1, R0 ADD R0, 1 JMP L0 L1: ... JMP addresses are indicated by labels for clarity of understanding. The actual executable code will not have any labels, but will only have logical addresses. Suppose L0 corresponds to logical address \u2013 say 2060, then the address of L1 must be 2070 because each XSM instruction takes two words. Counting backwards, the address of the first instruction must have been 2056. Here we must particularly note something - the application code is designed to be loaded by the OS to start execution from logical address 2056. The code with labels replaced by logical addresses will be as follows: MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 This code will not execute correctly unless loaded as the fifth logical page because jump addresses will be invalid otherwise. Thus, the physical number corresponding to logical page 4 (starting at logical address 2048) must be 100. Assume that the code continues to the next logical pages, the page number for logical page 5 must be set to 110. The valid bit for both entries must be set to 1. The valid bit for logical page 6 must be set to 0 since the page is not valid. As noted previously, setting the valid bit to 0 ensures that the machine will generate an exception if either of instruction fetch or operand fetch is attempted from that page. Finally, since code pages are expected not to be modified during program execution, the Write permission bit must be set to 0. (Setting write permission to 0 for code pages is a necessary exercise. A typical multi-tasking OS will permit several applications to share code pages in memory. It then is the duty of the OS to ensure that one application doesn't modify the shared code to \"hack\" others.) The essential idea to understand here is that each application's code is designed (by some programmer) to be loaded into certain part of its virtual address space. Although paging allows logical pages to be mapped to arbitrary physical pages, the logical page where each region of code must be loaded cannot be changed. (Note: There are architectures that allow application programmers write position independent code that can be loaded anywhere within an application's address space. XSM does not support this feature, and we will not discuss this topic here.) Finally, the page table itself needs to be stored somewhere in memory. Note that the page table is a \"meta data\" maintained by the OS about an application and must not be stored in memory allocated to the logical address space of the program (why?). Let us assume that page table of the application begins at - say - physical address 1000. Then, the entries in the page table must be set as below: Location Entry Desciption 1000 xx page 0 physical page number - irrelevant (not loaded) 1001 ?? page 0 invalid \u2013 what must be the value set here? 1002 xx page 1 physical page number (not loaded) 1003 ?? page 1 invalid \u2013 what must be the value set here? 1004 xx page 2 physical page number (not loaded) 1005 ?? page 2 invalid - what must be the value set here? 1006 xx Page 3 not loaded 1007 ?? Must be set to invalid 1008 100 Page 4 \u2013 loaded to physical page 100 1009 ?? Page 4 \u2013 Valid, Write Only \u2013 what must be set here? 1010 110 Page 5 \u2013 loaded to physical page 110 1011 ?? Page 5 Valid, write only 1012 xx Page not loaded 1013 ?? Invalid 1014 xx Page not loaded 1015 ?? Invalid 1016 xx Page not loaded 1017 ?? Invalid 1018 xx Page not loaded 1019 ?? Invalid Since PTLR=10, the page table requires 20 words. We must set all unloaded pages invalid. The PTBR register must be set to value 1000 (MOV PTBR, 1000). Now address translation for logical page 4 and logical page 5 will correctly translate to physical page 100 and physical page 110. To summarise: a) The valid bit must be set for the pages loaded. b) Logical page to physical page mapping must be set up in the page table correctly c) PTBR register must be set to the start address of the page table. Important Note Suppose you are designing the loader program of an operating system to load and execute unknown applications, how will you figure out where must be code pages of the application loaded? In general, there is no way unless there is a prior agreement with the application programmer. Hence, each operating system publishes an interface specification called Application Binary Interface (ABI) that fixes this and several other matters. In the eXpOS project, the ABI convention is that the application code must be loaded to logical pages 4,5,6 and 7. The details are given in the eXpOS ABI given here . Thus the code area of an eXpOS application will start at address 2048. The above example had followed this eXpOS ABI. Step 3: A minimum of one page must be allocated to each application for maintaining a stack before the application is executed in unprivileged mode in the XSM machine. The IRET instruction (to be discussed next) that changes from privileged mode to unprivileged mode accesses the stack page. The pages allocated for stack must be writable , and hence the write permission for these pages must be set in the page table. Normally an application's run-time data will be stored in the stack . Arguments to function calls in the application and return values are also normally passed through the stack. How the application uses the stack is its concern, but an aspect important to us here is that the INT instruction which allows an application to switch the mode back to the privileged mode, as well as the IRET instruction that allows a mode switch from privileged mode to unprivileged mode, requires the stack. The eXpOS ABI of our concern stipulates that logical pages 8 and 9 of an application must be allocated for the stack. Hence the stack begins at logical address 4096. Therefore, before an application is run for the first time, the stack pointer register SP is set to value 4095 (why not 4096?). Continuing the above example, if the physical pages allocated for the stack are 120 and 121, then the page table starting at address 1000 will be as below: Location Entry Desciption 1000 xx page 0 physical page number - irrelevant (not loaded) 1001 ?? page 0 invalid \u2013 what must be the value set here? 1002 xx page 1 physical page number (not loaded) 1003 ?? page 1 invalid \u2013 what must be the value set here? 1004 xx page 2 physical page number (not loaded) 1005 ?? page 2 invalid - what must be the value set here? 1006 xx Page 3 not loaded 1007 ?? Must be set to invalid 1008 100 Page 4 \u2013 loaded to physical page100 1009 ?? Page 4 \u2013 Valid, Write Only \u2013 what must be set here? 1010 110 Page 5 \u2013 loaded to physical page 110 1011 ?? Page 5 Valid, write only 1012 xx Page not loaded 1013 ?? Invalid 1014 xx Page not loaded 1015 ?? Invalid 1016 120 First stack page 1017 ?? Valid, Write permission on \u2013 what must be set here? 1018 121 Second Stack page 1019 ?? Valid, Write permission on \u2013 what must be set here? Step 4: Initilize the instruction pointer (IP) for the application We must set up the instruction pointer so that the first instruction of the application is fetched and executed from the correct address. Once the application starts execution, it has to manage it's own contol flow, until it transfers control back to the OS by executing an INT instruction. How can the OS figure out the correct logical address to which the the instruction pointer must be initialized? There must be some mechanism by which the application communicates to the OS the logical address of the first instruction from which it must start execution. The OS ABI must specify the interface using which the application can tell the operating system the correct starting address. The way in which the eXpOS ABI does this is as follows. Each eXpOS application can have at most four code pages of machine instructions. An eXpOS compatible XEXE executable file must contain these instructions listed in sequential order. But before the code, the file must contain an eight-word header . The code follows the header. The first word (word 0) must be set to value 0. For the time being, we will be concerned only about the second word (word 1) called entry point . This word must contain the logical address of the first instruction to be executed when the application is run. The values of the remaining six words can be ignored. Coming back to the code in our running example: MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 .. .. The first instruction must begin at address 2056. The contents of an XEXE executable file containing this code (header included) would be as below: 0 2056 0 0 0 0 0 0 MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 .. .. Note that the start address of the code given in our example was specifically designed to be 2056 so that the first instruction starts after eight words from the beginning of logical page 4 (starting at 2048), leaving space for the header in the page. eXpOS ABI stipulates that an XEXE executable file (including the header) must fit into four pages of memory. Thus, an executable file can have an eight-word header plus a maximum of 1020 instructions (Why?). The first executable instruction will be in address 2056. (However, the application might want to start execution from some other address \u2013 say 3000 - in that case, the entry point value must be set to the value 3000.) In the present case, since the above code is designed to start from 2056, the entry point value must be set to 2056. Note It is generally the responsibility of the application programmer to design the application so that the header, entry point value and the code are organized correctly. In the eXpOS system, you will be using the ExpL programming language for writing application programs and the ExpL compiler supplied to you will correctly generate target code and header (including entry point value) properly so that the ABI conventions are satisfied. When the file is loaded into memory, the contents will be mapped to logical pages 4 to 7. In our running example, logical page 4 was mapped to physical page 100, starting at physical address 51200. The second word (51201) will contain the entry point value (in our example \u2013 2056). Thus, when the application is run in unprivileged mode, IP must be set to this value. To do this: Place the entry point value to the top of the stack and set the stack pointer to point to this value. Execute the IRET instruction. The instruction sequence in the specific example above will be: MOV R0, [51201] // move entry point value to a register MOV [61440], R0 // store entry point to first word in the stack = 120x512=61440 MOV SP, 4096 // SP to contain logical addresses, corresponding physical address being 61440. (How?) IRET // Unprivileged mode execution starts. The IRET instruction will first change the mode to unprivileged, then transfer the contents of logical address 4096 (translating to contents of physical address 61440) into the IP register and decrement the stack pointer. Since this value is the entry point (in the above example, 2056), IP will be loaded with this value and next instruction fetch will happen from logical address 2056 (what will be the physical address?). Since then, the fetch-execute cycle continues in the unprivileged mode with paging enabled. A program running in the unprivileged mode may switch the machine back to the privileged mode using the trap instruction INT n. Where n can take values from 4 up to 18 The INT n instruction will result in the following: Increment SP and transfer contents of IP register to the stack. (SP register holds the logical address of the top of the stack). Machine switches to privileged mode. IP is loaded with a value that depends on the value of n. This will be explained below. For example, INT 4 results in IP being loaded with physical address page 10 (address 5120). Since a switch to privileged mode takes place, paging will be disabled, and the next fetch will happen from physical address 5120. Similarly INT 5 will result in next fetch occurring from physical address 6144. There are two concepts to understand here. a) How does the machine map interrupt numbers to addresses? (which interrupt maps to which memory address) b) Why should an application use this instruction? INT 4 to INT 18 instructions are called software interrupts or traps. The XSM machine has an interrupt vector table that maps each interrupt number to a corresponding address (of the interrupt handler). The vector table is stored starting from physical address 492 of memory. Locations 492,493,494 and 495 stores the addresses of the exception handler, the timer interrupt handler, the disk interrupt handler and console interrupt handler. Location 496 contains the address of the first trap handler - INT 4, location 497 contains the address of INT 5 handler and so on. When the machine encounters an INT n instruction, the corresponding ROM location is searched for the handler address, and IP is set to this value. Since the values are hard-coded in the ROM code of the XSM simulator given to you, you cannot change the addresses of the handlers. Why do you need software interrupts? As explained previously, application programs run in unprivileged mode and cannot access memory beyond its virtual address space. If the application wishes to do tasks like input-output or disk access which are not permitted in unprivileged mode, then the OS must provide a \"regulated access mechanism\" through which the application can invoke an OS routine to do the task. The OS routine must be designed to run in privileged mode, must validate the application's request (permissions, etc.), perform the task and then return to the application. OS handlers that can be called from application programs for privileged tasks are known as system call routines. Software interrupts provide hardware support mechanism for implementing system calls. In the eXpOS project, the mapping of each system call to interrupt numbers is given here . (Note that in some cases, the same interrupt handler is designed to handle multiple system calls. In such cases the system call number passed as an argument to the interrupt handler is used to identify the correct service). Typically, the application pushes the input arguments to a system call handler into the stack before executing INT instruction. The handler after doing the corresponding action stores return value in a designated position in the application's stack. The conventions regarding how arguments and return values are passed are stipulated in the ABI . Example: In our running example, suppose the instruction at logical address 2070 is INT 4: 0 2056 0 0 0 0 0 0 MOV R0, 1 MOV R1, 0 CMP R0, 10 JNZ 2070 ADD R1, R0 ADD R0, 1 JMP 2060 INT 4 The INT 4 instruction will push the logical address of the next instruction (2072) into the physical location corresponding to the top of the stack (SP contains logical address of the top of the stack). The INT instruction then sets IP register to address 5120 by refering to the vector table and changes the machine mode to privileged. Hence, the next instruction will be fetched from 5120. Later when the interrupt handler executes an IRET instruction, the IP value (2072) to be popped off the stack so that execution continues with the instruction at logical address 2072. (Note that the above description had assumed that the INT handler has not changed the value of PTBR. What would happen if PTBR is changed?) Note In the eXpOS project, you will have to write code for various trap handlers and store it on the disk. Your bootstrap loader must load these interrupt handlers from the disk to the appropriate memory pages. The eXpOS system has clear specification regarding the disk locations where each interrupt handler must be stored and the memory pages to which the OS bootstrap loader must place each interrupt handler. This is specified in the eXpOS Memory Organisation documentation. This completes our discussion on XSM unprivileged execution mode.","title":"Loading application to address space"}]}